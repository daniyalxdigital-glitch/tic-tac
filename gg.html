<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Futuristic Tic-Tac-Toe</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <!-- Audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

       <style>
        
:root {
    --midnight-950: #0a0e1a;
    --midnight-900: #111827;
    --midnight-800: #1f2937;
    --midnight-700: #374151;
    
    --accent-primary: #6366f1;
    --accent-primary-light: #818cf8;
    --accent-primary-dark: #4f46e5;
    --accent-glow: rgba(99, 102, 241, 0.5);
    --accent-glow-strong: rgba(99, 102, 241, 0.7);
    
    --accent-secondary: #ec4899;
    --accent-secondary-light: #f472b6;
    --accent-secondary-glow: rgba(236, 72, 153, 0.5);
    
    --accent-gold: #f59e0b;
    --accent-gold-light: #fbbf24;
    
    --text-primary: #f9fafb;
    --text-secondary: #d1d5db;
    --text-muted: #9ca3af;
    --text-inverse: #111827;
    
    --surface-primary: rgba(31, 41, 55, 0.85);
    --surface-elevated: rgba(55, 65, 81, 0.7);
    --surface-hover: rgba(75, 85, 99, 0.8);
    --surface-glass: rgba(255, 255, 255, 0.05);
    --surface-glass-hover: rgba(255, 255, 255, 0.08);
    
    --border-subtle: rgba(148, 163, 184, 0.15);
    --border-medium: rgba(148, 163, 184, 0.25);
    --border-strong: rgba(148, 163, 184, 0.4);
    --border-glow: rgba(99, 102, 241, 0.3);
    
    /* Enhanced Shadows */
    --shadow-xs: 0 1px 3px rgba(0, 0, 0, 0.12);
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.2);
    --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.25);
    --shadow-lg: 0 8px 40px rgba(0, 0, 0, 0.35);
    --shadow-xl: 0 12px 60px rgba(0, 0, 0, 0.45);
    --shadow-glow: 0 0 30px var(--accent-glow);
    --shadow-glow-strong: 0 0 50px var(--accent-glow-strong);
    --shadow-inner: inset 0 2px 8px rgba(0, 0, 0, 0.15);
    
    /* Theme Compatibility */
    --bg-color-start: #1e3a8a;
    --bg-color-end: #0a0e1a;
    --text-dark: #f9fafb;
    --text-light: #9ca3af;
    --text-title: #6366f1;
    --menu-panel-bg: rgba(31, 41, 55, 0.85);
    --menu-panel-shadow: 0 8px 40px rgba(0, 0, 0, 0.35);
    --input-bg: rgba(55, 65, 81, 0.7);
    --input-text: #f9fafb;
    --input-focus-border: #6366f1;
    --btn-glow-shadow: 0 0 30px rgba(99, 102, 241, 0.5);
    --btn-glow-bg: #6366f1;
    --btn-glow-text: #ffffff;
    --neon-border-active: #6366f1;
    --neon-shadow-active: 0 0 25px rgba(99, 102, 241, 0.6);
    --neon-border-inactive: #4b5563;
    --neon-shadow-inactive: 0 0 10px rgba(0, 0, 0, 0.3);
    --sound-btn-bg: rgba(75, 85, 99, 0.8);
    --sound-btn-text: #f9fafb;
    --sound-btn-hover: rgba(99, 102, 241, 0.25);
    --option-bg: rgba(55, 65, 81, 0.7);
    --option-text: #d1d5db;
    --glass-border: rgba(148, 163, 184, 0.15);
    --shadow-color: rgba(0, 0, 0, 0.35);
    --icon-color: #9ca3af;
    --icon-color-active: #6366f1;
    
    /* Spacing Scale */
    --space-xs: 4px;
    --space-sm: 8px;
    --space-md: 12px;
    --space-lg: 16px;
    --space-xl: 20px;
    --space-2xl: 24px;
    --space-3xl: 32px;
    --space-4xl: 48px;
    
    /* Border Radius Scale */
    --radius-sm: 8px;
    --radius-md: 12px;
    --radius-lg: 16px;
    --radius-xl: 20px;
    --radius-2xl: 24px;
    --radius-full: 9999px;
    
    /* Transitions */
    --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
    --transition-base: 250ms cubic-bezier(0.4, 0, 0.2, 1);
    --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
    --transition-bounce: 450ms cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* --- PURPLE THEME (AI Mode) --- */
html[data-theme='purple'] {
    --bg-color-start: #5b21b6;
    --bg-color-end: #1e1b4b;
    --text-dark: #f3e8ff;
    --text-light: #c4b5fd;
    --text-title: #a78bfa;
    --menu-panel-bg: rgba(88, 28, 135, 0.5);
    --input-bg: rgba(107, 33, 168, 0.4);
    --btn-glow-bg: #a78bfa;
    --btn-glow-text: #1e1b4b;
    --neon-border-active: #a78bfa;
    --accent-primary: #a78bfa;
    --accent-primary-light: #c4b5fd;
    --accent-glow: rgba(167, 139, 250, 0.5);
    --player-x-color: #f0abfc;
    --player-x-shadow: 0 0 20px rgba(240, 171, 252, 0.7);
    --player-o-color: #818cf8;
    --player-o-shadow: 0 0 20px rgba(129, 140, 248, 0.7);
    --board-bg: linear-gradient(145deg, rgba(88, 28, 135, 0.4), rgba(30, 27, 75, 0.5));
    --cell-bg: linear-gradient(145deg, rgba(107, 33, 168, 0.5), rgba(88, 28, 135, 0.4));
    --cell-hover: rgba(139, 92, 246, 0.4);
}

/* --- BLUE THEME (Multiplayer Mode) --- */
html[data-theme='friend-blue'] {
    --bg-color-start: #1e3a8a;
    --bg-color-end: #0c1e3e;
    --text-dark: #dbeafe;
    --text-light: #93c5fd;
    --text-title: #38bdf8;
    --menu-panel-bg: rgba(30, 58, 138, 0.5);
    --input-bg: rgba(29, 78, 216, 0.4);
    --btn-glow-bg: #38bdf8;
    --btn-glow-text: #0c1e3e;
    --neon-border-active: #38bdf8;
    --accent-primary: #38bdf8;
    --accent-primary-light: #7dd3fc;
    --accent-glow: rgba(56, 189, 248, 0.5);
    --player-x-color: #38bdf8;
    --player-x-shadow: 0 0 20px rgba(56, 189, 248, 0.7);
    --player-o-color: #fbbf24;
    --player-o-shadow: 0 0 20px rgba(251, 191, 36, 0.7);
    --board-bg: linear-gradient(145deg, rgba(30, 58, 138, 0.4), rgba(12, 30, 62, 0.5));
    --cell-bg: linear-gradient(145deg, rgba(29, 78, 216, 0.5), rgba(30, 58, 138, 0.4));
    --cell-hover: rgba(59, 130, 246, 0.4);
}

/* --- BASE RESETS --- */
*,
*::before,
*::after {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
}

*::-webkit-scrollbar {
    width: 6px;
    height: 6px;
}

*::-webkit-scrollbar-track {
    background: var(--midnight-900);
    border-radius: var(--radius-full);
}

*::-webkit-scrollbar-thumb {
    background: var(--accent-primary);
    border-radius: var(--radius-full);
    transition: background var(--transition-fast);
}

*::-webkit-scrollbar-thumb:hover {
    background: var(--accent-primary-light);
}

html,
body {
    overflow-x: hidden !important;
    width: 100%;
    height: 100%;
}

html {
    font-size: 16px;
    overflow-y: auto;
    scroll-behavior: smooth;
}

/* Mobile-first: 14px base for small screens */
@media (max-width: 374px) {
    html {
        font-size: 14px;
    }
}

/* Tablet: 15px */
@media (min-width: 768px) {
    html {
        font-size: 15px;
    }
}

/* Desktop: 16px */
@media (min-width: 1024px) {
    html {
        font-size: 16px;
    }
}

/* Large Desktop: 17px */
@media (min-width: 1440px) {
    html {
        font-size: 17px;
    }
}

/* --- ENHANCED BODY & BACKGROUND --- */
body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', sans-serif;
    background: 
        radial-gradient(ellipse at 20% 20%, var(--bg-color-start) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, var(--bg-color-end) 0%, transparent 50%),
        linear-gradient(135deg, var(--midnight-900) 0%, var(--midnight-950) 100%);
    background-attachment: fixed;
    background-size: 200% 200%;
    min-height: 100vh;
    color: var(--text-primary);
    line-height: 1.6;
    position: relative;
    transition: background var(--transition-slow), color var(--transition-base);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    animation: gradientBG 15s ease infinite;
}

/* Ambient particles effect */
body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: 
        radial-gradient(circle at 10% 20%, rgba(99, 102, 241, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 90% 80%, rgba(236, 72, 153, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(245, 158, 11, 0.05) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
    animation: ambientPulse 8s ease-in-out infinite;
}

@keyframes gradientBG {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

@keyframes ambientPulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
}

/* --- PREMIUM TYPOGRAPHY --- */
h1, h2, h3, h4, h5, h6 {
    font-family: 'Space Grotesk', 'Inter', sans-serif;
    font-weight: 700;
    line-height: 1.2;
    color: var(--text-title);
    letter-spacing: -0.03em;
    transition: color var(--transition-base);
    text-shadow: 0 2px 20px rgba(99, 102, 241, 0.25);
}

h1 {
    font-size: clamp(1.75rem, 5vw + 1rem, 3.5rem);
    font-weight: 800;
}

h2 {
    font-size: clamp(1.5rem, 4vw + 0.75rem, 2.5rem);
    font-weight: 700;
}

h3 {
    font-size: clamp(1.15rem, 3vw + 0.5rem, 1.75rem);
    font-weight: 600;
}

#arcade-nexus-screen h1 {
    text-shadow: 0 0 30px color-mix(in srgb, var(--text-title) 50%, transparent),
                 0 4px 20px rgba(0, 0, 0, 0.3);
    animation: titleGlow 3s ease-in-out infinite;
}

@keyframes titleGlow {
    0%, 100% { 
        text-shadow: 0 0 30px color-mix(in srgb, var(--text-title) 50%, transparent),
                     0 4px 20px rgba(0, 0, 0, 0.3);
    }
    50% { 
        text-shadow: 0 0 50px color-mix(in srgb, var(--text-title) 70%, transparent),
                     0 6px 30px rgba(0, 0, 0, 0.4);
    }
}

/* --- ULTRA GLASS MORPHISM PANELS --- */
.glass-panel {
    background: var(--menu-panel-bg);
    backdrop-filter: blur(32px) saturate(200%);
    -webkit-backdrop-filter: blur(32px) saturate(200%);
    border: 1px solid var(--border-subtle);
    border-radius: var(--radius-xl);
    box-shadow: var(--shadow-lg),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    transition: all var(--transition-base);
    position: relative;
    overflow: hidden;
}

/* Glass shimmer effect */
.glass-panel::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.08), transparent);
    transition: left var(--transition-slow);
}

.glass-panel:hover::before {
    left: 100%;
}

.glass-panel:hover {
    border-color: var(--border-medium);
    box-shadow: var(--shadow-xl), 
                0 0 0 1px var(--border-glow),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
    transform: translateY(-2px);
}

#main-menu-screen .glass-panel {
    background: var(--menu-panel-bg);
    backdrop-filter: blur(32px) saturate(200%);
    -webkit-backdrop-filter: blur(32px) saturate(200%);
    box-shadow: var(--menu-panel-shadow),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

/* --- PREMIUM BUTTONS --- */
.play-button {
    background: linear-gradient(135deg, var(--btn-glow-bg), var(--accent-primary-light));
    color: var(--btn-glow-text);
    font-weight: 700;
    padding: 16px 40px;
    border-radius: var(--radius-lg);
    border: none;
    cursor: pointer;
    transition: all var(--transition-base);
    box-shadow: var(--btn-glow-shadow),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -2px 0 rgba(0, 0, 0, 0.1);
    font-size: 1rem;
    letter-spacing: 0.03em;
    position: relative;
    overflow: hidden;
    text-transform: uppercase;
    font-weight: 800;
}

/* Button shine effect */
.play-button::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.15), transparent);
    transform: rotate(45deg);
    transition: all var(--transition-slow);
}

.play-button:hover:not(:disabled)::after {
    left: 100%;
}

.play-button:hover:not(:disabled) {
    transform: translateY(-3px) scale(1.03);
    box-shadow: var(--shadow-glow-strong),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
}

.play-button:active:not(:disabled) {
    transform: translateY(-1px) scale(1);
    box-shadow: var(--btn-glow-shadow),
                inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.play-button:disabled {
    background: var(--surface-elevated);
    color: var(--text-muted);
    cursor: not-allowed;
    box-shadow: none;
    opacity: 0.5;
    transform: none;
}

/* Mobile: Smaller padding */
@media (max-width: 640px) {
    .play-button {
        padding: 14px 32px;
        font-size: 0.9rem;
    }
}

.control-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    background: var(--surface-elevated);
    color: var(--text-secondary);
    padding: 14px 24px;
    border-radius: var(--radius-md);
    font-weight: 600;
    border: 1px solid var(--border-subtle);
    cursor: pointer;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-sm),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    position: relative;
    overflow: hidden;
}

.control-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--surface-glass), transparent);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.control-btn:hover::before {
    opacity: 1;
}

.control-btn:hover {
    background: var(--surface-hover);
    border-color: var(--accent-primary);
    color: var(--accent-primary);
    transform: translateY(-2px);
    box-shadow: var(--shadow-md),
                0 0 20px var(--accent-glow);
}

.control-btn:active {
    transform: translateY(0);
}

/* Mobile: Adjust padding */
@media (max-width: 640px) {
    .control-btn {
        padding: 12px 20px;
        font-size: 0.9rem;
    }
}

.bottom-nav-btn {
    background: var(--surface-elevated);
    color: var(--text-secondary);
    padding: 14px;
    border-radius: var(--radius-full);
    border: 1px solid var(--border-subtle);
    transition: all var(--transition-base);
    box-shadow: var(--shadow-sm);
    cursor: pointer;
    position: relative;
    overflow: hidden;
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.bottom-nav-btn::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: var(--radius-full);
    background: radial-gradient(circle, var(--accent-glow), transparent);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.bottom-nav-btn:hover::before {
    opacity: 0.3;
}

.bottom-nav-btn:hover {
    background: var(--surface-hover);
    color: var(--accent-primary);
    border-color: var(--accent-primary);
    box-shadow: var(--shadow-glow);
    transform: scale(1.1) rotate(5deg);
}

.bottom-nav-btn:active {
    transform: scale(0.95);
}

/* Mobile: Touch-friendly sizing */
@media (max-width: 640px) {
    .bottom-nav-btn {
        width: 44px;
        height: 44px;
        padding: 12px;
    }
}

.login-btn,
.guest-login-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-md);
    width: 100%;
    border-radius: var(--radius-lg);
    padding: 16px 28px;
    font-weight: 700;
    font-size: 1rem;
    cursor: pointer;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-md),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
    height: 56px;
    background: linear-gradient(135deg, var(--btn-glow-bg), var(--accent-primary-light));
    color: var(--btn-glow-text);
    border: none;
    position: relative;
    overflow: hidden;
}

.login-btn::after,
.guest-login-btn::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    transform: translateX(-100%);
    transition: transform var(--transition-slow);
}

.login-btn:hover::after,
.guest-login-btn:hover::after {
    transform: translateX(100%);
}

.login-btn:hover,
.guest-login-btn:hover {
    transform: translateY(-3px);
    box-shadow: var(--shadow-glow-strong),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
}

.login-btn:active,
.guest-login-btn:active {
    transform: translateY(-1px);
}

/* Mobile: Adjust height and padding */
@media (max-width: 640px) {
    .login-btn,
    .guest-login-btn {
        height: 52px;
        padding: 14px 24px;
        font-size: 0.95rem;
    }
}

/* --- PREMIUM INPUTS --- */
.name-input,
.input-field {
    width: 100%;
    background: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--border-medium);
    border-radius: var(--radius-md);
    padding: 16px 18px;
    font-weight: 500;
    font-size: 1rem;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-sm),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
    outline: none;
}

.name-input:focus,
.input-field:focus {
    border-color: var(--input-focus-border);
    box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.2),
                var(--shadow-md),
                inset 0 2px 4px rgba(0, 0, 0, 0.05);
    background: color-mix(in srgb, var(--input-bg) 85%, var(--menu-panel-bg));
    transform: translateY(-1px);
}

.name-input::placeholder,
.input-field::placeholder {
    color: var(--text-muted);
    font-weight: 400;
}

/* Mobile: Adjust padding */
@media (max-width: 640px) {
    .name-input,
    .input-field {
        padding: 14px 16px;
        font-size: 0.95rem;
    }
}

/* --- ENHANCED RADIO OPTION GROUPS --- */
.option-group input[type="radio"] {
    display: none;
}

.option-group label {
    display: block;
    background: var(--surface-elevated);
    color: var(--text-secondary);
    padding: 14px 24px;
    border-radius: var(--radius-md);
    text-align: center;
    font-weight: 600;
    font-size: 0.95rem;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-sm),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    position: relative;
    overflow: hidden;
}

.option-group label::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--surface-glass), transparent);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.option-group label:hover::before {
    opacity: 1;
}

.option-group label:hover {
    background: var(--surface-hover);
    border-color: var(--border-medium);
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.option-group input[type="radio"]:checked + label {
    background: linear-gradient(135deg, var(--btn-glow-bg), var(--accent-primary-light));
    color: var(--btn-glow-text);
    border-color: transparent;
    box-shadow: var(--btn-glow-shadow),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
    transform: translateY(-2px) scale(1.02);
}

/* Mobile: Adjust padding */
@media (max-width: 640px) {
    .option-group label {
        padding: 12px 20px;
        font-size: 0.9rem;
    }
}

/* --- ULTRA GAME BOARD --- */
#game-board-container {
    display: grid;
    gap: 12px;
    background: var(--board-bg, var(--surface-primary));
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: var(--radius-xl);
    padding: 16px;
    box-shadow: var(--shadow-xl),
                inset 0 2px 12px rgba(0, 0, 0, 0.25),
                inset 0 -2px 0 rgba(255, 255, 255, 0.05);
    width: min(90vw, 440px);
    height: min(90vw, 440px);
    max-width: 440px;
    max-height: 440px;
    transition: all var(--transition-base);
    position: relative;
    border: 1px solid var(--border-subtle);
}

/* Board glow effect */
#game-board-container::before {
    content: '';
    position: absolute;
    inset: -2px;
    border-radius: var(--radius-xl);
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    opacity: 0.1;
    z-index: -1;
    filter: blur(20px);
    transition: opacity var(--transition-base);
}

#game-board-container:hover::before {
    opacity: 0.2;
}

/* Mobile: Smaller board */
@media (max-width: 640px) {
    #game-board-container {
        gap: 10px;
        padding: 14px;
        width: min(92vw, 380px);
        height: min(92vw, 380px);
        max-width: 380px;
        max-height: 380px;
    }
}

/* Extra small mobile */
@media (max-width: 374px) {
    #game-board-container {
        gap: 8px;
        padding: 12px;
    }
}

.game-cell {
    background: var(--cell-bg, var(--surface-elevated));
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: var(--radius-lg);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all var(--transition-base);
    box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.25),
                var(--shadow-sm),
                inset 0 -1px 0 rgba(255, 255, 255, 0.05);
    aspect-ratio: 1 / 1;
    position: relative;
    overflow: hidden;
    border: 1px solid var(--border-subtle);
}

/* Cell shimmer effect */
.game-cell::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.08), transparent);
    transform: translateX(-100%) rotate(45deg);
    transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
}

.game-cell:hover::before {
    transform: translateX(100%) rotate(45deg);
}

/* Hover glow ring */
.game-cell::after {
    content: '';
    position: absolute;
    inset: -2px;
    border-radius: var(--radius-lg);
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    opacity: 0;
    z-index: -1;
    filter: blur(8px);
    transition: opacity var(--transition-base);
}

.game-cell:hover:not([data-mark])::after {
    opacity: 0.4;
}

.game-cell:hover:not([data-mark]) {
    background: var(--cell-hover, var(--surface-hover));
    transform: scale(1.05);
    box-shadow: var(--shadow-md),
                inset 0 2px 8px rgba(0, 0, 0, 0.2);
    border-color: var(--border-medium);
}

.game-cell:active:not([data-mark]) {
    transform: scale(0.98);
}

.game-cell i[data-lucide] {
    width: 65%;
    height: 65%;
    transition: all var(--transition-base);
    opacity: 0;
    pointer-events: none;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
}

.game-cell.player-x i,
.player-profile.player-x i {
    color: var(--player-x-color);
    text-shadow: var(--player-x-shadow);
    filter: drop-shadow(0 0 12px var(--player-x-color))
            drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    opacity: 1;
}

.game-cell.player-o i,
.player-profile.player-o i {
    color: var(--player-o-color);
    text-shadow: var(--player-o-shadow);
    filter: drop-shadow(0 0 12px var(--player-o-color))
            drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    opacity: 1;
}

/* --- PREMIUM PLAYER PROFILES --- */
.player-profile {
    background: var(--surface-elevated);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    padding: 12px 16px;
    border-radius: var(--radius-full);
    display: flex;
    align-items: center;
    gap: 12px;
    min-width: 140px;
    border: 2px solid transparent;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-sm),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    position: relative;
    overflow: hidden;
}

.player-profile::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: var(--radius-full);
    background: linear-gradient(135deg, var(--surface-glass), transparent);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.player-profile:hover::before {
    opacity: 1;
}

.player-profile.active-turn {
    border-color: var(--accent-primary);
    box-shadow: 0 0 30px var(--accent-glow),
                var(--shadow-md),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
    background: color-mix(in srgb, var(--accent-primary) 15%, var(--surface-elevated));
    animation: activeTurnPulse 2s ease-in-out infinite;
}

@keyframes activeTurnPulse {
    0%, 100% {
        box-shadow: 0 0 30px var(--accent-glow), var(--shadow-md);
    }
    50% {
        box-shadow: 0 0 45px var(--accent-glow-strong), var(--shadow-lg);
    }
}

.player-profile.player-o {
    flex-direction: row-reverse;
    text-align: right;
}

.player-profile .icon {
    width: 44px;
    height: 44px;
    border-radius: var(--radius-full);
    background: var(--surface-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid var(--border-medium);
    flex-shrink: 0;
    box-shadow: var(--shadow-inner),
                0 2px 8px rgba(0, 0, 0, 0.2);
    transition: all var(--transition-base);
}

.player-profile:hover .icon {
    transform: scale(1.1) rotate(5deg);
    box-shadow: var(--shadow-md),
                0 0 20px var(--accent-glow);
}

.player-profile .name {
    font-size: 0.95rem;
    font-weight: 700;
    color: var(--text-primary);
    letter-spacing: 0.02em;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.player-profile .score {
    font-size: 0.85rem;
    color: var(--text-muted);
    font-weight: 600;
}

.player-profile .profile-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.player-profile.player-o .profile-info {
    align-items: flex-end;
}

/* Mobile: Smaller profiles */
@media (max-width: 640px) {
    .player-profile {
        min-width: 130px;
        padding: 10px 14px;
        gap: 10px;
    }
    
    .player-profile .icon {
        width: 40px;
        height: 40px;
    }
    
    .player-profile .name {
        font-size: 0.9rem;
    }
    
    .player-profile .score {
        font-size: 0.8rem;
    }
}

/* Extra small mobile */
@media (max-width: 374px) {
    .player-profile {
        min-width: 110px;
        padding: 8px 12px;
        gap: 8px;
    }
    
    .player-profile .icon {
        width: 36px;
        height: 36px;
    }
    
    .player-profile .name {
        font-size: 0.8rem;
    }
    
    .player-profile .score {
        font-size: 0.7rem;
    }
}

/* --- GAME STATUS DISPLAY --- */
#game-status-display {
    font-family: 'Space Grotesk', 'Inter', sans-serif;
    font-weight: 700;
    color: var(--text-title);
    text-shadow: 0 0 12px color-mix(in srgb, var(--text-title) 50%, transparent),
                 0 2px 8px rgba(0, 0, 0, 0.3);
    text-align: center;
    flex-grow: 1;
    padding: 0 var(--space-md);
    font-size: 1rem;
    min-height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    letter-spacing: 0.02em;
}

/* Mobile: Adjust sizing */
@media (max-width: 640px) {
    #game-status-display {
        font-size: 0.9rem;
        min-height: 44px;
        padding: 0 var(--space-sm);
    }
}

/* --- PREMIUM MODALS --- */
.modal-backdrop {
    position: fixed;
    inset: 0;
    z-index: 70;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(10, 14, 26, 0.85);
    backdrop-filter: blur(24px) saturate(150%);
    -webkit-backdrop-filter: blur(24px) saturate(150%);
    padding: var(--space-xl);
    animation: fadeIn var(--transition-base);
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

.modal-content {
    background: var(--menu-panel-bg);
    backdrop-filter: blur(32px) saturate(200%);
    -webkit-backdrop-filter: blur(32px) saturate(200%);
    border: 1px solid var(--border-medium);
    border-radius: var(--radius-2xl);
    padding: var(--space-4xl);
    width: 100%;
    max-width: 520px;
    box-shadow: var(--shadow-xl),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 80px rgba(0, 0, 0, 0.5);
    position: relative;
    animation: modalSlideUp var(--transition-base);
}

@keyframes modalSlideUp {
    from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
    }
    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

#multiplayer-result-modal .modal-content {
    max-width: 560px;
}

#global-settings-modal .modal-content {
    max-width: 420px;
}

/* Mobile: Adjust modal */
@media (max-width: 640px) {
    .modal-backdrop {
        padding: var(--space-lg);
    }
    
    .modal-content {
        padding: var(--space-2xl);
        border-radius: var(--radius-xl);
    }
}

/* Extra small mobile */
@media (max-width: 374px) {
    .modal-backdrop {
        padding: var(--space-md);
    }
    
    .modal-content {
        padding: var(--space-xl);
    }
}

.player-result-card {
    background: var(--surface-elevated);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border-radius: var(--radius-lg);
    padding: var(--space-2xl);
    border: 2px solid transparent;
    box-shadow: var(--shadow-md),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    animation: scaleIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    opacity: 0;
    transform: scale(0.9);
    color: var(--text-primary);
    position: relative;
    overflow: hidden;
}

.player-result-card::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--surface-glass), transparent);
    opacity: 0.5;
}

.player-result-card.winner {
    border-color: var(--player-x-color);
    box-shadow: 0 0 40px color-mix(in srgb, var(--player-x-color) 60%, transparent),
                var(--shadow-lg);
    transform: scale(1.05);
    animation: scaleIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
               pulseWinnerBorder 2s infinite ease-in-out 0.6s;
}

#game-over-modal .modal-content.winner-x,
#game-over-modal .modal-content.winner-o {
    border: 2px solid var(--accent-primary);
    box-shadow: 0 0 50px var(--accent-glow-strong),
                var(--shadow-xl);
    animation: pulseWinnerBorder 2s infinite ease-in-out;
}

/* --- PREMIUM GAME LIST ITEMS --- */
.game-list-item {
    background: var(--surface-elevated);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 2px solid var(--border-subtle);
    border-radius: var(--radius-xl);
    padding: var(--space-xl);
    display: flex;
    align-items: center;
    gap: var(--space-lg);
    cursor: pointer;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-sm),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    position: relative;
    overflow: hidden;
}

.game-list-item::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--surface-glass), transparent);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.game-list-item:hover:not(.disabled)::before {
    opacity: 1;
}

.game-list-item:hover:not(.disabled) {
    border-color: var(--neon-border-active);
    transform: translateY(-4px) scale(1.02);
    box-shadow: var(--neon-shadow-active),
                var(--shadow-lg),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
}

.game-list-item:active:not(.disabled) {
    transform: translateY(-2px) scale(1.01);
}

.game-list-item.active {
    border-color: var(--neon-border-active);
    background: color-mix(in srgb, var(--accent-primary) 12%, var(--surface-elevated));
    box-shadow: 0 0 30px var(--accent-glow),
                var(--shadow-md);
}

.game-list-item.disabled {
    opacity: 0.4;
    cursor: not-allowed;
    border-color: var(--neon-border-inactive) !important;
    box-shadow: none !important;
    transform: none !important;
}

.game-list-preview {
    width: 76px;
    height: 76px;
    border-radius: var(--radius-lg);
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-primary-light));
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    box-shadow: 0 8px 24px var(--accent-glow),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
    transition: all var(--transition-base);
    position: relative;
    overflow: hidden;
}

.game-list-preview::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.15), transparent);
    transform: translateX(-100%);
    transition: transform var(--transition-slow);
}

.game-list-item:hover:not(.disabled) .game-list-preview::before {
    transform: translateX(100%);
}

.game-list-preview i {
    width: 65%;
    height: 65%;
    color: white;
    filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
}

.game-list-item.active .game-list-preview,
.game-list-item:hover:not(.disabled) .game-list-preview {
    box-shadow: 0 12px 32px var(--accent-glow-strong);
    transform: scale(1.05) rotate(5deg);
}

/* Mobile: Smaller preview */
@media (max-width: 640px) {
    .game-list-item {
        padding: var(--space-lg);
        gap: var(--space-md);
    }
    
    .game-list-preview {
        width: 64px;
        height: 64px;
    }
}

/* Extra small mobile */
@media (max-width: 374px) {
    .game-list-item {
        padding: var(--space-md);
        gap: var(--space-sm);
    }
    
    .game-list-preview {
        width: 56px;
        height: 56px;
    }
}

.game-list-title {
    font-family: 'Space Grotesk', 'Inter', sans-serif;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--text-primary);
    text-transform: uppercase;
    letter-spacing: 0.03em;
    transition: all var(--transition-base);
    text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.game-list-item.active .game-list-title {
    color: var(--neon-border-active);
    text-shadow: 0 0 20px color-mix(in srgb, var(--neon-border-active) 50%, transparent);
}

/* Mobile: Smaller title */
@media (max-width: 640px) {
    .game-list-title {
        font-size: 1.05rem;
    }
}

/* Extra small mobile */
@media (max-width: 374px) {
    .game-list-title {
        font-size: 0.95rem;
    }
}

.game-list-play-btn {
    margin-left: auto;
    background: linear-gradient(135deg, var(--btn-glow-bg), var(--accent-primary-light));
    border: none;
    color: var(--btn-glow-text);
    padding: 12px 26px;
    border-radius: var(--radius-md);
    font-weight: 700;
    font-size: 0.95rem;
    box-shadow: var(--btn-glow-shadow),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
    transition: all var(--transition-base);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    cursor: pointer;
    position: relative;
    overflow: hidden;
}

.game-list-play-btn::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.15), transparent);
    transform: translateX(-100%);
    transition: transform var(--transition-slow);
}

.game-list-item:hover:not(.disabled) .game-list-play-btn::after {
    transform: translateX(100%);
}

.game-list-item:hover:not(.disabled) .game-list-play-btn {
    transform: scale(1.08) translateY(-2px);
    box-shadow: 0 12px 32px var(--accent-glow-strong);
}

.game-list-play-btn:active {
    transform: scale(1.02);
}

/* Mobile: Smaller button */
@media (max-width: 640px) {
    .game-list-play-btn {
        padding: 10px 20px;
        font-size: 0.85rem;
    }
}

/* --- PREMIUM NOTIFICATIONS --- */
#notification-bar {
    position: fixed;
    top: var(--space-xl);
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    z-index: 100;
    padding: 14px 28px;
    border-radius: var(--radius-lg);
    font-weight: 700;
    font-size: 0.95rem;
    box-shadow: var(--shadow-xl),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
    opacity: 0;
    transition: all var(--transition-base);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    max-width: 90vw;
}

#notification-bar.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

#notification-bar.success {
    background: linear-gradient(135deg, #10b981, #34d399);
    color: white;
}

#notification-bar.error {
    background: linear-gradient(135deg, #ef4444, #f87171);
    color: white;
}

#notification-bar.info {
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-primary-light));
    color: white;
}

/* Mobile: Adjust notification */
@media (max-width: 640px) {
    #notification-bar {
        top: var(--space-md);
        padding: 12px 24px;
        font-size: 0.85rem;
    }
}

#message-overlay {
    position: fixed;
    top: var(--space-xl);
    left: 50%;
    transform: translateX(-50%);
    z-index: 99;
    padding: 12px 24px;
    border-radius: var(--radius-md);
    background: rgba(255, 255, 255, 0.98);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    color: #111;
    font-weight: 700;
    box-shadow: var(--shadow-lg);
    display: none;
    animation: messageShow 3s ease-in-out forwards;
    max-width: 90vw;
}

/* --- HEARTS DISPLAY --- */
#hearts-bar {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    padding: 12px 24px;
    background: var(--surface-elevated);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 2px solid color-mix(in srgb, var(--player-o-color) 35%, transparent);
    border-radius: var(--radius-full);
    box-shadow: 0 8px 24px color-mix(in srgb, var(--player-o-color) 25%, transparent),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    justify-content: center;
    margin-top: var(--space-lg);
    transition: all var(--transition-base);
}

#hearts-bar:hover {
    transform: scale(1.05);
    box-shadow: 0 12px 32px color-mix(in srgb, var(--player-o-color) 35%, transparent);
}

#heart-count {
    font-family: 'Space Grotesk', 'Inter', sans-serif;
    font-weight: 800;
    font-size: 1.15rem;
    color: var(--player-o-color);
    text-shadow: 0 0 12px color-mix(in srgb, var(--player-o-color) 60%, transparent);
}

#heart-icon {
    color: var(--player-o-color);
    filter: drop-shadow(0 0 8px var(--player-o-color));
    animation: heartBeat 1.5s ease-in-out infinite;
}

@keyframes heartBeat {
    0%, 100% {
        transform: scale(1);
    }
    10%, 30% {
        transform: scale(1.1);
    }
    20%, 40% {
        transform: scale(1);
    }
}

/* Mobile: Smaller hearts bar */
@media (max-width: 640px) {
    #hearts-bar {
        padding: 10px 20px;
        margin-top: var(--space-md);
    }
    
    #heart-count {
        font-size: 1rem;
    }
}

#reward-panel {
    margin-top: var(--space-md);
    padding: 12px 24px;
    background: var(--surface-elevated);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border-radius: var(--radius-full);
    text-align: center;
    box-shadow: var(--shadow-md),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    transition: all var(--transition-base);
}

#reward-panel:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
}

#collect-reward-btn-top {
    background: linear-gradient(135deg, var(--btn-glow-bg), var(--accent-primary-light));
    color: var(--btn-glow-text);
    box-shadow: var(--btn-glow-shadow),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
    transition: all var(--transition-base);
}

#collect-reward-btn-top:hover:not(:disabled) {
    transform: scale(1.08);
    box-shadow: var(--shadow-glow-strong);
}

#collect-reward-btn-top:disabled {
    background: var(--surface-elevated);
    color: var(--text-muted);
    cursor: not-allowed;
    box-shadow: none;
    opacity: 0.5;
}

/* --- PREMIUM CHAT PANEL --- */
#multiplayer-chat-panel {
    background: var(--menu-panel-bg);
    backdrop-filter: blur(32px) saturate(200%);
    -webkit-backdrop-filter: blur(32px) saturate(200%);
    border: 1px solid var(--border-medium);
    border-radius: var(--radius-xl);
    padding: var(--space-lg);
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 280px;
    max-height: 55vh;
    box-shadow: var(--shadow-lg),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    position: relative;
}

#multiplayer-chat-panel h3 {
    font-size: 1.05rem;
    margin-bottom: var(--space-md);
    color: var(--text-title);
    text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    padding-bottom: var(--space-sm);
    border-bottom: 1px solid var(--border-subtle);
}

#chat-messages {
    display: flex;
    flex-direction: column;
    gap: var(--space-sm);
    flex-grow: 1;
    overflow-y: auto;
    margin-bottom: var(--space-md);
    padding-right: var(--space-xs);
}

/* Custom scrollbar for chat */
#chat-messages::-webkit-scrollbar {
    width: 4px;
}

#chat-messages::-webkit-scrollbar-thumb {
    background: var(--accent-primary);
    border-radius: var(--radius-full);
}

.chat-message {
    padding: 12px 16px;
    border-radius: var(--radius-md);
    max-width: 85%;
    font-size: 0.85rem;
    line-height: 1.5;
    box-shadow: var(--shadow-sm);
    position: relative;
    animation: messageSlideIn var(--transition-base);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

@keyframes messageSlideIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.my-message {
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-primary-light));
    color: white;
    align-self: flex-end;
    box-shadow: 0 4px 16px var(--accent-glow),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.opponent-message {
    background: var(--surface-elevated);
    color: var(--text-primary);
    align-self: flex-start;
    border: 1px solid var(--border-medium);
    box-shadow: var(--shadow-sm);
}

.chat-sender {
    font-size: 0.7rem;
    font-weight: 700;
    margin-bottom: 4px;
    color: rgba(255, 255, 255, 0.85);
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.opponent-message .chat-sender {
    color: var(--text-muted);
}

.chat-time {
    display: block;
    font-size: 0.65rem;
    text-align: right;
    margin-top: 6px;
    color: rgba(255, 255, 255, 0.65);
    font-weight: 600;
}

.opponent-message .chat-time {
    color: var(--text-muted);
}

#chat-input-container {
    margin-top: var(--space-md);
    display: flex;
    gap: var(--space-sm);
    padding-top: var(--space-md);
    border-top: 1px solid var(--border-subtle);
}

#chat-input-field {
    flex-grow: 1;
    background: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--border-medium);
    border-radius: var(--radius-md);
    padding: 12px 16px;
    font-weight: 500;
    font-size: 0.9rem;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-xs),
                inset 0 2px 4px rgba(0, 0, 0, 0.05);
}

#chat-input-field:focus {
    outline: none;
    border-color: var(--input-focus-border);
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15),
                var(--shadow-sm);
    transform: translateY(-1px);
}

#chat-input-field::placeholder {
    color: var(--text-muted);
}

#chat-send-btn {
    background: linear-gradient(135deg, var(--btn-glow-bg), var(--accent-primary-light));
    color: var(--btn-glow-text);
    border-radius: var(--radius-md);
    padding: 12px 18px;
    font-weight: 700;
    cursor: pointer;
    transition: all var(--transition-base);
    box-shadow: var(--btn-glow-shadow),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
}

#chat-send-btn:hover:not(:disabled) {
    transform: scale(1.08) translateY(-2px);
    box-shadow: var(--shadow-glow-strong);
}

#chat-send-btn:active:not(:disabled) {
    transform: scale(1.02);
}

#chat-send-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
}

/* Mobile & Tablet: Slide-in chat panel */
@media (max-width: 1023px) {
    #multiplayer-chat-panel {
        position: fixed;
        bottom: 64px;
        left: 0;
        width: min(60vw, 280px);
        height: 50vh;
        max-height: 50vh;
        z-index: 80;
        border-radius: 0 var(--radius-xl) var(--radius-xl) 0;
        transform: translateX(-100%);
        transition: transform var(--transition-base);
        box-shadow: 8px 0 32px rgba(0, 0, 0, 0.6);
        overflow-y: hidden;
        padding: var(--space-md);
    }

    #multiplayer-chat-panel.open {
        transform: translateX(0);
    }

    #chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        padding-right: var(--space-xs);
        margin-bottom: var(--space-sm);
    }

    #chat-input-container {
        margin-top: var(--space-sm);
        padding-top: var(--space-sm);
        gap: 6px;
        flex-shrink: 0;
    }

    #chat-input-field {
        font-size: 0.8rem;
        padding: 10px 12px;
    }

    #chat-send-btn {
        padding: 10px;
        width: 44px;
        height: 44px;
        flex-shrink: 0;
    }

    #multiplayer-chat-panel h3 {
        font-size: 0.9rem;
        margin-bottom: var(--space-sm);
        padding-bottom: var(--space-xs);
    }
}

/* Extra small mobile chat */
@media (max-width: 374px) {
    #multiplayer-chat-panel {
        width: min(70vw, 240px);
        padding: var(--space-sm);
    }
    
    #chat-send-btn {
        width: 40px;
        height: 40px;
        padding: 8px;
    }
}

/* Desktop: Normal layout */
@media (min-width: 1024px) {
    #multiplayer-chat-panel {
        position: relative;
        transform: none;
        border-radius: var(--radius-xl);
    }
}

/* --- GAME SCREEN RESPONSIVE LAYOUT --- */
.game-screen {
    position: fixed;
    inset: 0;
    z-index: 60;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    background: var(--bg-color-end);
    padding: var(--space-md);
    transition: background var(--transition-slow);
    overflow-y: auto;
}

#game-content-area {
    display: grid;
    width: 100%;
    max-width: 1280px;
    grid-template-areas:
        "header"
        "board"
        "chat-panel-area";
    grid-template-columns: 1fr;
    gap: var(--space-md);
    flex-grow: 1;
}

.game-header-new {
    grid-area: header;
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: var(--space-md);
    padding: var(--space-sm) 0;
}

#game-board-wrapper {
    grid-area: board;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    flex-grow: 1;
}

#chat-panel-area {
    grid-area: chat-panel-area;
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
}

/* Tablet: 768px - 1023px */
@media (min-width: 768px) and (max-width: 1023px) {
    .game-screen {
        padding: var(--space-lg);
    }
    
    #game-content-area {
        gap: var(--space-lg);
    }
    
    .game-header-new {
        padding: var(--space-md) 0;
    }
}

/* Desktop: 1024px+ */
@media (min-width: 1024px) {
    .game-screen {
        padding: var(--space-xl);
    }
    
    #game-content-area {
        grid-template-areas:
            "header header"
            "board chat-panel-area";
        grid-template-columns: minmax(480px, 650px) minmax(320px, 1fr);
        align-items: start;
        padding-top: var(--space-2xl);
        gap: var(--space-3xl);
    }

    #game-board-wrapper {
        flex-grow: 0;
        align-self: center;
        margin-top: var(--space-lg);
    }

    #chat-panel-area {
        max-height: 82vh;
        position: sticky;
        top: var(--space-2xl);
    }
}

/* Large Desktop: 1440px+ */
@media (min-width: 1440px) {
    #game-content-area {
        grid-template-columns: minmax(520px, 700px) minmax(360px, 1fr);
        gap: var(--space-4xl);
    }
}

/* Mobile: Adjust layout */
@media (max-width: 1023px) {
    .game-screen {
        justify-content: flex-start;
    }

    #game-board-wrapper {
        margin-top: var(--space-sm);
        padding-bottom: 0;
    }
}

/* --- FIXED CONTROLS BAR --- */
#fixed-controls-bar {
    width: 100%;
    max-width: 540px;
    display: flex;
    justify-content: space-between;
    padding: 14px 20px;
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    z-index: 75;
    background: var(--surface-elevated);
    backdrop-filter: blur(32px) saturate(180%);
    -webkit-backdrop-filter: blur(32px) saturate(180%);
    border-top: 1px solid var(--border-subtle);
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
    transition: all var(--transition-base);
    box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

/* Mobile: Smaller controls */
@media (max-width: 640px) {
    #fixed-controls-bar {
        max-width: 100%;
        padding: 12px 16px;
    }
}

/* Desktop: Normal layout */
@media (min-width: 1024px) {
    #fixed-controls-bar {
        position: relative;
        bottom: auto;
        left: auto;
        transform: none;
        max-width: none;
        background: transparent;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        border-top: none;
        border-radius: 0;
        padding: 0;
        justify-content: flex-end;
        gap: var(--space-md);
        box-shadow: none;
    }

    #game-screen #chat-toggle-btn {
        display: none !important;
    }
}

/* --- POWER-UP BUTTONS --- */
#blocker-powerup-btn-desktop,
#blocker-powerup-btn-mobile {
    color: var(--player-o-color);
    background: var(--surface-elevated);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    padding: 14px 24px;
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-sm),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    transition: all var(--transition-base);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    border: 1px solid var(--border-subtle);
    cursor: pointer;
    font-weight: 600;
}

#blocker-powerup-btn-desktop:hover:not(:disabled),
#blocker-powerup-btn-mobile:hover:not(:disabled) {
    transform: translateY(-2px) scale(1.05);
    box-shadow: var(--shadow-md),
                0 0 20px color-mix(in srgb, var(--player-o-color) 30%, transparent);
    border-color: var(--player-o-color);
}

#blocker-powerup-btn-desktop.active,
#blocker-powerup-btn-mobile.active {
    background: var(--player-o-color);
    color: var(--text-inverse);
    box-shadow: 0 0 30px color-mix(in srgb, var(--player-o-color) 60%, transparent),
                var(--shadow-md);
    border-color: var(--player-o-color);
    animation: activePowerup 1.5s ease-in-out infinite;
}

@keyframes activePowerup {
    0%, 100% {
        box-shadow: 0 0 30px color-mix(in srgb, var(--player-o-color) 60%, transparent);
    }
    50% {
        box-shadow: 0 0 45px color-mix(in srgb, var(--player-o-color) 80%, transparent);
    }
}

#blocker-powerup-btn-desktop:disabled,
#blocker-powerup-btn-mobile:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
}

@media (max-width: 640px) {
    #blocker-powerup-btn-desktop,
    #blocker-powerup-btn-mobile {
        padding: 12px 20px;
        font-size: 0.85rem;
    }
}

#ai-tip-btn-desktop,
#ai-tip-btn,
#ai-tip-btn-mobile {
    background: var(--surface-elevated);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    color: var(--player-x-color);
    padding: 14px 24px;
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-sm),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
    transition: all var(--transition-base);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    border: 1px solid var(--border-subtle);
    cursor: pointer;
    position: relative;
    font-weight: 600;
}

#ai-tip-btn-desktop:hover:not(:disabled),
#ai-tip-btn:hover:not(:disabled),
#ai-tip-btn-mobile:hover:not(:disabled) {
    background: var(--surface-hover);
    border-color: var(--player-x-color);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 0 24px color-mix(in srgb, var(--player-x-color) 40%, transparent),
                var(--shadow-md);
}

#ai-tip-btn-desktop:disabled,
#ai-tip-btn:disabled,
#ai-tip-btn-mobile:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
}

@media (max-width: 640px) {
    #ai-tip-btn-desktop,
    #ai-tip-btn,
    #ai-tip-btn-mobile {
        padding: 12px 20px;
        font-size: 0.85rem;
    }
}

#ai-tip-count-desktop,
#ai-tip-count,
#ai-tip-count-mobile {
    background: var(--player-o-color);
    color: white;
    padding: 3px 10px;
    border-radius: var(--radius-full);
    font-size: 0.75rem;
    font-weight: 800;
    box-shadow: 0 2px 8px color-mix(in srgb, var(--player-o-color) 50%, transparent);
}

.sound-toggle-btn {
    background: var(--surface-elevated);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    color: var(--text-primary);
    border: 1px solid var(--border-medium);
    padding: 14px 28px;
    border-radius: var(--radius-md);
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-base);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    width: 100%;
    justify-content: center;
    box-shadow: var(--shadow-sm),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.sound-toggle-btn:hover {
    background: var(--surface-hover);
    border-color: var(--accent-primary);
    transform: translateY(-2px);
    box-shadow: var(--shadow-md),
                0 0 20px var(--accent-glow);
}

.sound-toggle-btn.muted {
    background: color-mix(in srgb, var(--surface-elevated) 75%, var(--player-o-color));
    color: color-mix(in srgb, var(--text-primary) 75%, var(--player-o-color));
    border-color: var(--player-o-color);
    box-shadow: 0 4px 16px color-mix(in srgb, var(--player-o-color) 25%, transparent);
}

@media (max-width: 640px) {
    .sound-toggle-btn {
        padding: 12px 24px;
        font-size: 0.9rem;
    }
}

.icon-option,
.color-option {
    width: 52px;
    height: 52px;
    border-radius: var(--radius-md);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    border: 2px solid transparent;
    background: var(--surface-elevated);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    transition: all var(--transition-base);
    position: relative;
    box-shadow: var(--shadow-sm),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.icon-option:hover,
.color-option:hover {
    border-color: var(--border-medium);
    transform: scale(1.1) rotate(5deg);
    box-shadow: var(--shadow-md),
                0 0 16px var(--accent-glow);
}

.icon-option i,
.color-option i {
    width: 60%;
    height: 60%;
    color: var(--text-primary);
    filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.4));
    transition: all var(--transition-base);
}

.icon-option.selected,
.color-option.selected {
    border-color: var(--accent-primary);
    box-shadow: 0 0 24px var(--accent-glow-strong),
                var(--shadow-md);
    background: color-mix(in srgb, var(--accent-primary) 20%, var(--surface-elevated));
    transform: scale(1.1);
}

.icon-option.selected i,
.color-option.selected i {
    filter: drop-shadow(0 0 10px var(--accent-primary));
}

@media (max-width: 640px) {
    .icon-option,
    .color-option {
        width: 48px;
        height: 48px;
    }
}

.icon-lock {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.75);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    border-radius: var(--radius-md);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 5;
    cursor: not-allowed;
}

.icon-cost {
    position: absolute;
    bottom: -10px;
    right: -10px;
    background: var(--player-o-color);
    color: white;
    padding: 4px 10px;
    border-radius: var(--radius-full);
    font-size: 0.65rem;
    font-weight: 800;
    z-index: 10;
    box-shadow: 0 4px 12px color-mix(in srgb, var(--player-o-color) 70%, transparent);
}

#win-streak-display {
    margin-top: var(--space-md);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    font-family: 'Space Grotesk', 'Inter', sans-serif;
    font-weight: 700;
    font-size: 1rem;
    color: var(--text-title);
    text-shadow: 0 0 12px color-mix(in srgb, var(--text-title) 50%, transparent),
                 0 2px 8px rgba(0, 0, 0, 0.3);
}

#win-streak-icon {
    color: var(--text-title);
    filter: drop-shadow(0 0 8px var(--text-title));
    animation: streakGlow 2s ease-in-out infinite;
}

@keyframes streakGlow {
    0%, 100% {
        filter: drop-shadow(0 0 8px var(--text-title));
    }
    50% {
        filter: drop-shadow(0 0 16px var(--text-title));
    }
}

#rematch-status {
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--text-title);
    text-shadow: 0 0 10px color-mix(in srgb, var(--text-title) 40%, transparent);
    min-height: 28px;
    transition: all var(--transition-base);
}

#rematch-btn.requested {
    background: var(--surface-elevated);
    color: var(--text-muted);
    box-shadow: none;
    cursor: default;
    opacity: 0.7;
    transform: none;
}

.stat-value.positive {
    color: var(--accent-primary);
    font-weight: 700;
    text-shadow: 0 0 8px color-mix(in srgb, var(--accent-primary) 40%, transparent);
}

.stat-value.negative {
    color: var(--player-o-color);
    font-weight: 700;
    text-shadow: 0 0 8px color-mix(in srgb, var(--player-o-color) 40%, transparent);
}

@keyframes fadeInScaleUp {
    from {
        opacity: 0;
        transform: scale(0.9) translateY(10px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

@keyframes fadeOutScaleDown {
    from {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
    to {
        opacity: 0;
        transform: scale(0.9) translateY(10px);
    }
}

@keyframes bounceIn {
    0% {
        transform: scale(0) rotate(0deg);
        opacity: 0;
    }
    50% {
        transform: scale(1.15) rotate(5deg);
        opacity: 1;
    }
    70% {
        transform: scale(0.95) rotate(-3deg);
    }
    85% {
        transform: scale(1.05) rotate(2deg);
    }
    100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
    }
}

@keyframes pulseWin {
    0%, 100% {
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-primary-light));
        box-shadow: 0 0 30px var(--accent-glow);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 50px var(--accent-glow-strong);
        transform: scale(1.08);
    }
}

@keyframes pulseWinnerBorder {
    0%, 100% {
        border-color: var(--accent-primary);
        box-shadow: 0 0 30px var(--accent-glow);
    }
    50% {
        border-color: var(--accent-primary-light);
        box-shadow: 0 0 50px var(--accent-glow-strong);
    }
}

@keyframes shake {
    0%, 100% {
        transform: translateX(0) rotate(0deg);
    }
    20% {
        transform: translateX(-8px) rotate(-2deg);
    }
    40% {
        transform: translateX(8px) rotate(2deg);
    }
    60% {
        transform: translateX(-8px) rotate(-1deg);
    }
    80% {
        transform: translateX(8px) rotate(1deg);
    }
}

@keyframes pulseTip {
    0% {
        background: var(--cell-hover);
        box-shadow: 0 0 25px var(--player-x-color),
                    inset 0 0 15px var(--player-x-color);
        border-color: var(--player-x-color);
    }
    50% {
        background: var(--cell-bg);
        box-shadow: 0 0 15px var(--player-x-color),
                    inset 0 0 8px var(--player-x-color);
        border-color: var(--border-subtle);
    }
    100% {
        background: var(--cell-hover);
        box-shadow: 0 0 25px var(--player-x-color),
                    inset 0 0 15px var(--player-x-color);
        border-color: var(--player-x-color);
    }
}

@keyframes subtlePulse {
    0%, 100% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.03);
        opacity: 0.85;
    }
}

@keyframes messageShow {
    0% {
        opacity: 0;
        transform: translateY(-15px) scale(0.9);
    }
    10% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    90% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-15px) scale(0.9);
    }
}

@keyframes scaleIn {
    to {
        opacity: 1;
        transform: scale(1);
    }
}

/* Animation Classes */
.animate-fade-in-scale-up {
    animation: fadeInScaleUp 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.animate-fade-out-scale-down {
    animation: fadeOutScaleDown 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

.cell-bounce-in {
    animation: bounceIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.winning-cell {
    animation: pulseWin 1.2s ease-in-out infinite;
}

.winning-cell i,
.winning-cell svg {
    color: white !important;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.9) !important;
    filter: drop-shadow(0 0 16px rgba(255, 255, 255, 0.9)) !important;
    opacity: 1 !important;
}

.shake {
    animation: shake 0.4s cubic-bezier(0.36, 0.07, 0.19, 0.97);
}

.ai-tip-highlight {
    animation: pulseTip 0.4s ease-in-out 1 forwards;
}

.ai-thinking-status {
    color: var(--text-title);
    text-shadow: 0 0 12px color-mix(in srgb, var(--text-title) 50%, transparent);
    animation: subtlePulse 1.8s infinite ease-in-out;
}

.hidden {
    display: none !important;
}

.opacity-50 {
    opacity: 0.5;
}

.blur {
    filter: blur(4px);
    pointer-events: none;
}


@media (min-width: 480px) and (max-width: 767px) {
    .glass-panel {
        padding: 24px;
    }
    
    #game-board-container {
        width: min(85vw, 400px);
        height: min(85vw, 400px);
        max-width: 400px;
        max-height: 400px;
    }
}

@media (min-width: 768px) and (max-width: 1023px) {
    .glass-panel {
        padding: 28px;
        border-radius: 22px;
    }
    
    #game-board-container {
        width: min(70vw, 480px);
        height: min(70vw, 480px);
        max-width: 480px;
        max-height: 480px;
        gap: 14px;
        padding: 18px;
    }
    
    .player-profile {
        min-width: 150px;
        padding: 14px 18px;
    }
}

@media (min-width: 1024px) and (max-width: 1279px) {
    #game-board-container {
        width: min(50vw, 480px);
        height: min(50vw, 480px);
    }
}

@media (min-width: 1920px) {
    html {
        font-size: 18px;
    }
    
    #game-content-area {
        max-width: 1600px;
        grid-template-columns: minmax(580px, 800px) minmax(420px, 1fr);
    }
    
    #game-board-container {
        width: min(40vw, 560px);
        height: min(40vw, 560px);
        max-width: 560px;
        max-height: 560px;
    }
}

@media print {
    .glass-panel,
    .modal-backdrop,
    #notification-bar,
    #fixed-controls-bar {
        display: none;
    }
}

@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}


@media (prefers-contrast: high) {
    :root {
        --border-subtle: rgba(255, 255, 255, 0.4);
        --border-medium: rgba(255, 255, 255, 0.6);
        --text-muted: #d1d5db;
    }
    
    .glass-panel,
    .modal-content {
        border-width: 2px;
    }
}


@media (hover: none) and (pointer: coarse) {
    .play-button,
    .control-btn,
    .game-cell,
    .bottom-nav-btn {
        min-height: 44px;
        min-width: 44px;
    }
    
    .game-cell:active:not([data-mark]) {
        background: var(--cell-hover);
        transform: scale(0.95);
    }
}

    </style>
    
</head>
<body class="overflow-hidden">
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 flex flex-col items-center justify-center z-[100]">
         <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4" style="border-color: var(--text-title); border-top-color: transparent;"></div>
         <p class="mt-4 text-lg font-semibold tracking-wider" style="color: var(--text-title);">Loading Arcade Nexus...</p>
    </div>

    <!-- Notification Bar -->
    <div id="notification-bar" role="alert" class="fixed top-5 left-1/2 -translate-x-1/2 z-[110] px-6 py-3 rounded-lg font-semibold shadow-xl text-white transition-all duration-300 opacity-0 -translate-y-10 max-w-[90vw] text-center" style="backdrop-filter: blur(10px);"></div>
    
    <!-- Message Overlay -->
    <div id="message-overlay" class="fixed top-5 left-1/2 -translate-x-1/2 z-[99] px-6 py-3 rounded-lg font-semibold shadow-xl text-gray-900 bg-white bg-opacity-95 transition-all duration-300 opacity-0 -translate-y-10 max-w-[90vw] text-center" style="backdrop-filter: blur(10px);"></div>

    <!-- 1. Login Screen -->
    <div id="login-screen" class="min-h-screen p-6 flex flex-col items-center justify-center hidden">
        <div class="w-full max-w-sm space-y-8">
            <div class="text-center">
                <h1 class="text-4xl sm:text-5xl font-bold uppercase tracking-widest" style="font-family: 'Oxanium', monospace;">
                    FUTURISTIC
                </h1>
                <h2 class="text-3xl sm:text-4xl font-bold uppercase tracking-widest" style="font-family: 'Oxanium', monospace;">
                    TIC-TAC-TOE
                </h2>
            </div>
            
            <div class="glass-panel p-6 sm:p-8 space-y-6">
                 <button id="play-btn" class="play-button w-full py-3 rounded-lg text-lg font-bold shadow-lg flex items-center justify-center gap-2">
                     <i data-lucide="play" class="w-5 h-5"></i>
                     <span>PLAY</span>
                 </button>
            </div>
            
             <div class="glass-panel p-6 sm:p-8 space-y-4">
                <h3 class="text-lg font-semibold text-gray-400 mb-2">Load Data by ID</h3>
                <input type="text" id="old-game-id-input" class="name-input w-full rounded-lg py-3 px-4" placeholder="Paste your saved Game ID">
                <button id="load-data-btn" class="play-button w-full py-3 rounded-lg font-bold text-lg shadow-lg">
                    LOAD DATA
                </button>
            </div>
        </div>
    </div>

    <!-- 2. Arcade Nexus (Main Menu) -->
    <div id="arcade-nexus-screen" class="min-h-screen p-4 sm:p-6 flex flex-col items-center relative hidden">
        
        <!-- NEW Top Bar (From Screenshot 1) -->
        <div class="w-full max-w-lg flex justify-between items-center gap-2 p-3 glass-button rounded-xl mb-6">
            <!-- Profile Button -->
            <button id="profile-btn" class="glass-button rounded-lg p-2 aspect-square h-12 w-12 flex items-center justify-center text-white">
                <i id="top-bar-profile-icon" data-lucide="user-circle-2" class="w-7 h-7"></i>
            </button>
            
            <!-- Stats -->
            <div class="flex-1 flex justify-center items-center gap-3">
                <!-- Streak -->
                <div class="glass-button flex items-center gap-2 px-3 sm:px-4 py-2 rounded-lg text-sm sm:text-base">
                    <i data-lucide="flame" class="w-5 h-5 text-orange-400"></i>
                    <span id="win-streak-count" class="font-bold text-white">0</span>
                    <span class="hidden sm:inline text-gray-400">Streak</span>
                </div>
                <!-- Hearts -->
                <div class="glass-button flex items-center gap-2 px-3 sm:px-4 py-2 rounded-lg text-sm sm:text-base">
                    <i data-lucide="heart" class="w-5 h-5 text-red-400 fill-red-400"></i>
                    <span id="heart-count" class="font-bold text-white">20</span>
                </div>
            </div>
            
            <!-- Settings Button -->
            <button id="global-settings-btn" class="glass-button rounded-lg p-2 aspect-square h-12 w-12 flex items-center justify-center text-gray-400 hover:text-white">
                <i data-lucide="settings" class="w-7 h-7"></i>
            </button>
        </div>

        <!-- REPLACED Header -->
        <h1 class="w-full text-center text-3xl sm:text-4xl font-bold uppercase tracking-widest mt-4 mb-6" style="font-family: 'Oxanium', monospace;">
            ARCADE NEXUS
        </h1>

        <!-- Reward Button -->
        <button id="collect-reward-btn-top" class="play-button py-2 px-5 text-sm font-bold rounded-full shadow-lg mb-6 flex items-center gap-2" disabled>
             <i data-lucide="gift" class="w-5 h-5"></i>
             <span>Collect Reward</span>
        </button>

        <!-- Game Mode List -->
        <div class="w-full max-w-lg space-y-4">
            <div id="select-ttt" class="game-list-item p-4 rounded-xl flex items-center gap-4 cursor-pointer">
                <div class="w-16 h-16 rounded-lg bg-gradient-to-br from-blue-500 to-blue-700 flex items-center justify-center shadow-lg">
                    <i data-lucide="layout-grid" class="w-8 h-8 text-white"></i>
                </div>
                <div class="flex-grow">
                    <h3 class="text-lg font-bold uppercase text-white">PLAYER VS PLAYER</h3>
                </div>
                <button class="play-button rounded-lg px-5 py-2 text-sm font-bold flex items-center gap-2">
                    <i data-lucide="play" class="w-4 h-4"></i>
                    <span>PLAY</span>
                </button>
            </div>
            
             <div id="select-ai" class="game-list-item p-4 rounded-xl flex items-center gap-4 cursor-pointer">
                <div class="w-16 h-16 rounded-lg bg-gradient-to-br from-purple-500 to-purple-700 flex items-center justify-center shadow-lg">
                    <i data-lucide="cpu" class="w-8 h-8 text-white"></i>
                </div>
                <div class="flex-grow">
                    <h3 class="text-lg font-bold uppercase text-white">PLAY WITH AI</h3>
                </div>
                <button id="ai-btn" class="play-button rounded-lg px-5 py-2 text-sm font-bold flex items-center gap-2">
                    <i data-lucide="play" class="w-4 h-4"></i>
                    <span>PLAY</span>
                </button>
            </div>
            
            <div id="select-ftf" class="game-list-item p-4 rounded-xl flex items-center gap-4 cursor-pointer">
                <div class="w-16 h-16 rounded-lg bg-gradient-to-br from-pink-500 to-pink-700 flex items-center justify-center shadow-lg">
                    <i data-lucide="users" class="w-8 h-8 text-white"></i>
                </div>
                <div class="flex-grow">
                    <h3 class="text-lg font-bold uppercase text-white">PLAY WITH FRIENDS</h3>
                </div>
                <button id="ftf-btn" class="play-button rounded-lg px-5 py-2 text-sm font-bold flex items-center gap-2">
                    <i data-lucide="arrow-right" class="w-4 h-4"></i>
                    <span>SELECT</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 3. New Game Screen -->
     <div id="main-menu-screen" class="min-h-screen max-h-screen overflow-y-auto p-4 sm:p-6 flex flex-col items-center justify-center hidden relative">
         <button id="main-menu-close-btn" class="absolute top-4 left-4 text-gray-400 hover:text-white transition-colors z-10 p-2">
            <i data-lucide="arrow-left" class="w-8 h-8"></i>
        </button>
        <div class="glass-panel p-6 sm:p-8 w-full max-w-md max-h-[95vh] overflow-y-auto">
            <h2 class="text-3xl font-bold text-center mb-6 mt-8" style="font-family: 'Oxanium', monospace;">
                NEW GAME
            </h2>
            <div class="space-y-6">
                <!-- Board Size -->
                <div>
                    <h3 class="text-lg font-semibold text-gray-400 mb-3">Board Size</h3>
                    <div class="option-group grid grid-cols-3 gap-3">
                        <div><input type="radio" id="size-3x3" name="board-size" value="3" checked><label for="size-3x3" class="py-3 px-2 rounded-lg text-sm sm:text-base">3 x 3</label></div>
                        <div><input type="radio" id="size-4x4" name="board-size" value="4"><label for="size-4x4" class="py-3 px-2 rounded-lg text-sm sm:text-base">4 x 4</label></div>
                        <div><input type="radio" id="size-5x5" name="board-size" value="5"><label for="size-5x5" class="py-3 px-2 rounded-lg text-sm sm:text-base">5 x 5</label></div>
                    </div>
                </div>
                <!-- Game Mode -->
                <div>
                    <h3 class="text-lg font-semibold text-gray-400 mb-3">Game Mode</h3>
                    <div class="option-group grid grid-cols-2 gap-3">
                        <div><input type="radio" id="mode-pvp" name="game-mode" value="pvp" checked><label for="mode-pvp" class="py-3 px-4 rounded-lg">Player vs Player</label></div>
                        <div><input type="radio" id="mode-pva" name="game-mode" value="pva"><label for="mode-pva" class="py-3 px-4 rounded-lg">Player vs AI (-1 <i data-lucide="heart" class="w-4 h-4 inline fill-red-400 text-red-400"></i>)</label></div>
                    </div>
                </div>
                <!-- AI Difficulty -->
                <div id="ai-difficulty-section" class="hidden">
                    <h3 class="text-lg font-semibold text-gray-400 mb-3">AI Difficulty</h3>
                    <div class="option-group grid grid-cols-2 gap-3">
                        <div><input type="radio" id="ai-easy" name="ai-difficulty" value="easy"><label for="ai-easy" class="py-3 px-4 rounded-lg">Easy</label></div>
                        <div><input type="radio" id="ai-medium" name="ai-difficulty" value="medium" checked><label for="ai-medium" class="py-3 px-4 rounded-lg">Medium</label></div>
                        <div><input type="radio" id="ai-hard" name="ai-difficulty" value="hard"><label for="ai-hard" class="py-3 px-4 rounded-lg">Hard</label></div>
                        <div><input type="radio" id="ai-grandmaster" name="ai-difficulty" value="grandmaster"><label for="ai-grandmaster" class="py-3 px-4 rounded-lg">Grandmaster</label></div>
                    </div>
                </div>
                <!-- Game Variant -->
                <div>
                    <h3 class="text-lg font-semibold text-gray-400 mb-3">Game Variant</h3>
                    <div class="option-group grid grid-cols-2 gap-3">
                        <div><input type="radio" id="variant-classic" name="game-variant" value="classic" checked><label for="variant-classic" class="py-3 px-4 rounded-lg">Classic</label></div>
                        <div><input type="radio" id="variant-blocker" name="game-variant" value="blocker"><label for="variant-blocker" class="py-3 px-4 rounded-lg">Blocker</label></div>
                    </div>
                </div>
                <!-- Icon Customization (REMOVED) -->
                <button id="start-game-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg mt-5">
                    START GAME
                </button>
            </div>
        </div>
    </div>

    <!-- 4. Game Screen -->
    <div id="game-screen" class="game-screen p-3 sm:p-4 flex flex-col items-center justify-start hidden">
        <!-- Game Header -->
        <div class="w-full max-w-5xl mx-auto flex justify-between items-center gap-2 sm:gap-4 p-2 mb-4">
            <div id="player-x-profile" class="player-profile flex-1 p-2 sm:p-3 rounded-full flex items-center gap-2 sm:gap-3 min-w-0">
                <div class="icon w-10 h-10 sm:w-12 sm:h-12 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0 border-2 border-gray-600" style="color: var(--player-x-color); text-shadow: var(--player-x-shadow);">
                    <i data-lucide="x" class="w-6 h-6 sm:w-7 sm:h-7"></i>
                </div>
                <div class="profile-info flex-col min-w-0">
                    <h3 id="player-x-name" class="name text-sm sm:text-base font-bold text-white truncate">DANIYAL</h3>
                    <p id="player-x-score" class="score text-xs sm:text-sm text-gray-400">0</p>
                </div>
            </div>
            
            <!-- BUG FIX: Added h-12 and flex items-center to prevent layout shift -->
            <div id="game-status-display" class="flex-1 text-center font-bold text-sm sm:text-base h-12 flex items-center justify-center px-2" style="color: var(--text-title);">
                Your Turn
            </div>
            
            <div id="player-o-profile" class="player-profile flex-1 p-2 sm:p-3 rounded-full flex items-center justify-end gap-2 sm:gap-3 min-w-0">
                <div class="profile-info flex-col items-end min-w-0">
                    <h3 id="player-o-name" class="name text-sm sm:text-base font-bold text-white truncate">AI</h3>
                    <p id="player-o-score" class="score text-xs sm:text-sm text-gray-400">0</p>
                </div>
                <div class="icon w-10 h-10 sm:w-12 sm:h-12 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0 border-2 border-gray-600" style="color: var(--player-o-color); text-shadow: var(--player-o-shadow);">
                    <i data-lucide="sparkles" class="w-6 h-6 sm:w-7 sm:h-7"></i>
                </div>
            </div>
        </div>

        <!-- Game Content Area -->
        <div id="game-content-area" class="w-full max-w-5xl mx-auto flex-1 flex flex-col lg:flex-row items-start justify-center gap-4 sm:gap-8">
            <!-- Board Wrapper -->
            <div id="game-board-wrapper" class="w-full flex-1 flex items-center justify-center">
                <div id="game-board-container" class="game-board grid gap-2 sm:gap-3 p-3 sm:p-4 rounded-xl sm:rounded-2xl w-full max-w-md aspect-square">
                    <!-- Cells dynamically generated -->
                </div>
            </div>

            <!-- Chat & Controls Area (Desktop) -->
            <div id="chat-panel-area" class="w-full lg:w-96 lg:max-w-md flex-shrink-0 space-y-4">
                 <div id="multiplayer-chat-panel" class="glass-panel p-4 h-full min-h-[200px] lg:min-h-[400px] lg:max-h-[60vh] flex-col hidden">
                     <h3 class="text-lg font-bold mb-3 pb-2 border-b border-gray-700" style="color: var(--text-title);">ROOM CHAT</h3>
                     <div id="chat-messages" class="flex-grow overflow-y-auto mb-3 space-y-2 pr-2">
                         <!-- Chat messages dynamically generated -->
                     </div>
                     <div id="chat-input-container" class="flex gap-2 border-t border-gray-700 pt-3">
                         <input type="text" id="chat-input-field" class="name-input flex-grow rounded-lg py-2 px-3 text-sm" placeholder="Write a message..." maxlength="150">
                         <button id="chat-send-btn" class="play-button rounded-lg px-4 flex items-center justify-center" disabled>
                             <i data-lucide="send" class="w-5 h-5"></i>
                         </button>
                     </div>
                 </div>
                 
                 <div id="desktop-game-controls" class="hidden lg:flex justify-center items-center gap-4 mt-2">
                    <button id="ai-tip-btn-desktop" class="control-btn relative p-3 text-sm flex items-center gap-2" title="Get AI Hint (-5 Hearts)">
                        <i data-lucide="lightbulb" class="w-5 h-5"></i>
                        <span>AI Hint</span>
                    </button>
                    <button id="blocker-powerup-btn-desktop" class="control-btn p-3 text-sm flex items-center gap-2 text-red-400 hidden">
                        <i data-lucide="shield-ban" class="w-5 h-5"></i>
                        <span>Blocker</span>
                    </button>
                 </div>
            </div>
        </div>

        <!-- Fixed Controls Bar (Mobile) -->
        <div id="fixed-controls-bar" class="w-full max-w-lg mx-auto p-2 glass-button rounded-xl flex justify-around items-center gap-2 lg:hidden mt-auto mb-2">
            <button id="chat-toggle-btn" class="control-btn p-3 rounded-lg flex-1 flex justify-center items-center">
                <i data-lucide="message-square" class="w-6 h-6"></i>
            </button>
            <button id="ai-tip-btn" class="control-btn p-3 rounded-lg flex-1 flex justify-center items-center hidden" title="Get AI Hint (-5 Hearts)">
                <i data-lucide="lightbulb" class="w-6 h-6"></i>
            </button>
            <button id="blocker-powerup-btn-mobile" class="control-btn p-3 rounded-lg flex-1 flex justify-center items-center text-red-400 hidden">
                 <i data-lucide="shield-ban" class="w-6 h-6"></i>
            </button>
            <button id="settings-btn" class="control-btn p-3 rounded-lg flex-1 flex justify-center items-center">
                <i data-lucide="settings" class="w-6 h-6"></i>
            </button>
        </div>
        
        <div id="confetti-container" class="fixed inset-0 pointer-events-none z-50"></div>
    </div>

    <!-- Modals -->

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-backdrop fixed inset-0 z-[70] p-4 flex items-center justify-center hidden">
        <div class="modal-content w-full max-w-sm text-center p-6 sm:p-8">
            <button id="settings-close-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
            <h2 class="text-3xl font-bold mb-6" style="font-family: 'Oxanium', monospace;">
                SETTINGS
            </h2>
            <div class="space-y-4">
                <button id="restart-game-btn" class="control-btn py-3 text-lg w-full flex items-center justify-center gap-2 rounded-lg"><i data-lucide="refresh-cw" class="w-5 h-5"></i>Restart</button>
                <button id="in-game-sound-toggle-btn" class="control-btn py-3 text-lg w-full flex items-center justify-center gap-2 rounded-lg">
                     <i data-lucide="volume-2" class="w-5 h-5"></i>
                    <span>Sound On</span>
                </button>
                <button id="back-to-main-menu-btn" class="control-btn w-full justify-center py-3 text-lg mt-4 flex items-center gap-2 rounded-lg">
                    <i data-lucide="arrow-left" class="w-5 h-5"></i>Back to Main Menu
                </button>
            </div>
        </div>
    </div>

    <!-- Global Settings Modal -->
     <div id="global-settings-modal" class="modal-backdrop fixed inset-0 z-[70] p-4 flex items-center justify-center hidden">
        <div class="modal-content w-full max-w-sm text-center p-6 sm:p-8">
            <button id="global-settings-close-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
            <h2 class="text-3xl font-bold mb-6" style="font-family: 'Oxanium', monospace;">
                OPTIONS
            </h2>
            <div class="space-y-4">
                 <div>
                    <h3 class="text-lg font-semibold text-gray-400 mb-2 text-left">Your Name</h3>
                    <input type="text" id="player-name-input" class="name-input w-full rounded-lg py-3 px-4" placeholder="Player 1" maxlength="10">
                 </div>
                <button id="sound-toggle-btn" class="control-btn py-3 text-lg w-full flex items-center justify-center gap-2 rounded-lg">
                    <i data-lucide="volume-2" class="w-5 h-5"></i>
                    <span>Sound On</span>
                </button>
                <button id="logout-btn" class="control-btn w-full justify-center py-3 text-lg text-red-400 hover:text-red-300 hover:border-red-400 flex items-center gap-2 rounded-lg">
                    <i data-lucide="log-out" class="w-5 h-5"></i>
                    <span>Logout</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-backdrop fixed inset-0 z-[70] p-4 flex items-center justify-center hidden">
        <div class="modal-content w-full max-w-sm text-center p-6 sm:p-8">
             <h2 id="game-over-message" class="text-3xl font-bold mb-4" style="font-family: 'Oxanium', monospace;">
                 PLAYER X WINS!
             </h2>
             <div class="text-left mb-6 space-y-2 p-4 bg-gray-800 bg-opacity-50 rounded-lg">
                 <div class="flex justify-between"><span class="text-gray-400">Time Taken:</span> <span id="stat-time" class="font-bold text-white">0s</span></div>
                 <div class="flex justify-between"><span class="text-gray-400">Total Moves:</span> <span id="stat-moves" class="font-bold text-white">0</span></div>
                 <div class="flex justify-between"><span class="text-gray-400">Hearts Change:</span> <span id="stat-hearts" class="font-bold text-green-400">-1 Heart</span></div>
                 <div class="flex justify-between"><span class="text-gray-400">Win Streak:</span> <span id="stat-win-streak" class="font-bold text-orange-400">0 Wins</span></div>
             </div>
             <div class="flex flex-col space-y-4">
                 <button id="play-again-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg">
                     Next Round
                 </button>
                 <button id="back-to-menu-btn" class="control-btn w-full justify-center py-3 text-lg rounded-lg">
                     Back to Menu
                 </button>
             </div>
         </div>
    </div>

    <!-- FTF Modal -->
     <div id="ftf-modal" class="modal-backdrop fixed inset-0 z-[70] p-4 flex items-center justify-center hidden">
        <div id="ftf-content" class="modal-content w-full max-w-sm text-center p-6 sm:p-8">
            <button id="ftf-close-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
            <h2 id="ftf-title" class="text-3xl font-bold mb-6" style="font-family: 'Oxanium', monospace;">
                PLAY WITH FRIENDS
            </h2>
            <!-- Selection View -->
            <div id="ftf-selection-view">
                <div class="flex flex-col space-y-4">
                    <button id="ftf-create-room-select-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg flex items-center justify-center gap-2">
                        <i data-lucide="plus-square" class="w-5 h-5"></i>
                        <span>CREATE ROOM (-1 <i data-lucide="heart" class="w-4 h-4 inline fill-red-400 text-red-400"></i>)</span>
                    </button>
                    <button id="ftf-join-room-select-btn" class="control-btn w-full justify-center py-3 text-lg rounded-lg flex items-center gap-2">
                        <i data-lucide="log-in" class="w-5 h-5"></i>
                        <span>JOIN ROOM (-1 <i data-lucide="heart" class="w-4 h-4 inline fill-red-400 text-red-400"></i>)</span>
                    </button>
                </div>
            </div>
            <!-- Create View -->
            <div id="ftf-create-view" class="hidden space-y-6">
                <p class="text-sm text-gray-400">Share this code with your friend.</p>
                <div class="bg-gray-800 bg-opacity-50 p-4 rounded-xl flex justify-between items-center shadow-inner border border-gray-600">
                    <span id="room-code-display" class="text-2xl font-mono font-bold tracking-widest" style="color: var(--text-title);">LOADING...</span>
                    <button id="copy-room-code-btn" class="p-2 rounded-lg hover:bg-gray-700 transition-colors" title="Copy Code">
                         <i data-lucide="copy" class="w-5 h-5"></i>
                    </button>
                </div>
                <div id="waiting-status" class="flex flex-col items-center justify-center space-y-3 mt-4">
                    <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2" style="border-color: var(--text-title); border-top-color: transparent;"></div>
                    <p class="font-semibold" style="color: var(--text-title);">WAITING FOR PLAYER 2...</p>
                </div>
                 <button id="cancel-room-btn" class="control-btn justify-center py-2 text-md mt-4 text-red-400 hover:text-red-300 hover:border-red-400 rounded-lg w-full">
                    CANCEL
                </button>
            </div>
            <!-- Join View -->
             <div id="ftf-join-view" class="hidden space-y-4">
                <input type="text" id="join-room-input" class="name-input w-full text-center uppercase tracking-widest rounded-lg py-3 px-4" placeholder="ENTER ROOM CODE">
                <button id="join-room-submit-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg" disabled>
                    SUBMIT
                </button>
                <button id="back-to-selection-btn" class="control-btn w-full justify-center py-2 text-md mt-4 rounded-lg">
                    BACK
                </button>
            </div>
        </div>
    </div>

    <!-- Multiplayer Result Modal -->
    <div id="multiplayer-result-modal" class="modal-backdrop fixed inset-0 z-[70] p-4 flex items-center justify-center hidden">
        <div class="modal-content w-full max-w-md text-center p-6 sm:p-8">
            <button id="multiplayer-result-close-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
             <h2 id="multiplayer-result-title" class="text-3xl font-bold mb-4" style="font-family: 'Oxanium', monospace;">
                MATCH FINISHED
            </h2>
            <div id="multiplayer-score-display" class="flex justify-around items-center mb-6">
                 <!-- Player X Result -->
                 <div class="player-result-card player-x p-4 rounded-lg bg-gray-800 bg-opacity-50 w-32 space-y-1">
                     <span class="text-xs text-gray-400">PLAYER X</span>
                     <div class="result-icon h-10 flex items-center justify-center" style="color: var(--player-x-color); filter: drop-shadow(0 0 8px var(--player-x-color));"> <i id="result-icon-x" data-lucide="x" class="w-8 h-8"></i> </div>
                     <p id="result-name-x" class="result-name font-bold truncate text-white">Name X</p>
                     <p id="result-score-x" class="text-3xl font-bold" style="color: var(--text-title);">0</p>
                 </div>
                 <span class="text-4xl font-extrabold text-gray-500 mx-4">VS</span>
                 <!-- Player O Result -->
                 <div class="player-result-card player-o p-4 rounded-lg bg-gray-800 bg-opacity-50 w-32 space-y-1">
                     <span class="text-xs text-gray-400">PLAYER O</span>
                     <div class="result-icon h-10 flex items-center justify-center" style="color: var(--player-o-color); filter: drop-shadow(0 0 8px var(--player-o-color));"> <i id="result-icon-o" data-lucide="circle" class="w-8 h-8"></i> </div>
                     <p id="result-name-o" class="result-name font-bold truncate text-white">Name O</p>
                     <p id="result-score-o" class="text-3xl font-bold" style="color: var(--text-title);">0</p>
                 </div>
            </div>
            <!-- Stats -->
            <div class="text-left mb-4 space-y-1 text-sm p-4 bg-gray-800 bg-opacity-50 rounded-lg">
                  <div class="flex justify-between"><span class="text-gray-400">Hearts Change:</span> <span id="mp-stat-hearts" class="font-bold text-green-400">0 Hearts</span></div>
                  <div class="flex justify-between"><span class="text-gray-400">Win Streak:</span> <span id="mp-stat-win-streak" class="font-bold text-orange-400">0 Wins</span></div>
            </div>
            <!-- Rematch -->
            <p id="rematch-status" class="text-sm font-semibold mb-4 min-h-[1.25rem]">Awaiting opponent's request...</p>
            <div class="flex flex-col space-y-4">
                <button id="rematch-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg">
                    REQUEST REMATCH
                </button>
                <button id="multiplayer-back-to-menu-btn" class="control-btn w-full justify-center py-3 text-lg rounded-lg">
                    LEAVE ROOM
                </button>
            </div>
        </div>
    </div>
    
    <!-- NEW Profile Modal (From Screenshot 2) -->
    <div id="profile-modal" class="modal-backdrop fixed inset-0 z-[70] p-4 flex items-center justify-center hidden">
        <div class="modal-content w-full max-w-sm text-center p-6 sm:p-8">
            <button id="profile-modal-close-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
            
            <!-- Profile Info -->
            <div class="flex flex-col items-center mb-6">
                <div id="profile-modal-avatar" class="w-24 h-24 rounded-full glass-button flex items-center justify-center mb-4 border-2" style="border-color: var(--accent-primary);">
                    <i id="profile-modal-icon" data-lucide="user-circle-2" class="w-16 h-16" style="color: var(--accent-primary);"></i>
                </div>
                <h2 id="profile-modal-name" class="text-2xl font-bold text-white">Player</h2>
            </div>
            
            <!-- Game ID -->
            <div class="bg-gray-800 bg-opacity-50 p-4 rounded-xl shadow-inner border border-gray-600 mb-6">
                <h3 class="text-sm font-semibold text-gray-400 mb-1">Game ID (UID)</h3>
                <span id="profile-modal-uid" class="text-sm font-mono cursor-pointer transition-colors hover:text-white" style="color: var(--text-title);" title="Click to Copy ID">
                    LOADING...
                </span>
            </div>
            
            <!-- Stats -->
            <div class="grid grid-cols-3 gap-3 text-center mb-6">
                <div>
                    <div class="glass-panel p-3 rounded-lg">
                        <p id="profile-modal-wins" class="text-2xl font-bold" style="color: var(--text-title);">0</p>
                        <p class="text-xs text-gray-400">Wins</p>
                    </div>
                </div>
                <div>
                    <div class="glass-panel p-3 rounded-lg">
                        <p id="profile-modal-games" class="text-2xl font-bold" style="color: var(--text-title);">0</p>
                        <p class="text-xs text-gray-400">Games</p>
                    </div>
                </div>
                <div>
                    <div class="glass-panel p-3 rounded-lg">
                        <p id="profile-modal-winrate" class="text-2xl font-bold" style="color: var(--text-title);">0%</p>
                        <p class="text-xs text-gray-400">Win Rate</p>
                    </div>
                </div>
            </div>
            
            <!-- Avatar Selection -->
            <div>
                <h3 class="text-lg font-semibold text-gray-400 mb-3 text-left">Select Avatar</h3>
                <div id="profile-avatar-grid" class="grid grid-cols-4 gap-3">
                    <!-- Avatars dynamically generated -->
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, deleteDoc, runTransaction, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getDatabase, ref, onValue, set, onDisconnect, push, remove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Global State ---
        let app, auth, db, rtdb;
        let isAuthReady = false;
        let saveDebounceTimer = null;
        
        const SCORE_COLLECTION = 'tictactoe_scores';
        const ROOM_COLLECTION = 'rooms';
    
        // Fallback Config
        const FIREBASE_FALLBACK_CONFIG = {
            apiKey: "AIzaSyBUZ-U_NrrqLs5IHjT3QiJUI9UeYeknDQM",
            authDomain: "tic-tac-game-92b57.firebaseapp.com",
            databaseURL: "https://tic-tac-game-92b57-default-rtdb.firebaseio.com/", 
            projectId: "tic-tac-game-92b57",
            storageBucket: "tic-tac-game-92b57.appspot.com",
            messagingSenderId: "426567158009",
            appId: "1:426567158009:web:c086438883e025ff75f85b" 
        };
        
        // --- Game Constants ---
        const AI_PERSONALITIES = {
            easy: { name: 'NOODLER', thinking: 'Noodler is thinking...' },
            medium: { name: 'ANALYST', thinking: 'Analyst is thinking...' },
            hard: { name: 'ARCHITECT', thinking: 'Architect is thinking...' },
            grandmaster: { name: 'GRANDMASTER', thinking: 'Grandmaster is planning...' }
        };
        
        const FREE_REWARD_CAP = 100;
        const STARTING_HEARTS = 20;
        const REWARD_INTERVAL = 3 * 60 * 60 * 1000;
        const REWARD_AMOUNT = 3; 
        const AI_WIN_REWARD = 2;
        const AI_LOSE_COST = -1;
        const FTF_WIN_REWARD = 2;
        const FTF_CREATE_COST = -1;
        const FTF_JOIN_COST = -1;
        const AI_TIP_COST = 5;
        const WIN_STREAK_BONUS_COUNT = 3;
        const WIN_STREAK_BONUS_AMOUNT = 5;
        
        // Icon data (Cost: 0 = free)
        const ICON_COSTS = {
            'user-circle-2': ['user-circle-2', 0],
            'x': ['x', 0],
            'circle': ['circle', 0],
            'shield': ['shield', 5],
            'zap': ['zap', 8],
            'skull': ['skull', 15],
            'anchor': ['anchor', 10],
            'ghost': ['ghost', 12]
        };
        const MINIMAX_DEPTHS = { 3: 5, 4: 4, 5: 3 };
        
        // --- Player & Game State ---
        let gameSettings = {};
        let player1Name = "Play";
        let playerXScore = 0;
        let playerOScore = 0;
        let currentHearts = STARTING_HEARTS;
        let nextRewardTimestamp = 0;
        let winStreak = 0; 
        let playerXIcon = 'user-circle-2'; // Default to new icon
        let unlockedIcons = ['user-circle-2', 'x', 'circle'];
        let userProfile = { uid: null, displayName: 'Play', isGuest: true };
        let unsubscribeUserScoresListener = null;
        
        const humanPlayer = 'X';
        const aiPlayer = 'O';
        let playerOIcon = 'sparkles';
        let currentPlayer = 'X';
        let boardState = [];
        let isGameActive = true;
        let boardSize = 3;
        let moveHistory = [];
        let gameStartTime;
        let moveCount = 0;
        
        // --- Sound State ---
        let audioStarted = false; 
        let isMuted = false; 
        let clickSound, winSound, drawSound, undoSound, invalidSound, themeSound, timerTickSound, tipSound, loseSound, rematchSound;
        
        // --- Game Variant State ---
        let blockerCountX = 1;
        let blockerCountO = 1;
        let isBlockerActive = false;
        
        // --- Cooldowns ---
        let rewardTimerInterval; 
        let isMoveOnCooldown = false;
        const MOVE_COOLDOWN_MS = 300;
        let isChatOnCooldown = false;
        const CHAT_COOLDOWN_MS = 1500;
        
        // --- Multiplayer State ---
        let isCreatingRoom = false;
        let isMultiplayer = false;
        let currentRoomId = null;
        let myPlayerMark = null;
        let unsubscribeRoomListener = null;
        let unsubscribeChatListener = null;
        let unsubscribeOpponentPresence = null; 
        let opponentName = 'Opponent'; 
        let opponentMark = null; 
        let playerXRematch = false; 
        let playerORematch = false; 
        let rematchCountdownInterval = null; 
        let gameStartedNotified = false; 
        let mpPlayerXData = {}; 
        let mpPlayerOData = {}; 
        let notificationTimeout; 
        let lastKnownStateFingerprint = null; 
        let isChatPanelOpen = false;
        let gameEndedNotified = false; 
        
        // --- DOM Elements ---
        let loadingOverlay, notificationBar, messageOverlay, loginScreen, playBtn, oldGameIdInput, loadDataBtn, logoutBtn;
        let arcadeNexusScreen, profileBtn, topBarProfileIcon, winStreakCountEl, heartCountEl, globalSettingsBtn, collectRewardBtnTop, selectTttBtn, selectAiBtn, selectFtfBtn;
        let profileModal, profileModalCloseBtn, profileModalAvatar, profileModalIcon, profileModalName, profileModalUid, profileModalWins, profileModalGames, profileModalWinrate, profileAvatarGrid;
        let mainMenuScreen, mainMenuCloseBtn, startGameBtn, gameModeRadios, aiDifficultySection;
        let gameScreen, gameStatusDisplay, playerXProfile, playerOProfile, playerXScoreEl, playerOScoreEl, playerXNameEl, playerONameEl, gameBoardContainer, confettiContainer;
        let fixedControlsBar, chatToggleButton, aiTipBtn, aiTipBtnMobile, blockerPowerupBtn, blockerPowerupBtnMobile, settingsBtn;
        let settingsModal, settingsCloseBtn, restartGameBtn, inGameSoundToggleBtn, backToMainMenuBtn;
        let globalSettingsModal, globalSettingsCloseBtn, soundToggleBtn, playerNameInput;
        let gameOverModal, gameOverMessage, statTime, statMoves, statHearts, statWinStreak, playAgainBtn, backToMenuBtn;
        let ftfModal, ftfCloseBtn, ftfSelectionView, ftfCreateView, ftfJoinView, createRoomSelectBtn, joinRoomSelectBtn, roomCodeDisplay, copyRoomCodeBtn, waitingStatus, cancelRoomBtn, joinRoomInput, joinRoomSubmitBtn, backToSelectionBtn;
        let multiplayerResultModal, mpResultTitle, resultIconX, resultIconO, resultNameX, resultNameO, resultScoreX, resultScoreO, mpStatHearts, mpStatWinStreak, rematchBtn, mpBackToMenuBtn, rematchStatusEl;
        let multiplayerChatPanel, chatMessagesContainer, chatInputField, chatSendBtn;

        try {
            window.addEventListener('DOMContentLoaded', () => {
                console.log("DOM loaded. Futuristic UI Initializing...");
                
                // --- Initialize DOM Elements ---
                loadingOverlay = document.getElementById('loading-overlay');
                notificationBar = document.getElementById('notification-bar');
                messageOverlay = document.getElementById('message-overlay');
                loginScreen = document.getElementById('login-screen');
                playBtn = document.getElementById('play-btn');
                oldGameIdInput = document.getElementById('old-game-id-input');
                loadDataBtn = document.getElementById('load-data-btn');
                logoutBtn = document.getElementById('logout-btn');
                
                arcadeNexusScreen = document.getElementById('arcade-nexus-screen');
                profileBtn = document.getElementById('profile-btn');
                topBarProfileIcon = document.getElementById('top-bar-profile-icon');
                winStreakCountEl = document.getElementById('win-streak-count');
                heartCountEl = document.getElementById('heart-count');
                globalSettingsBtn = document.getElementById('global-settings-btn');
                collectRewardBtnTop = document.getElementById('collect-reward-btn-top');
                selectTttBtn = document.getElementById('select-ttt');
                selectAiBtn = document.getElementById('select-ai');
                selectFtfBtn = document.getElementById('select-ftf');

                profileModal = document.getElementById('profile-modal');
                profileModalCloseBtn = document.getElementById('profile-modal-close-btn');
                profileModalAvatar = document.getElementById('profile-modal-avatar');
                profileModalIcon = document.getElementById('profile-modal-icon');
                profileModalName = document.getElementById('profile-modal-name');
                profileModalUid = document.getElementById('profile-modal-uid');
                profileModalWins = document.getElementById('profile-modal-wins');
                profileModalGames = document.getElementById('profile-modal-games');
                profileModalWinrate = document.getElementById('profile-modal-winrate');
                profileAvatarGrid = document.getElementById('profile-avatar-grid');

                mainMenuScreen = document.getElementById('main-menu-screen');
                mainMenuCloseBtn = document.getElementById('main-menu-close-btn');
                startGameBtn = document.getElementById('start-game-btn');
                gameModeRadios = document.querySelectorAll('input[name="game-mode"]');
                aiDifficultySection = document.getElementById('ai-difficulty-section');
                
                gameScreen = document.getElementById('game-screen');
                gameStatusDisplay = document.getElementById('game-status-display');
                playerXProfile = document.getElementById('player-x-profile');
                playerOProfile = document.getElementById('player-o-profile');
                playerXScoreEl = document.getElementById('player-x-score');
                playerOScoreEl = document.getElementById('player-o-score');
                playerXNameEl = document.getElementById('player-x-name');
                playerONameEl = document.getElementById('player-o-name');
                gameBoardContainer = document.getElementById('game-board-container');
                confettiContainer = document.getElementById('confetti-container');
                
                fixedControlsBar = document.getElementById('fixed-controls-bar');
                chatToggleButton = document.getElementById('chat-toggle-btn');
                aiTipBtn = document.getElementById('ai-tip-btn-desktop');
                aiTipBtnMobile = document.getElementById('ai-tip-btn');
                blockerPowerupBtn = document.getElementById('blocker-powerup-btn-desktop');
                blockerPowerupBtnMobile = document.getElementById('blocker-powerup-btn-mobile');
                settingsBtn = document.getElementById('settings-btn');
                
                settingsModal = document.getElementById('settings-modal');
                settingsCloseBtn = document.getElementById('settings-close-btn');
                restartGameBtn = document.getElementById('restart-game-btn');
                inGameSoundToggleBtn = document.getElementById('in-game-sound-toggle-btn');
                backToMainMenuBtn = document.getElementById('back-to-main-menu-btn');
                
                globalSettingsModal = document.getElementById('global-settings-modal');
                globalSettingsCloseBtn = document.getElementById('global-settings-close-btn');
                soundToggleBtn = document.getElementById('sound-toggle-btn');
                playerNameInput = document.getElementById('player-name-input');
                
                gameOverModal = document.getElementById('game-over-modal');
                gameOverMessage = document.getElementById('game-over-message');
                statTime = document.getElementById('stat-time');
                statMoves = document.getElementById('stat-moves');
                statHearts = document.getElementById('stat-hearts');
                statWinStreak = document.getElementById('stat-win-streak');
                playAgainBtn = document.getElementById('play-again-btn');
                backToMenuBtn = document.getElementById('back-to-menu-btn');
                
                ftfModal = document.getElementById('ftf-modal');
                ftfCloseBtn = document.getElementById('ftf-close-btn');
                ftfSelectionView = document.getElementById('ftf-selection-view');
                ftfCreateView = document.getElementById('ftf-create-view');
                ftfJoinView = document.getElementById('ftf-join-view');
                createRoomSelectBtn = document.getElementById('ftf-create-room-select-btn');
                joinRoomSelectBtn = document.getElementById('ftf-join-room-select-btn');
                roomCodeDisplay = document.getElementById('room-code-display');
                copyRoomCodeBtn = document.getElementById('copy-room-code-btn');
                waitingStatus = document.getElementById('waiting-status');
                cancelRoomBtn = document.getElementById('cancel-room-btn');
                joinRoomInput = document.getElementById('join-room-input');
                joinRoomSubmitBtn = document.getElementById('join-room-submit-btn');
                backToSelectionBtn = document.getElementById('back-to-selection-btn');
                
                multiplayerResultModal = document.getElementById('multiplayer-result-modal');
                mpResultTitle = document.getElementById('multiplayer-result-title');
                resultIconX = document.getElementById('result-icon-x');
                resultIconO = document.getElementById('result-icon-o');
                resultNameX = document.getElementById('result-name-x');
                resultNameO = document.getElementById('result-name-o');
                resultScoreX = document.getElementById('result-score-x');
                resultScoreO = document.getElementById('result-score-o');
                mpStatHearts = document.getElementById('mp-stat-hearts');
                mpStatWinStreak = document.getElementById('mp-stat-win-streak');
                rematchBtn = document.getElementById('rematch-btn');
                mpBackToMenuBtn = document.getElementById('multiplayer-back-to-menu-btn');
                rematchStatusEl = document.getElementById('rematch-status');
                
                multiplayerChatPanel = document.getElementById('multiplayer-chat-panel');
                chatMessagesContainer = document.getElementById('chat-messages');
                chatInputField = document.getElementById('chat-input-field');
                chatSendBtn = document.getElementById('chat-send-btn');
                
                // --- Initialize Sound ---
                initializeSounds();
                
                // --- Initialize Firebase ---
                loadSettings();
                initializeFirebase();
                
                // --- Event Listeners ---
                setupGlobalEventListeners();
                setupMenuEventListeners();
                setupGameEventListeners();
                setupMultiplayerEventListeners();

            });
        } catch (error) {
            console.error("Critical error during initialization:", error);
            document.body.innerHTML = `<div style="color: red; padding: 20px;"><h1>Initialization Error</h1><p>Something went wrong. Check console.</p><pre>${error.stack || error}</pre></div>`;
        }

        // --- Sound Initialization ---
        function initializeSounds() {
            try {
                if (typeof Tone !== 'undefined' && Tone.Synth) {
                    clickSound = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 } }).toDestination();
                    winSound = new Tone.PolySynth(Tone.Synth, { envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
                    drawSound = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.0, release: 0.1 } }).toDestination();
                    undoSound = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
                    invalidSound = new Tone.Synth({ oscillator: { type: 'square' }, volume: -12, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                    themeSound = new Tone.Synth({ oscillator: { type: 'sine' }, volume: -10, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                    timerTickSound = new Tone.Synth({ oscillator: { type: 'sine' }, volume: -15, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                    tipSound = new Tone.Synth({ oscillator: { type: 'triangle' }, volume: -8, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                    loseSound = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 }, volume: -15 }).toDestination(); 
                    rematchSound = new Tone.Synth({ oscillator: { type: 'square' }, volume: -10, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination(); 
                } else {
                    throw new Error("Tone.js missing");
                }
            } catch (e) {
                console.error("Tone.js init error:", e);
                const dummySound = { triggerAttackRelease: () => {} };
                clickSound = winSound = drawSound = undoSound = invalidSound = themeSound = timerTickSound = tipSound = loseSound = rematchSound = dummySound;
                [soundToggleBtn, inGameSoundToggleBtn].forEach(btn => {
                    if(btn) {
                        btn.disabled = true;
                        const span = btn.querySelector('span');
                        if(span) span.textContent = 'Sound Error';
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                });
            }
        }

        // --- Global Listeners ---
        function setupGlobalEventListeners() {
            playBtn.addEventListener('click', () => {
                localStorage.setItem('ticTacToePlayedOnce', 'true');
                showScreen(arcadeNexusScreen);
            });

            loadDataBtn.addEventListener('click', async () => {
                const targetUid = oldGameIdInput.value.trim();
                if (!targetUid || targetUid.length < 20) {
                    showNotification('Please enter a valid Game ID.', 'error');
                    return;
                }
                loadDataBtn.disabled = true;
                if (unsubscribeUserScoresListener) unsubscribeUserScoresListener();
                
                await listenToUserScores(targetUid);
                
                loadDataBtn.disabled = false;
                userProfile.uid = targetUid;
                userProfile.displayName = player1Name; 
                localStorage.setItem('ticTacToePlayedOnce', 'true');
                localStorage.setItem('ticTacToeLoadedUID', targetUid); 
                
                showNotification(`Data loaded successfully for ID: ${targetUid.substring(0, 8)}...`, 'success');
                showScreen(arcadeNexusScreen);
                updateUIforUser();
                startRewardTimer();
                oldGameIdInput.value = '';
            });

            logoutBtn.addEventListener('click', () => {
                localStorage.removeItem('ticTacToePlayedOnce');
                localStorage.removeItem('ticTacToeLoadedUID'); 
                if (auth) signOut(auth).catch(error => console.error("Sign-out failed:", error));
            });

            playerNameInput.addEventListener('input', () => {
                const newName = playerNameInput.value.trim().substring(0, 10) || 'Play';
                player1Name = newName;
                userProfile.displayName = newName;
                if(userProfile.uid) saveAllData();
                updateUIforUser(); // Updates name in profile modal if open
            });

            collectRewardBtnTop.addEventListener('click', async () => {
                if (currentHearts >= FREE_REWARD_CAP || nextRewardTimestamp > Date.now() || collectRewardBtnTop.disabled) {
                    showNotification('Reward not ready or hearts are full!', 'info');
                    return;
                }
                currentHearts += REWARD_AMOUNT;
                nextRewardTimestamp = Date.now() + REWARD_INTERVAL;
                await saveAllData();
                showNotification(`${REWARD_AMOUNT} Hearts collected!`, 'success');
                updateHeartsUI();
                startRewardTimer();
            });

            [soundToggleBtn, inGameSoundToggleBtn].forEach(btn => {
                btn.addEventListener('click', () => setSoundState(!isMuted));
            });

            // New Profile Modal Listeners
            profileBtn.addEventListener('click', showProfileModal);
            profileModalCloseBtn.addEventListener('click', () => hideScreen(profileModal));
            
            profileAvatarGrid.addEventListener('click', async (e) => {
                const target = e.target.closest('.avatar-option'); 
                if (!target) return;
                
                const id = target.dataset.id;
                const cost = parseInt(target.dataset.cost);
                const isUnlocked = unlockedIcons.includes(id) || cost === 0;

                if (!isUnlocked) {
                    if (currentHearts >= cost) {
                        currentHearts -= cost;
                        unlockedIcons.push(id);
                        showNotification(`${id} unlocked for ${cost} hearts!`, 'success');
                        await saveAllData(); 
                        renderProfileAvatarGrid(); // Re-render to show unlocked
                        updateHeartsUI();
                    } else {
                        showNotification(`Need ${cost - currentHearts} more hearts to unlock!`, 'error');
                        return;
                    }
                }
                
                playerXIcon = id;
                document.querySelectorAll('.avatar-option').forEach(el => el.classList.remove('selected'));
                target.classList.add('selected');
                
                // Update icons instantly
                updatePlayerIconDisplay('X', playerXIcon);
                updatePlayerIconDisplay('profile', playerXIcon);
                
                await saveSettings();
                await saveAllData(); // Save new icon choice
            });

            document.addEventListener('click', (e) => {
                if (e.target.id === 'profile-modal-uid' && userProfile.uid) {
                    e.preventDefault();
                    copyTextToClipboard(userProfile.uid);
                }
            });
        }
        
        // --- Menu Listeners ---
        function setupMenuEventListeners() {
            selectTttBtn.addEventListener('click', () => {
                hideScreen(arcadeNexusScreen, () => {
                    document.querySelector('input[name="game-mode"][value="pvp"]').checked = true;
                    document.querySelector('input[name="game-mode"]:checked').dispatchEvent(new Event('change'));
                    showScreen(mainMenuScreen);
                });
            });
            selectAiBtn.addEventListener('click', () => {
                hideScreen(arcadeNexusScreen, () => {
                    document.querySelector('input[name="game-mode"][value="pva"]').checked = true;
                    document.querySelector('input[name="game-mode"]:checked').dispatchEvent(new Event('change'));
                    showScreen(mainMenuScreen);
                });
            });
            globalSettingsBtn.addEventListener('click', () => { 
                playerNameInput.value = player1Name;
                showScreen(globalSettingsModal); 
            });
            globalSettingsCloseBtn.addEventListener('click', () => { hideScreen(globalSettingsModal, () => showScreen(arcadeNexusScreen)); }); 
            
            mainMenuCloseBtn.addEventListener('click', () => { hideScreen(mainMenuScreen, () => showScreen(arcadeNexusScreen)); });
            
            startGameBtn.addEventListener('click', () => {
                 gameSettings.gameMode = document.querySelector('input[name="game-mode"]:checked').value;
                 if (gameSettings.gameMode === 'pva' && currentHearts < Math.abs(AI_LOSE_COST)) {
                      showNotification(`Not enough hearts! Need ${Math.abs(AI_LOSE_COST)} heart to play vs AI.`, 'error');
                      return;
                 }
                 gameEndedNotified = false;
                 gameSettings.boardSize = parseInt(document.querySelector('input[name="board-size"]:checked').value);
                 gameSettings.aiDifficulty = document.querySelector('input[name="ai-difficulty"]:checked')?.value || 'medium';
                 gameSettings.gameVariant = document.querySelector('input[name="game-variant"]:checked').value;
                 
                 if(gameSettings.gameMode === 'pva' && !isMultiplayer) {
                     currentHearts = Math.max(0, currentHearts + AI_LOSE_COST);
                     updateHeartsUI();
                     saveAllData(); 
                 }
                 hideScreen(mainMenuScreen, () => showScreen(gameScreen));
                 initializeGame();
                 saveSettings();
            });
            
            gameModeRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    const isPVA = radio.value === 'pva';
                    aiDifficultySection.classList.toggle('hidden', !isPVA);
                    const showBlocker = document.querySelector('input[name="game-variant"]:checked').value === 'blocker';
                    blockerPowerupBtn.classList.toggle('hidden', !showBlocker || !isPVA);
                    blockerPowerupBtnMobile.classList.toggle('hidden', !showBlocker || !isPVA);
                });
            });
        }
        
        // --- Game Listeners ---
        function setupGameEventListeners() {
            gameBoardContainer.addEventListener('click', handleCellClick);
            
            settingsBtn.addEventListener('click', () => { 
                confettiContainer.innerHTML = '';
                showScreen(settingsModal); 
            });
            settingsCloseBtn.addEventListener('click', () => { hideScreen(settingsModal, () => showScreen(gameScreen)); });
            
            playAgainBtn.addEventListener('click', () => {
                 if (playAgainBtn.disabled) return;
                 playAgainBtn.disabled = true;
                 hideScreen(gameOverModal, () => { 
                     resetBoardVisuals(); 
                     initializeGame(); 
                     showScreen(gameScreen);
                     playAgainBtn.disabled = false;
                 });
            });
            
            [backToMenuBtn, mpBackToMenuBtn, backToMainMenuBtn].forEach(btn => { 
                btn.addEventListener('click', async () => {
                     const actionAfterHiding = () => {
                         if (isMultiplayer) {
                              showScreen(arcadeNexusScreen); 
                              (async () => {
                                   await cancelRoom();
                                   if (unsubscribeRoomListener) unsubscribeRoomListener();
                                   if (unsubscribeChatListener) unsubscribeChatListener(); 
                                   if (unsubscribeOpponentPresence) { 
                                      unsubscribeOpponentPresence();
                                      unsubscribeOpponentPresence = null;
                                   }
                                   if (rtdb && userProfile.uid) {
                                       const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                                       const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                                       const userStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${userProfile.uid}`);
                                       await set(userStatusRef, false); 
                                       setupPresence(userProfile.uid);
                                   }
                                   clearInterval(rematchCountdownInterval); 
                                   clearInterval(rewardTimerInterval); 
                                   isMultiplayer = false;
                                   playerXRematch = false;
                                   playerORematch = false;
                                   gameStartedNotified = false; 
                                   lastKnownStateFingerprint = null; 
                                   isChatPanelOpen = false; 
                                   multiplayerChatPanel.classList.add('hidden'); 
                              })();
                         } else {
                              showScreen(arcadeNexusScreen); 
                         }
                     };
                     
                     let visibleModal = null;
                     if (!settingsModal.classList.contains('hidden')) visibleModal = settingsModal;
                     else if (!gameOverModal.classList.contains('hidden')) visibleModal = gameOverModal;
                     else if (!multiplayerResultModal.classList.contains('hidden')) visibleModal = multiplayerResultModal;
                    
                     hideScreen(gameScreen); 
                     if (visibleModal) {
                         hideScreen(visibleModal, actionAfterHiding);
                     } else {
                         setTimeout(actionAfterHiding, 300);
                     }
                });
            });
            
            [blockerPowerupBtn, blockerPowerupBtnMobile].forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!isGameActive || btn.disabled) return;
                    isBlockerActive = !isBlockerActive;
                    gameBoardContainer.classList.toggle('blocker-active', isBlockerActive);
                    blockerPowerupBtn.classList.toggle('active', isBlockerActive);
                    blockerPowerupBtnMobile.classList.toggle('active', isBlockerActive);
                    if (!isBlockerActive) updateTurnStatus();
                    else playSound(clickSound, 'A4', '0.05');
                });
            });
            
            [aiTipBtn, aiTipBtnMobile].forEach(tipBtn => {
                tipBtn.addEventListener('click', async () => {
                    if (currentHearts < AI_TIP_COST || !isGameActive) {
                        if (currentHearts < AI_TIP_COST) showNotification(`Need ${AI_TIP_COST} hearts for a tip!`, 'error');
                        return;
                    }
                    if (!((gameSettings.gameMode === 'pva' && currentPlayer === humanPlayer))) return;
                    
                    playSound(tipSound, ['G5', 'E6'], '0.1');
                    currentHearts = Math.max(0, currentHearts - AI_TIP_COST);
                    await saveAllData();
                    updateHeartsUI();
                    
                    tipBtn.disabled = true;
                    if(currentHearts < AI_TIP_COST) {
                        aiTipBtn.disabled = true;
                        aiTipBtnMobile.disabled = true;
                    }
                    
                    const hintIndex = findBestMove(boardState.slice(), true);
                    if (hintIndex !== -1) {
                        const cell = gameBoardContainer.querySelector(`[data-index='${hintIndex}']`);
                        if (cell) cell.classList.add('ai-tip-highlight');
                        setTimeout(() => cell.classList.remove('ai-tip-highlight'), 300);
                    } else {
                        showNotification('No clear advantage found.', 'info');
                    }
                });
            });
        }

        // --- Multiplayer Listeners ---
        function setupMultiplayerEventListeners() {
            selectFtfBtn.addEventListener('click', () => {
                ftfModal.classList.remove('hidden');
                showFtfView('selection');
            });
            ftfCloseBtn.addEventListener('click', async () => {
                if (currentRoomId && myPlayerMark) await cancelRoom();
                hideScreen(ftfModal);
            });
            cancelRoomBtn.addEventListener('click', async () => {
                await cancelRoom();
                showFtfView('selection');
            });
            backToSelectionBtn.addEventListener('click', () => showFtfView('selection'));
            
            createRoomSelectBtn.addEventListener('click', () => {
                if (isCreatingRoom) return;
                if (currentHearts < Math.abs(FTF_CREATE_COST)) {
                    showNotification(`Not enough hearts! Need ${Math.abs(FTF_CREATE_COST)}.`, 'error');
                    return;
                }
                isCreatingRoom = true;
                setTimeout(() => { isCreatingRoom = false; }, 10000); 
                showFtfView('create');
                createRoom();
            });
            
            joinRoomSelectBtn.addEventListener('click', () => showFtfView('join'));
            
            joinRoomInput.addEventListener('input', () => {
                joinRoomInput.value = joinRoomInput.value.toUpperCase();
                joinRoomSubmitBtn.disabled = joinRoomInput.value.trim().length !== 6;
            });
            
            joinRoomSubmitBtn.addEventListener('click', () => {
                const code = joinRoomInput.value.trim().toUpperCase();
                if (code.length === 6) joinRoom(code);
            });
            
            copyRoomCodeBtn.addEventListener('click', () => {
                 const code = roomCodeDisplay.textContent;
                 if (code && code !== 'LOADING...') copyTextToClipboard(code);
                 else showNotification('Room code is not yet ready.', 'info');
            });
            
            rematchBtn.addEventListener('click', async () => {
                if (!currentRoomId || !myPlayerMark) return;
                rematchBtn.disabled = true;
                rematchBtn.textContent = 'WAITING...';
                playSound(rematchSound, 'C4', '0.1');
                try {
                    const roomDocRef = getRoomDocRef(currentRoomId);
                    if (myPlayerMark === 'X') await updateDoc(roomDocRef, { rematchX: true });
                    else await updateDoc(roomDocRef, { rematchO: true });
                } catch (e) {
                    console.error("Error requesting rematch:", e);
                    showNotification('Failed to send rematch request.', 'error');
                    rematchBtn.disabled = false;
                }
            });
            
            chatSendBtn.addEventListener('click', sendChatMessage);
            chatInputField.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !chatSendBtn.disabled) sendChatMessage();
            });
            
            chatToggleButton.addEventListener('click', () => {
                 if (!isMultiplayer && !currentRoomId) {
                      showNotification('Chat is only available in Play with Friends mode.', 'info');
                      return;
                 }
                 isChatPanelOpen = !isChatPanelOpen;
                 if (window.innerWidth >= 1024) { // Desktop
                     multiplayerChatPanel.classList.toggle('hidden', !isChatPanelOpen);
                 } else { // Mobile
                     multiplayerChatPanel.classList.toggle('hidden', !isChatPanelOpen);
                 }
                 if(isChatPanelOpen) chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            });
        }
        
        // --- Sound Control ---
        function playSound(sound, note = 'C5', duration = '8n') {
            if (!audioStarted || isMuted || !sound || typeof sound.triggerAttackRelease !== 'function') return;
            try {
                if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                    Tone.start();
                    audioStarted = true;
                }
                sound.triggerAttackRelease(note, duration);
            } catch (e) { console.warn(`Sound play failed for [${note}]:`, e); }
        }
        
        function setSoundState(muted) {
            if (!muted && !audioStarted && typeof Tone !== 'undefined') {
                 Tone.start().then(() => {
                      audioStarted = true;
                      console.log('Audio context started on unmute.');
                 });
            }
            isMuted = muted;
            localStorage.setItem('ticTacToeMuted', isMuted ? 'true' : 'false');
            const icon = isMuted ? 'volume-x' : 'volume-2';
            const text = isMuted ? 'Sound Off' : 'Sound On';
            [soundToggleBtn, inGameSoundToggleBtn].forEach(btn => {
                 if(btn) {
                     const i = btn.querySelector('i');
                     const span = btn.querySelector('span');
                     if (i) i.setAttribute('data-lucide', icon);
                     if (span) span.textContent = text;
                     if (isMuted) btn.classList.add('opacity-70');
                     else btn.classList.remove('opacity-70');
                     if (i) lucide.createIcons({ nodes: [i] });
                 }
            });
        }
        
        // --- UI Control ---
        function showNotification(message, type = 'info', isChatMessage = false) {
            clearTimeout(notificationTimeout);
            const bar = isChatMessage ? messageOverlay : notificationBar;
            
            bar.textContent = message;
            bar.classList.remove('opacity-0', '-translate-y-10');
            if (!isChatMessage) {
                bar.classList.remove('bg-green-500', 'bg-red-500', 'bg-blue-500');
                if (type === 'success') bar.classList.add('bg-green-500');
                else if (type === 'error') bar.classList.add('bg-red-500');
                else bar.classList.add('bg-blue-500');
            }
            
            notificationTimeout = setTimeout(() => {
                bar.classList.add('opacity-0', '-translate-y-10');
            }, 3000);
        }
        
        function copyTextToClipboard(text) {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showNotification('Code copied to clipboard!', 'success');
                }).catch(err => fallbackCopyTextToClipboard(text));
                return;
            }
            fallbackCopyTextToClipboard(text);
        }

        function fallbackCopyTextToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            try {
                if (document.execCommand('copy')) showNotification('Code copied to clipboard!', 'success');
                else showNotification('Copy failed. Please manually select.', 'error');
            } catch (err) {
                showNotification('Copy failed. Please manually select.', 'error');
            }
            document.body.removeChild(textarea);
        }
        
        function generateRoomId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));
            return result;
        }
        
        function showScreen(screenToShow) {
            [loadingOverlay, loginScreen, arcadeNexusScreen, mainMenuScreen, gameScreen, gameOverModal, settingsModal, globalSettingsModal, ftfModal, multiplayerResultModal, profileModal].forEach(screen => {
                if (screen) screen.classList.add('hidden');
            });
            if (screenToShow) {
                screenToShow.classList.remove('hidden');
            }
        }
        
        function hideScreen(screenToHide, onHidden) {
             if (!screenToHide || screenToHide.classList.contains('hidden')) { 
                 if (onHidden) onHidden(); 
                 return; 
             }
             screenToHide.classList.add('hidden');
             if (onHidden) onHidden();
        }
        
        function applyTheme(mode) {
             const htmlEl = document.documentElement;
             if (mode === 'pva') htmlEl.setAttribute('data-theme', 'purple');
             else htmlEl.setAttribute('data-theme', 'friend-blue');
        }

        // --- New Profile Modal Functions ---
        function showProfileModal() {
            const totalGames = playerXScore + playerOScore;
            const winRate = totalGames > 0 ? Math.round((playerXScore / totalGames) * 100) : 0;

            profileModalName.textContent = player1Name;
            profileModalUid.textContent = userProfile.uid || 'N/A';
            profileModalWins.textContent = playerXScore;
            profileModalGames.textContent = totalGames;
            profileModalWinrate.textContent = `${winRate}%`;

            updatePlayerIconDisplay('profile', playerXIcon);
            renderProfileAvatarGrid();
            showScreen(profileModal);
        }
        
        function renderProfileAvatarGrid() {
            profileAvatarGrid.innerHTML = '';
            Object.entries(ICON_COSTS).forEach(([id, [iconName, cost]]) => {
                const isUnlocked = unlockedIcons.includes(id) || cost === 0;
                const isSelected = id === playerXIcon;
                
                const div = document.createElement('div');
                div.className = `avatar-option aspect-square rounded-lg flex items-center justify-center cursor-pointer relative ${isSelected ? 'selected' : ''} ${!isUnlocked ? 'locked' : ''}`;
                div.dataset.id = id;
                div.dataset.cost = cost;
                
                let innerHTML = `<i data-lucide="${iconName}" class="w-7 h-7 ${!isUnlocked ? 'opacity-30' : 'text-white'}"></i>`;
                
                if (!isUnlocked) {
                    innerHTML += `<div class="absolute inset-0 bg-black bg-opacity-60 rounded-lg flex flex-col items-center justify-center p-1">
                                    <i data-lucide="lock" class="w-4 h-4 text-white"></i>
                                    <span class="text-xs font-bold text-white flex items-center gap-1">${cost} <i data-lucide="heart" class="w-3 h-3 fill-red-400 text-red-400"></i></span>
                                 </div>`;
                }
                
                div.innerHTML = innerHTML;
                profileAvatarGrid.appendChild(div);
            });
            lucide.createIcons({ nodes: profileAvatarGrid.querySelectorAll('i') });
        }
        
        // --- Core Data & UI ---
        function loadSettings() {
            gameSettings = {}; 
            player1Name = 'Play';
            playerNameInput.value = player1Name;
            
            document.querySelector(`input[name="board-size"][value="3"]`).checked = true;
            document.querySelector(`input[name="game-mode"][value="pvp"]`).checked = true;
            document.querySelector(`input[name="ai-difficulty"][value="medium"]`).checked = true;
            document.querySelector(`input[name="game-variant"][value="classic"]`).checked = true;

            const gameModeChecked = document.querySelector('input[name="game-mode"]:checked');
            if (gameModeChecked) gameModeChecked.dispatchEvent(new Event('change'));
            
            isMuted = localStorage.getItem('ticTacToeMuted') === 'true';
            setSoundState(isMuted);
            
            playerXIcon = 'user-circle-2';
        }
        
        function saveSettings() {
            // Settings are now saved in the main data save
        }
        
        function getScoreDocRef(userId) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId; 
            return doc(db, 'artifacts', appId, 'users', userId, SCORE_COLLECTION, 'user_scores');
        }
        
        function getRoomDocRef(roomId) {
            const isCanvasEnv = typeof __app_id !== 'undefined';
            let appId = isCanvasEnv ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
            return doc(db, 'artifacts', appId, 'public', 'data', ROOM_COLLECTION, roomId);
        }
        
        function getChatRoomRef(roomId) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
            const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
            return ref(rtdb, `artifacts/${rtdbAppId}/public/data/chat/${roomId}`);
        }
        
        async function listenToUserScores(uid) {
            if (!isAuthReady || !uid) return;
            if (unsubscribeUserScoresListener) unsubscribeUserScoresListener();
        
            const scoreDocRef = getScoreDocRef(uid);
            unsubscribeUserScoresListener = onSnapshot(scoreDocRef, async (docSnap) => {
                let dataToSave = {};
                let needsSave = false;
        
                if (docSnap.exists()) {
                    dataToSave = docSnap.data();
                } else {
                    dataToSave = {
                        x: 0, o: 0,
                        hearts: STARTING_HEARTS,
                        nextRewardTimestamp: Date.now() + REWARD_INTERVAL,
                        unlockedIcons: ['user-circle-2', 'x', 'circle'],
                        winStreak: 0,
                        displayName: userProfile.displayName,
                        gameSettings: {},
                        playerXIcon: 'user-circle-2'
                    };
                    needsSave = true;
                }
        
                playerXScore = dataToSave.x || 0;
                playerOScore = dataToSave.o || 0;
                currentHearts = (dataToSave.hearts !== undefined && dataToSave.hearts !== null) ? dataToSave.hearts : STARTING_HEARTS;
                nextRewardTimestamp = dataToSave.nextRewardTimestamp || Date.now();
                unlockedIcons = dataToSave.unlockedIcons || ['user-circle-2', 'x', 'circle'];
                winStreak = dataToSave.winStreak || 0;
                player1Name = dataToSave.displayName || userProfile.displayName;
                gameSettings = dataToSave.gameSettings || {};
                
                if (unlockedIcons.includes(dataToSave.playerXIcon) && ICON_COSTS[dataToSave.playerXIcon]) {
                    playerXIcon = dataToSave.playerXIcon;
                } else {
                    playerXIcon = 'user-circle-2';
                }
                
                playerXScoreEl.textContent = playerXScore;
                playerOScoreEl.textContent = playerOScore;
        
                if (needsSave) await setDoc(scoreDocRef, dataToSave, { merge: true });

                userProfile.displayName = player1Name;
                updateUIforUser();
                startRewardTimer();
                
            }, (error) => {
                console.error("Error listening to user scores:", error);
                playerXScore = 0; playerOScore = 0;
                currentHearts = STARTING_HEARTS;
                winStreak = 0;
                updateUIforUser();
            });
        }
        
        async function saveAllData() {
            if (saveDebounceTimer) clearTimeout(saveDebounceTimer);
        
            saveDebounceTimer = setTimeout(async () => {
                if (!isAuthReady || !userProfile.uid) return;
                try {
                    const scoreDocRef = getScoreDocRef(userProfile.uid);
                    const data = {
                        x: playerXScore,
                        o: playerOScore,
                        hearts: currentHearts,
                        nextRewardTimestamp: nextRewardTimestamp,
                        playerXIcon: playerXIcon, 
                        unlockedIcons: unlockedIcons, 
                        winStreak: winStreak, 
                        displayName: player1Name, 
                        gameSettings: gameSettings,
                        lastUpdated: new Date()
                    };
                    await setDoc(scoreDocRef, data, { merge: true });
                } catch (e) { console.error("Error saving data to Firestore:", e); }
                finally { saveDebounceTimer = null; }
            }, 2000);
        }
        
        // --- Firebase Auth & Setup ---
        async function initializeFirebase() {
            try {
                const canvasConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
                const firebaseConfig = canvasConfig && canvasConfig.projectId ? canvasConfig : FIREBASE_FALLBACK_CONFIG;
                if (!firebaseConfig.projectId) {
                    await handleAuth(null); 
                    loadingOverlay.classList.add('hidden'); 
                    return;
                }
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                rtdb = getDatabase(app); 
                auth = getAuth(app);
                setLogLevel('debug'); 
                
                onAuthStateChanged(auth, async (user) => {
                    isAuthReady = true;
                    loadingOverlay.classList.add('hidden');
                    await handleAuth(user);
                });
                
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                if (initialAuthToken) {
                    signInWithCustomToken(auth, initialAuthToken).catch(error => {
                        console.warn("Custom token sign-in failed, falling back to anonymous:", error.message);
                        signInAnonymously(auth).catch(async anonError => { 
                             console.error("Anonymous Sign-in failed after token failure:", anonError);
                             await handleAuth(null); 
                        });
                    });
                } else {
                    signInAnonymously(auth).catch(async anonError => {
                         console.error("Initial Anonymous Sign-in failed:", anonError);
                         await handleAuth(null); 
                    });
                }
            } catch (e) {
                console.error("Firebase Initialization Failed:", e);
                await handleAuth(null); 
            }
        }
        
        async function handleAuth(user) {
            if (unsubscribeUserScoresListener) unsubscribeUserScoresListener();
            
            if (user) {
                const loadedUID = localStorage.getItem('ticTacToeLoadedUID');
                let effectiveUID = loadedUID || user.uid;
                
                userProfile = {
                    uid: effectiveUID,
                    displayName: 'Play',
                    isGuest: user.isAnonymous,
                };
                
                await listenToUserScores(effectiveUID);
                setupPresence(effectiveUID); 
                
                userProfile.displayName = player1Name; 
                updateUIforUser(); 
                startRewardTimer(); 
                
                const playedOnce = localStorage.getItem('ticTacToePlayedOnce') === 'true';
                showScreen(playedOnce ? arcadeNexusScreen : loginScreen);
            } else {
                userProfile = { uid: null, displayName: 'Play', isGuest: true };
                updateUIforUser();
                showScreen(loginScreen); 
            }
            try { lucide.createIcons(); } catch(e) { console.error("Lucide icon creation failed:", e); }
        }
        
        function setupPresence(userId) {
            if (!rtdb) return; 
            const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
            const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
            const userStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${userId}`);
            
            onDisconnect(userStatusRef).set(false).catch((err) => console.error("RTDB onDisconnect setup failed:", err));
            set(userStatusRef, true).catch((err) => console.error("RTDB initial presence set failed:", err));
        }

        // --- UI Update Functions ---
        function updateUIforUser() {
            if (userProfile.uid) {
                playerNameInput.value = player1Name;
            } else {
                playerNameInput.value = 'Play';
            }
            
            applyTheme(gameSettings.gameMode === 'pva' ? 'pva' : 'pvp');
            playerXScoreEl.textContent = playerXScore;
            playerOScoreEl.textContent = playerOScore;
            winStreakCountEl.textContent = winStreak; 
            updateHeartsUI(); 
            updatePlayerIconDisplay('X', playerXIcon); // Game screen
            updatePlayerIconDisplay('profile', playerXIcon); // Top bar & modal
        }
        
        function updateHeartsUI() {
            heartCountEl.textContent = `${currentHearts}`;
            const now = Date.now();
            const timeRemaining = nextRewardTimestamp - now;
            
            if (currentHearts >= FREE_REWARD_CAP) {
                collectRewardBtnTop.disabled = true;
                collectRewardBtnTop.querySelector('span').textContent = 'Hearts Full';
                return;
            }
            if (timeRemaining <= 0) {
                collectRewardBtnTop.disabled = false;
                collectRewardBtnTop.querySelector('span').textContent = 'Collect Reward';
            } else {
                collectRewardBtnTop.disabled = true;
                const totalSeconds = Math.floor(timeRemaining / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                collectRewardBtnTop.querySelector('span').textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        function startRewardTimer() {
            clearInterval(rewardTimerInterval);
            updateHeartsUI();
            rewardTimerInterval = setInterval(updateHeartsUI, 1000);
        }
        
        function updatePlayerIconDisplay(player, iconName) {
            let iconContainer, profileIconEl;
            
            if (player === 'X') {
                iconContainer = playerXProfile.querySelector('.icon');
            } else if (player === 'O') {
                iconContainer = playerOProfile.querySelector('.icon');
                if (!isMultiplayer && gameSettings.gameMode === 'pva') iconName = 'sparkles';
            } else if (player === 'profile') {
                iconContainer = topBarProfileIcon; // Top bar
                profileIconEl = profileModalIcon; // Modal main icon
            }
            
            const iconData = ICON_COSTS[iconName] || ICON_COSTS['user-circle-2'];
            if (!iconData) return;
            
            const iEl = document.createElement('i');
            iEl.setAttribute('data-lucide', iconData[0]);
            
            if (iconContainer) {
                iconContainer.innerHTML = ''; 
                iconContainer.appendChild(iEl);
                lucide.createIcons({ nodes: [iEl] });
            }
            if (profileIconEl) {
                const iEl2 = document.createElement('i');
                iEl2.setAttribute('data-lucide', iconData[0]);
                iEl2.className = profileIconEl.className; // Keep size
                profileIconEl.replaceWith(iEl2);
                profileModalIcon = iEl2; // Update reference
                lucide.createIcons({ nodes: [iEl2] });
            }
        }
        
        // --- Game Initialization ---
        function initializeGame(room = null) {
            gameEndedNotified = false;
            lastKnownStateFingerprint = null;
            isChatPanelOpen = false;
            resetBoardVisuals(); 
    
            if (room) { // Multiplayer
                applyTheme('multiplayer');
                isMultiplayer = true;
                boardSize = room.boardSize;
                
                mpPlayerXData = { id: room.playerXId, name: room.playerXName, icon: room.playerXIcon };
                mpPlayerOData = { id: room.playerOId, name: room.playerOName, icon: room.playerOIcon };
                opponentName = (myPlayerMark === 'X') ? mpPlayerOData.name : mpPlayerXData.name;
                
                playerXIcon = room.playerXIcon;
                playerOIcon = room.playerOIcon;
                boardState = room.boardState;
                currentPlayer = room.currentPlayer;
                isGameActive = (room.status === 'playing');
                playerXScoreEl.textContent = playerXScore;
                playerOScoreEl.textContent = playerOScore;
                
                const opponentId = (myPlayerMark === 'X') ? mpPlayerOData.id : mpPlayerXData.id;
                listenToOpponentPresence(opponentId, room);
                
                aiTipBtn.classList.add('hidden');
                blockerPowerupBtn.classList.add('hidden');
                chatToggleButton.classList.remove('hidden');
                aiTipBtnMobile.classList.add('hidden');
                blockerPowerupBtnMobile.classList.add('hidden');
                
                gameBoardContainer.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
                drawBoard(room);
                updateTurnStatus();
                
                if(window.innerWidth >= 1024) multiplayerChatPanel.classList.remove('hidden');
                return;
            }
            
            // Single Player (PVP or PVA)
            isMultiplayer = false;
            const isPVA = gameSettings.gameMode === 'pva';
            applyTheme(isPVA ? 'pva' : 'pvp');
            chatToggleButton.classList.add('hidden');
            multiplayerChatPanel.classList.add('hidden');
            
            gameStartTime = new Date();
            moveCount = 0;
            isGameActive = true;
            boardSize = gameSettings.boardSize; 
            boardState = Array(boardSize * boardSize).fill(null);
            moveHistory = [];
            blockerCountX = 1;
            blockerCountO = 1;
            isBlockerActive = false;
            currentPlayer = humanPlayer;
            
            playerXNameEl.textContent = player1Name.toUpperCase();
            playerONameEl.textContent = isPVA ? (AI_PERSONALITIES[gameSettings.aiDifficulty] || AI_PERSONALITIES.medium).name : 'PLAYER 2';
            
            updatePlayerIconDisplay('X', playerXIcon);
            updatePlayerIconDisplay('O', 'sparkles');
            
            gameBoardContainer.innerHTML = '';
            gameBoardContainer.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
            for (let i = 0; i < boardSize * boardSize; i++) {
                const cell = document.createElement('div');
                cell.className = 'game-cell rounded-lg sm:rounded-xl aspect-square flex items-center justify-center cursor-pointer';
                cell.dataset.index = i;
                cell.dataset.mark = '';
                gameBoardContainer.appendChild(cell);
            }
            
            const showBlocker = (gameSettings.gameVariant === 'blocker');
            aiTipBtn.classList.toggle('hidden', !isPVA);
            aiTipBtnMobile.classList.toggle('hidden', !isPVA);
            blockerPowerupBtn.classList.toggle('hidden', !showBlocker || !isPVA);
            blockerPowerupBtnMobile.classList.toggle('hidden', !showBlocker || !isPVA);
            
            if (isPVA) {
                const canAffordTip = currentHearts >= AI_TIP_COST;
                aiTipBtn.disabled = !canAffordTip;
                aiTipBtnMobile.disabled = !canAffordTip;
            }
            updateTurnStatus();
            confettiContainer.innerHTML = '';
        }
        
        function resetBoardVisuals() {
             gameBoardContainer.querySelectorAll('.game-cell').forEach(cell => {
                 cell.classList.remove('winning-cell', 'ai-tip-highlight', 'cell-bounce-in', 'blocked', 'player-x', 'player-o');
                 cell.innerHTML = '';
                 cell.dataset.mark = '';
             });
        }
        
        function drawBoard(roomData) {
            const existingCells = gameBoardContainer.querySelectorAll('.game-cell');
            const requiredCells = roomData.boardSize * roomData.boardSize;
            if (existingCells.length !== requiredCells) {
                gameBoardContainer.innerHTML = '';
                gameBoardContainer.style.gridTemplateColumns = `repeat(${roomData.boardSize}, 1fr)`;
                for (let i = 0; i < requiredCells; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'game-cell rounded-lg sm:rounded-xl aspect-square flex items-center justify-center cursor-pointer';
                    cell.dataset.index = i;
                    cell.dataset.mark = '';
                    gameBoardContainer.appendChild(cell);
                }
            }
            
            playerXNameEl.textContent = roomData.playerXName.toUpperCase(); 
            updatePlayerIconDisplay('X', roomData.playerXIcon); 
            
            playerONameEl.textContent = roomData.playerOName.toUpperCase() || 'OPPONENT'; 
            updatePlayerIconDisplay('O', roomData.playerOIcon); 
            
            if (isMultiplayer && !gameStartedNotified) {
                showNotification(`You are Player ${myPlayerMark}. Opponent is Player ${opponentMark}.`, 'info');
                gameStartedNotified = true; 
            }
            
            const iconsToCreate = [];
            gameBoardContainer.querySelectorAll('.game-cell').forEach((cell, index) => {
                const mark = roomData.boardState[index];
                const currentMark = cell.dataset.mark || null; 
                
                if (currentMark === mark) { // Cell is already correct
                     cell.classList.toggle('winning-cell', roomData.winningLine && roomData.winningLine.includes(index));
                     return;
                }
                
                cell.dataset.mark = mark || ''; 
                cell.innerHTML = ''; 
                cell.classList.remove('player-x', 'player-o', 'winning-cell', 'cell-bounce-in', 'blocked');
                
                if (mark) {
                     cell.classList.add(`player-${mark.toLowerCase()}`);
                     const iconId = (mark === 'X') ? (roomData.playerXIcon || 'x') : (roomData.playerOIcon || 'circle');
                     const iconName = ICON_COSTS[iconId] ? ICON_COSTS[iconId][0] : iconId;
                     const iconEl = document.createElement('i');
                     iconEl.setAttribute('data-lucide', iconName);
                     iconEl.className = 'w-[65%] h-[65%]';
                     cell.appendChild(iconEl);
                     iconsToCreate.push(iconEl);
                     cell.classList.add('cell-bounce-in'); 
                     if (roomData.winningLine && roomData.winningLine.includes(index)) {
                          cell.classList.add('winning-cell');
                     }
                }
            });
            
            if (iconsToCreate.length > 0) lucide.createIcons({ nodes: iconsToCreate });
            
             aiTipBtn.classList.add('hidden');
             blockerPowerupBtn.classList.add('hidden');
        }

        // --- Game Logic ---
        function handleCellClick(event) {
            if (!isGameActive) return;
            
            const clickedCell = event.target.closest('.game-cell');
            if (!clickedCell) return;
            const clickedIndex = parseInt(clickedCell.dataset.index);
            if (isNaN(clickedIndex) || clickedCell.dataset.mark || clickedCell.classList.contains('processing')) {
                playSound(invalidSound, 'C3', '0.1');
                if(clickedCell) clickedCell.classList.add('shake');
                setTimeout(() => clickedCell.classList.remove('shake'), 300);
                return;
            }
            
            if (isMultiplayer) {
                 if (currentPlayer !== myPlayerMark) {
                      showNotification("Wait for your opponent's turn.", 'info');
                      return;
                 }
                 isGameActive = false; // Lock board
                 placeMark(clickedCell, clickedIndex); 
                 syncMoveToFirestore(clickedIndex, clickedCell);
                 return;
            }
            
            if (isBlockerActive) {
                placeBlock(clickedCell, clickedIndex, currentPlayer);
                isBlockerActive = false;
                gameBoardContainer.classList.remove('blocker-active');
                blockerPowerupBtn.classList.remove('active');
                blockerPowerupBtnMobile.classList.remove('active');
                if (checkEndCondition()) return;
                switchPlayer();
                if (gameSettings.gameMode === 'pva' && currentPlayer === aiPlayer) aiMove();
                return;
            }
            
            if (gameSettings.gameMode === 'pva' && currentPlayer !== humanPlayer) return;
            
            if (window.navigator.vibrate) window.navigator.vibrate(50);
            
            placeMark(clickedCell, clickedIndex);
            if (checkEndCondition()) return;
            switchPlayer();
            
            if (gameSettings.gameMode === 'pva' && currentPlayer === aiPlayer && isGameActive) {
                aiMove();
            }
        }
        
        async function syncMoveToFirestore(index, cell) {
             if (isMoveOnCooldown) return; 
             isMoveOnCooldown = true;
             try {
                 await runTransaction(db, async (transaction) => {
                      const roomDoc = await transaction.get(getRoomDocRef(currentRoomId));
                      if (!roomDoc.exists()) throw new Error("Room doesn't exist.");
                      
                      const roomData = roomDoc.data();
                      if (roomData.status !== 'playing') throw new Error("Game is not active.");
                      if (roomData.currentPlayer !== myPlayerMark) throw new Error("Not your turn.");
                      if (roomData.boardState[index] !== null) throw new Error("Cell already taken.");
                      
                      const newBoardState = [...roomData.boardState];
                      newBoardState[index] = myPlayerMark;
                      const newCurrentPlayer = (myPlayerMark === 'X') ? 'O' : 'X';
                      
                      transaction.update(getRoomDocRef(currentRoomId), {
                          boardState: newBoardState,
                          currentPlayer: newCurrentPlayer,
                          lastUpdated: Date.now()
                      });
                 });
             } catch (e) {
                  console.error("Move sync transaction failed:", e.message);
                  showNotification(e.message || "Invalid move. Board desynced.", 'error');
             } finally {
                  setTimeout(() => { isMoveOnCooldown = false; }, MOVE_COOLDOWN_MS);
             }
        }
        
        function placeMark(cell, index) {
            const mark = currentPlayer;
            boardState[index] = mark;
            cell.dataset.mark = mark;
            cell.classList.add(`player-${mark.toLowerCase()}`);
            
            let iconId;
            if (isMultiplayer) {
                iconId = (mark === 'X') ? mpPlayerXData.icon : mpPlayerOData.icon;
            } else {
                iconId = (mark === 'X') ? playerXIcon : (gameSettings.gameMode === 'pva' ? 'sparkles' : 'circle');
            }
            
            const iconName = ICON_COSTS[iconId] ? ICON_COSTS[iconId][0] : iconId;
            const iconEl = document.createElement('i');
            iconEl.setAttribute('data-lucide', iconName);
            iconEl.className = 'w-[65%] h-[65%]'; // Use Tailwind percentage for responsive icon
            cell.innerHTML = '';
            cell.appendChild(iconEl);
            lucide.createIcons({ nodes: [iconEl] });
            cell.classList.add('cell-bounce-in');
            
            moveHistory.push({ index, player: mark, type: 'mark' });
            moveCount++;
            playSound(clickSound, (mark === 'X' ? 'C5' : 'E5'), '0.05');
        }
        
        function switchPlayer() {
            currentPlayer = (currentPlayer === 'X') ? 'O' : 'X';
            updateTurnStatus();
        }
        
        function updateTurnStatus() {
            if (!isGameActive && !isMultiplayer) return;
            
            let isMyTurn, statusText;
            
            if (isMultiplayer) {
                isGameActive = (currentPlayer === myPlayerMark); // Board locked when not my turn
                
                isMyTurn = (currentPlayer === myPlayerMark);
                statusText = isMyTurn ? "YOUR TURN" : (opponentName.toUpperCase() + "'S TURN");
            } else {
                isMyTurn = (currentPlayer === humanPlayer);
                if (gameSettings.gameMode === 'pva') {
                    const personality = AI_PERSONALITIES[gameSettings.aiDifficulty] || AI_PERSONALITIES.medium;
                    statusText = isMyTurn ? "YOUR TURN" : personality.thinking;
                } else {
                    statusText = `PLAYER ${currentPlayer}'S TURN`;
                }
            }
            
            gameStatusDisplay.textContent = statusText;
            playerXProfile.classList.toggle('active-turn', currentPlayer === 'X');
            playerOProfile.classList.toggle('active-turn', currentPlayer === 'O');
            
            const isPVA = gameSettings.gameMode === 'pva';
            if (isPVA) {
                const canAffordTip = currentHearts >= AI_TIP_COST;
                aiTipBtn.disabled = !canAffordTip || !isMyTurn;
                aiTipBtnMobile.disabled = !canAffordTip || !isMyTurn;
                updateBlockerButton();
            }
        }

        // --- Win/Draw Check ---
        function checkWin(board, player) {
            const size = boardSize;
            for (let r = 0; r < size; r++) { // Check rows
                let line = [];
                let won = true;
                for (let c = 0; c < size; c++) {
                    const index = r * size + c;
                    line.push(index);
                    if (board[index] !== player) { won = false; break; }
                }
                if (won) return { won: true, line };
            }
            for (let c = 0; c < size; c++) { // Check columns
                let line = [];
                let won = true;
                for (let r = 0; r < size; r++) {
                    const index = r * size + c;
                    line.push(index);
                    if (board[index] !== player) { won = false; break; }
                }
                if (won) return { won: true, line };
            }
            let diag1 = [], wonDiag1 = true; // Check diag 1
            for (let i = 0; i < size; i++) {
                const index = i * size + i;
                diag1.push(index);
                if (board[index] !== player) wonDiag1 = false;
            }
            if (wonDiag1) return { won: true, line: diag1 };
            
            let diag2 = [], wonDiag2 = true; // Check diag 2
            for (let i = 0; i < size; i++) {
                const index = i * size + (size - 1 - i);
                diag2.push(index);
                if (board[index] !== player) wonDiag2 = false;
            }
            if (wonDiag2) return { won: true, line: diag2 };
            
            return { won: false, line: [] };
        }
        
        async function checkAndEndGameIfNeeded(room) {
            if (!room || room.status !== 'playing' || myPlayerMark !== 'X') return;

            const winInfoX = checkWin(room.boardState, 'X');
            const winInfoO = checkWin(room.boardState, 'O');
            const isDraw = checkDraw(room.boardState);

            let newStatus = 'playing', winner = null, winningLine = [];

            if (winInfoX.won) { newStatus = 'finished'; winner = 'X'; winningLine = winInfoX.line; }
            else if (winInfoO.won) { newStatus = 'finished'; winner = 'O'; winningLine = winInfoO.line; }
            else if (isDraw) { newStatus = 'finished'; winner = 'Draw'; }

            if (newStatus === 'finished') {
                try {
                    await updateDoc(getRoomDocRef(currentRoomId), {
                        status: newStatus,
                        winner: winner,
                        winningLine: winningLine,
                        lastUpdated: Date.now()
                    });
                } catch (e) { console.error("Error updating game end status:", e); }
            }
        }

        function checkDraw(board) {
            return getAvailableMoves(board).length === 0 &&
                   !checkWin(board, 'X').won &&
                   !checkWin(board, 'O').won;
        }
        
        function checkEndCondition() {
            const winInfo = checkWin(boardState, currentPlayer);
            const isDraw = checkDraw(boardState);
            if (winInfo.won) {
                endGame(false, winInfo.line, currentPlayer);
                return true;
            } else if (isDraw) {
                endGame(true, [], 'Draw');
                return true;
            }
            return false;
        }
        
        function highlightWinningCells(line) {
            line.forEach(index => {
                const cell = gameBoardContainer.querySelector(`[data-index='${index}']`);
                if (cell) cell.classList.add('winning-cell');
            });
        }
        
        async function endGame(isDraw, winningLine = [], winner = 'Draw', room = null) {
            if (gameEndedNotified && !isMultiplayer) return;
            gameEndedNotified = true;
            isGameActive = false;
            
            let heartsChange = 0, heartsChangeSymbol = '0', heartsChangeClass = 'neutral', winStreakText = '';
            
            if (isDraw) {
                playSound(drawSound, 'C4', '0.5');
                winStreak = 0;
            } else { // Someone won
                playSound(winSound, ['C5', 'E5', 'G5'], '0.4');
                let playerWon = false;
                
                if (!isMultiplayer) {
                    if (winner === humanPlayer) { playerXScore++; playerWon = true; }
                    else if (winner === aiPlayer) { playerOScore++; playerWon = false; }
                    else if (winner === 'X') playerXScore++;
                    else if (winner === 'O') playerOScore++;
                } else {
                    if (winner === myPlayerMark) { playerWon = true; }
                    if (winner === 'X') playerXScore++;
                    else if (winner === 'O') playerOScore++;
                }

                if (playerWon) {
                    winStreak++;
                    heartsChange = isMultiplayer ? FTF_WIN_REWARD : (gameSettings.gameMode === 'pva' ? AI_WIN_REWARD : 0);
                } else {
                    winStreak = 0;
                    heartsChange = 0;
                }
            }
            
            // Apply streak bonus
            if (winStreak > 0 && winStreak % WIN_STREAK_BONUS_COUNT === 0) {
                heartsChange += WIN_STREAK_BONUS_AMOUNT;
                showNotification(`+${WIN_STREAK_BONUS_AMOUNT} Hearts for ${winStreak}-Win Streak!`, 'success');
            }

            // Set text for modal
            if (heartsChange > 0) { heartsChangeSymbol = `+${heartsChange}`; heartsChangeClass = 'text-green-400'; }
            else if (heartsChange < 0) { heartsChangeSymbol = `${heartsChange}`; heartsChangeClass = 'text-red-400'; }
            else { heartsChangeSymbol = `0`; heartsChangeClass = 'text-gray-400'; }
            
            winStreakText = `${winStreak} Wins`;
            
            // Save data
            currentHearts = Math.max(0, currentHearts + heartsChange);
            playerXScoreEl.textContent = playerXScore;
            playerOScoreEl.textContent = playerOScore;
            await saveAllData();
            updateHeartsUI();
            
            highlightWinningCells(winningLine);
            await new Promise(res => setTimeout(res, 1000));

            if (!isMultiplayer) {
                if (winner === 'X' || (winner === 'O' && gameSettings.gameMode === 'pva')) runConfetti();
                
                gameOverMessage.textContent = isDraw ? "It's a Draw!" : (winner === 'X' ? `${player1Name.toUpperCase()} WINS!` : `${playerONameEl.textContent.toUpperCase()} WINS!`);
                gameOverMessage.style.color = isDraw ? 'var(--text-light)' : (winner === 'X' ? 'var(--player-x-color)' : 'var(--player-o-color)');
                statTime.textContent = `${((new Date() - gameStartTime) / 1000).toFixed(1)}s`;
                statMoves.textContent = moveCount;
                
                statHearts.textContent = `${heartsChangeSymbol} Hearts`;
                statHearts.className = `font-bold ${heartsChangeClass}`;
                statWinStreak.textContent = winStreakText;
                statWinStreak.className = `font-bold ${winStreak > 0 ? 'text-orange-400' : 'text-white'}`;
                
                playAgainBtn.disabled = false;
                showScreen(gameOverModal);
            } else {
                showMultiplayerResult(room, heartsChangeSymbol, heartsChangeClass, winStreakText, winStreak > 0, room.status === 'abandoned');
            }
        }
        
        function showMultiplayerResult(room, heartsSymbol, heartsClass, streakText, streakPositive, isAbandoned = false) {
            mpResultTitle.textContent = room.winner === 'Draw' ? "IT'S A DRAW!" : (room.winner === myPlayerMark ? " YOU WON! " : "YOU LOST");
            if (isAbandoned && room.winner === myPlayerMark) mpResultTitle.textContent = " OPPONENT LEFT! ";
            
            resultNameX.textContent = mpPlayerXData.name.toUpperCase();
            resultScoreX.textContent = playerXScore;
            updateIconInElement(resultIconX, mpPlayerXData.icon || 'x');
            
            resultNameO.textContent = mpPlayerOData.name.toUpperCase();
            resultScoreO.textContent = playerOScore;
            updateIconInElement(resultIconO, mpPlayerOData.icon || 'circle');

            mpStatHearts.textContent = `${heartsSymbol} Hearts`;
            mpStatHearts.className = `font-bold ${heartsClass}`;
            mpStatWinStreak.textContent = streakText;
            mpStatWinStreak.className = `font-bold ${streakPositive ? 'text-orange-400' : 'text-white'}`;
            
            if (isAbandoned) {
                 rematchBtn.disabled = true;
                 rematchBtn.textContent = 'GAME OVER';
                 rematchStatusEl.textContent = 'Opponent left the match.';
            } else {
                 playerXRematch = false;
                 playerORematch = false;
                 rematchBtn.disabled = false;
                 rematchBtn.textContent = 'REQUEST REMATCH';
                 rematchStatusEl.textContent = 'Challenge your opponent to a rematch!';
            }
            
            showScreen(multiplayerResultModal);
        }

        function updateIconInElement(element, iconId) {
            const iconName = ICON_COSTS[iconId] ? ICON_COSTS[iconId][0] : iconId;
            const iconEl = document.createElement('i');
            iconEl.setAttribute('data-lucide', iconName);
            iconEl.className = 'w-8 h-8'; // Match size in modal
            element.innerHTML = '';
            element.appendChild(iconEl);
            lucide.createIcons({ nodes: [iconEl] });
        }
        
        // --- AI Logic ---
        function aiMove() {
             if (!isGameActive) return;
             gameBoardContainer.classList.add('opacity-70'); // Visual cue for thinking
             let finalMove = -1, useBlocker = false, blockIndex = -1;
             const difficulty = gameSettings.aiDifficulty || 'medium';
             
             // ... [AI logic for blocker and move calculation, same as before] ...
             if (gameSettings.gameVariant === 'blocker' && blockerCountO > 0 && difficulty !== 'easy') {
                 const aiWinMove = findWinningMove(boardState, aiPlayer);
                 if (aiWinMove == -1) {
                     const humanThreats = findAllWinningMoves(boardState, humanPlayer);
                     if (humanThreats.length > 1) { useBlocker = true; blockIndex = humanThreats[0]; }
                 }
             }

             if (!useBlocker) {
                 if (difficulty === 'easy') finalMove = findRandomMove(boardState);
                 else if (difficulty === 'medium') finalMove = findMediumMove(boardState, false);
                 else if (difficulty === 'hard') finalMove = findBestMove(boardState, false);
                 else if (difficulty === 'grandmaster') {
                     // Grandmaster logic (simplified, use findBestMove)
                     finalMove = findBestMove(boardState, false);
                 }
             }
             if (finalMove === -1 && !useBlocker) finalMove = findRandomMove(boardState);
             
             const delay = Math.random() * 400 + 400;
             setTimeout(() => {
                 if (!isGameActive) { gameBoardContainer.classList.remove('opacity-70'); return; }
                 
                 if (useBlocker) { 
                     const aiCell = gameBoardContainer.querySelector(`[data-index='${blockIndex}']`);
                     if (aiCell && boardState[blockIndex] === null) placeBlock(aiCell, blockIndex, aiPlayer);
                 } else if (finalMove !== -1) { 
                     const aiCell = gameBoardContainer.querySelector(`[data-index='${finalMove}']`);
                     if (aiCell && boardState[finalMove] === null) placeMark(aiCell, finalMove);
                     else { // Fallback if move is invalid
                         const randomFallback = findRandomMove(boardState);
                         if(randomFallback !== -1) placeMark(gameBoardContainer.querySelector(`[data-index='${randomFallback}']`), randomFallback);
                     }
                 }
                 
                 gameBoardContainer.classList.remove('opacity-70');
                 if (!checkEndCondition()) switchPlayer();
             }, delay);
        }
        
        function findRandomMove(board) {
            const available = getAvailableMoves(board);
            if (available.length === 0) return -1;
            return available[Math.floor(Math.random() * available.length)];
        }
        
        function findMediumMove(board, forHuman) {
            const player = forHuman ? humanPlayer : aiPlayer;
            const opponent = forHuman ? aiPlayer : humanPlayer;
            let winMove = findWinningMove(board, player);
            if(winMove !== -1) return winMove;
            let blockMove = findWinningMove(board, opponent);
            if(blockMove !== -1) return blockMove;
            return findRandomMove(board);
        }
        
        function findBestMove(board, forHuman) {
            let bestScore = -Infinity;
            let move = -1;
            const player = forHuman ? humanPlayer : aiPlayer;
            const availableMoves = getAvailableMoves(board);
            if (availableMoves.length === 0) return -1;
            
            for (const index of availableMoves) {
                board[index] = player;
                let score = minimax(board, 0, false, -Infinity, Infinity, forHuman);
                board[index] = null;
                if (score > bestScore) {
                    bestScore = score;
                    move = index;
                }
            }
            return move === -1 ? availableMoves[0] : move;
        }
        
        function minimax(board, depth, isMaximizing, alpha, beta, forHuman) {
            const player = forHuman ? humanPlayer : aiPlayer;
            const opponent = forHuman ? aiPlayer : humanPlayer;
            
             if (checkWin(board, player).won) return 100 - depth;
             if (checkWin(board, opponent).won) return depth - 100;
             if (checkDraw(board)) return 0;
            
            const maxDepth = MINIMAX_DEPTHS[boardSize] || 3;
            if (depth >= maxDepth) return 0;
            
            const availableMoves = getAvailableMoves(board);
            
            if (isMaximizing) {
                let bestScore = -Infinity;
                for (const index of availableMoves) {
                    board[index] = player;
                    bestScore = Math.max(bestScore, minimax(board, depth + 1, false, alpha, beta, forHuman));
                    board[index] = null;
                    alpha = Math.max(alpha, bestScore);
                    if (beta <= alpha) break;
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (const index of availableMoves) {
                    board[index] = opponent;
                    bestScore = Math.min(bestScore, minimax(board, depth + 1, true, alpha, beta, forHuman));
                    board[index] = null;
                    beta = Math.min(beta, bestScore);
                    if (beta <= alpha) break;
                }
                return bestScore;
            }
        }
        
        function getAvailableMoves(board) {
             if (!Array.isArray(board)) return [];
             return board.map((cell, index) => cell === null ? index : -1).filter(index => index !== -1);
        }
        
        function findAllWinningMoves(board, player) {
            const threats = [];
            const available = getAvailableMoves(board);
            for (let index of available) {
                board[index] = player;
                if (checkWin(board, player).won) threats.push(index);
                board[index] = null;
            }
            return threats;
        }

        function findWinningMove(board, player) {
            const available = getAvailableMoves(board);
            for (let index of available) {
                board[index] = player;
                if (checkWin(board, player).won) { board[index] = null; return index; }
                board[index] = null;
            }
            return -1;
        }
        
        // --- Variant Logic ---
        function placeBlock(cell, index, player) {
            boardState[index] = 'B';
            const iconEl = document.createElement('i');
            iconEl.setAttribute('data-lucide', 'shield-ban');
            iconEl.className = 'w-[65%] h-[65%]';
            cell.innerHTML = '';
            cell.appendChild(iconEl);
            lucide.createIcons({ nodes: [iconEl] });
            cell.classList.add('blocked', 'cell-bounce-in');
            moveHistory.push({ index, player: player, type: 'block' });
            if (player === 'X') blockerCountX--; else blockerCountO--;
            playSound(clickSound, 'G4', '0.05');
        }
        
        function updateBlockerButton() {
            if (gameSettings.gameVariant !== 'blocker' || !isGameActive) return;
            const isPVA = gameSettings.gameMode === 'pva';
            const disableButton = (currentPlayer === 'X' ? blockerCountX : blockerCountO) <= 0 || isBlockerActive || !isPVA;
            blockerPowerupBtn.disabled = disableButton;
            blockerPowerupBtnMobile.disabled = disableButton;
            blockerPowerupBtn.classList.toggle('active', isBlockerActive);
            blockerPowerupBtnMobile.classList.toggle('active', isBlockerActive);
        }
        
        // --- Misc ---
        function runConfetti() {
             confettiContainer.innerHTML = '';
             for (let i = 0; i < 100; i++) {
                 const confetti = document.createElement('div');
                 confetti.className = 'absolute w-2 h-2 rounded-full opacity-0';
                 confetti.style.left = `${Math.random() * 100}%`;
                 confetti.style.animation = `confetti-fall ${Math.random() * 2 + 3}s ${Math.random() * 2}s linear infinite`;
                 confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
                 confettiContainer.appendChild(confetti);
             }
        }
        
        // --- Multiplayer Functions ---
        function showFtfView(view) {
            [ftfSelectionView, ftfCreateView, ftfJoinView].forEach(v => v.classList.add('hidden'));
            ftfModal.querySelector('#ftf-title').textContent = 'PLAY WITH FRIENDS';
            if (view === 'selection') ftfSelectionView.classList.remove('hidden');
            else if (view === 'create') {
                ftfCreateView.classList.remove('hidden');
                ftfModal.querySelector('#ftf-title').textContent = 'CREATE ROOM';
            } else if (view === 'join') {
                ftfJoinView.classList.remove('hidden');
                ftfModal.querySelector('#ftf-title').textContent = 'JOIN ROOM';
                joinRoomInput.value = '';
                joinRoomSubmitBtn.disabled = true;
            }
        }
        
        async function createRoom() {
            if (!userProfile.uid) { 
                showNotification('Authentication error.', 'error'); 
                isCreatingRoom = false; return; 
            }
            currentRoomId = generateRoomId();
            roomCodeDisplay.textContent = currentRoomId;
            const roomDocRef = getRoomDocRef(currentRoomId);
            try {
                await setDoc(roomDocRef, {
                    status: 'waiting',
                    boardSize: 3, 
                    playerXId: userProfile.uid,
                    playerXName: userProfile.displayName,
                    playerXIcon: playerXIcon,
                    playerOId: '', playerOName: '', playerOIcon: null,
                    boardState: Array(9).fill(null),
                    currentPlayer: 'X',
                    rematchX: false, rematchO: false,
                    lastUpdated: Date.now()
                });
                showNotification('Room created. Waiting for opponent.', 'info');
                myPlayerMark = 'X';
                listenToRoomState(currentRoomId);
                currentHearts = Math.max(0, currentHearts + FTF_CREATE_COST);
                updateHeartsUI();
                saveAllData();
            } catch (e) {
                console.error("Error creating room:", e);
                showNotification('Failed to create room.', 'error');
                currentRoomId = null;
                showFtfView('selection');
                isCreatingRoom = false;
            }
        }
        
        async function joinRoom(roomId) {
            if (!userProfile.uid) { showNotification('Authentication error.', 'error'); return; }
            if (currentHearts < Math.abs(FTF_JOIN_COST)) {
                showNotification(`Not enough hearts! Need ${Math.abs(FTF_JOIN_COST)}.`, 'error');
                return;
            }
            
            currentRoomId = roomId;
            joinRoomSubmitBtn.disabled = true;
            const roomDocRef = getRoomDocRef(roomId);
            try {
                const docSnap = await getDoc(roomDocRef);
                if (!docSnap.exists()) throw new Error('Room not found.');
                
                const roomData = docSnap.data();
                if (roomData.status !== 'waiting') throw new Error('Room is full or game started.');
                if (roomData.playerXId === userProfile.uid) {
                     myPlayerMark = 'X';
                     listenToRoomState(currentRoomId);
                     return;
                }
                
                let playerOIconCurrent = playerXIcon; 
                if(playerXIcon === roomData.playerXIcon) {
                     playerOIconCurrent = 'circle'; // Avoid icon clash
                     showNotification('Icon clash! You were assigned the Circle icon.', 'info');
                }
                
                await updateDoc(roomDocRef, {
                    status: 'playing',
                    playerOId: userProfile.uid,
                    playerOName: userProfile.displayName,
                    playerOIcon: playerOIconCurrent
                });
                
                currentHearts = Math.max(0, currentHearts + FTF_JOIN_COST);
                updateHeartsUI();
                saveAllData();
                
                myPlayerMark = 'O';
                listenToRoomState(currentRoomId);
            } catch (e) {
                console.error("Error joining room:", e);
                showNotification(e.message || 'Failed to join room.', 'error');
                currentRoomId = null;
                joinRoomSubmitBtn.disabled = false;
            }
        }
        
         async function cancelRoom() {
             if (unsubscribeRoomListener) unsubscribeRoomListener();
             if (unsubscribeChatListener) unsubscribeChatListener();
             if (unsubscribeOpponentPresence) unsubscribeOpponentPresence();
             
             if (chatMessagesContainer) chatMessagesContainer.innerHTML = '';
             isChatPanelOpen = false;
             if (multiplayerChatPanel) multiplayerChatPanel.classList.add('hidden');
             
             if (currentRoomId) {
                  try {
                      if (rtdb && userProfile.uid) {
                          const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                          const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                          const userStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${userProfile.uid}`);
                          await set(userStatusRef, false);
                          setupPresence(userProfile.uid); 
                      }
                      await deleteChatHistory(currentRoomId);
                      if (myPlayerMark === 'X') {
                          await updateDoc(getRoomDocRef(currentRoomId), { status: 'abandoned', winner: 'O' });
                      } else if (myPlayerMark === 'O') { 
                           await updateDoc(getRoomDocRef(currentRoomId), { status: 'abandoned', winner: 'X' });
                      }
                  } catch (e) { console.error("Error managing room/chat deletion:", e); }
             }
             currentRoomId = null;
             myPlayerMark = null;
             gameStartedNotified = false; 
        }
        
        async function handleOpponentAbandonment(room) {
            if (gameEndedNotified) return;
            gameEndedNotified = true;
            isGameActive = false;
        
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            if (unsubscribeChatListener) unsubscribeChatListener();
            
            showNotification('Opponent disconnected. Please wait...', 'info');
            
            setTimeout(async () => {
                const winner = myPlayerMark;
                const leaverMark = (myPlayerMark === 'X') ? 'O' : 'X';
                
                try {
                    await updateDoc(getRoomDocRef(currentRoomId), { status: 'abandoned', winner: winner });
                } catch (e) { console.error("Failed to update room to 'abandoned'", e); }
        
                let heartsChange = FTF_WIN_REWARD;
                winStreak++;
                
                if (winStreak > 0 && winStreak % WIN_STREAK_BONUS_COUNT === 0) {
                    heartsChange += WIN_STREAK_BONUS_AMOUNT;
                    showNotification(`+${WIN_STREAK_BONUS_AMOUNT} Hearts for ${winStreak}-Win Streak!`, 'success');
                }
                
                currentHearts = Math.max(0, currentHearts + heartsChange);
                if (myPlayerMark === 'X') playerXScore++;
                else playerOScore++;
                
                await saveAllData();
                updateHeartsUI();
                
                showMultiplayerResult(room, `+${heartsChange}`, 'text-green-400', `${winStreak} Wins`, true, true);
        
            }, 1000); 
        }
        
        function listenToRoomState(roomId) {
            if (unsubscribeRoomListener) unsubscribeRoomListener();
            listenToChatState(roomId);
            
            unsubscribeRoomListener = onSnapshot(getRoomDocRef(roomId), (doc) => {
                const room = doc.data();
                if (!room) {
                    showNotification('Room was deleted by the host.', 'error');
                    goBackFromMultiplayer();
                    return;
                }
                
                const currentStatus = room.status;

                if (currentStatus === 'waiting') {
                    if (myPlayerMark === 'X') {
                        if (!gameScreen.classList.contains('hidden')) {
                            showNotification('Player O left. Returning to Nexus.', 'info');
                            goBackFromMultiplayer();
                        } else if (!ftfModal.classList.contains('hidden')) {
                            roomCodeDisplay.textContent = currentRoomId;
                            waitingStatus.classList.remove('hidden');
                        }
                    }
                    else if (myPlayerMark === 'O') {
                         showNotification('Room reset by host.', 'error');
                         goBackFromMultiplayer();
                    }
                    return; 
                }

                if (currentStatus === 'playing' && myPlayerMark === 'X') {
                    checkAndEndGameIfNeeded(room);
                }

                if (currentStatus === 'playing' || currentStatus === 'finished' || currentStatus === 'abandoned') {
                    const isRematchStarting = currentStatus === 'playing' && !multiplayerResultModal.classList.contains('hidden');
                    const isFirstGameStarting = currentStatus === 'playing' && !ftfModal.classList.contains('hidden');

                    if (isFirstGameStarting) {
                        hideScreen(ftfModal, () => { showScreen(gameScreen); initializeGame(room); });
                    } else if (isRematchStarting) {
                        hideScreen(multiplayerResultModal, () => { initializeGame(room); showScreen(gameScreen); });
                    } else {
                        boardState = room.boardState;
                        currentPlayer = room.currentPlayer;
                        isGameActive = (currentStatus === 'playing');
                        if (!isFirstGameStarting && !isRematchStarting) {
                             drawBoard(room);
                             updateTurnStatus();
                        }
                    }

                    playerXRematch = room.rematchX;
                    playerORematch = room.rematchO;

                    if (currentStatus === 'finished' || currentStatus === 'abandoned') {
                        if (!gameEndedNotified) {
                            endGame(room.winner === 'Draw', room.winningLine || [], room.winner, room);
                        }
                    }

                    if (playerXRematch && playerORematch && currentStatus !== 'playing' && rematchCountdownInterval === null) {
                        if (!multiplayerResultModal.classList.contains('hidden')) startRematchCountdown();
                    } else {
                         if (!multiplayerResultModal.classList.contains('hidden')) updateRematchStatusUI();
                    }
                }
            }, (error) => {
                 console.error("Firestore room listener error:", error);
                 showNotification('Connection lost or room error.', 'error');
                 goBackFromMultiplayer();
            });
        }
        
        function listenToOpponentPresence(opponentId, room) {
            if (unsubscribeOpponentPresence) unsubscribeOpponentPresence();
            if (!rtdb || !opponentId) return;
            
            const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
            const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
            const opponentStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${opponentId}`);
            
            unsubscribeOpponentPresence = onValue(opponentStatusRef, (snapshot) => {
                const isOnline = snapshot.val();
                
                if (isOnline === false) { // Opponent disconnected
                    if (gameEndedNotified || !isMultiplayer) return; 
                    
                    console.warn(`Opponent (ID: ${opponentId}) disconnected!`);
                    
                    setTimeout(async () => {
                        if (gameEndedNotified || !currentRoomId) return; // Check again after delay
                        
                        try {
                             const roomDocRef = getRoomDocRef(currentRoomId);
                             const roomSnap = await getDoc(roomDocRef);
                             if (roomSnap.exists() && roomSnap.data().status === 'waiting') {
                                 return; // Opponent left from waiting, which is fine
                             }
                             // If still in game, handle abandonment
                             handleOpponentAbandonment(roomSnap.data());

                        } catch (e) { console.error("Error checking room status during grace period:", e); }
 
                    }, 20000); // 20-second grace period for mobile disconnects
                }
            }, (error) => console.error("RTDB Presence listener error:", error));
        }

        function listenToChatState(roomId) {
             if (unsubscribeChatListener) unsubscribeChatListener();
             chatMessagesContainer.innerHTML = '';
             chatSendBtn.disabled = true;
             chatInputField.disabled = true;
             
             const chatRef = getChatRoomRef(roomId); 
             
             unsubscribeChatListener = onValue(chatRef, (snapshot) => {
                  chatMessagesContainer.innerHTML = '';
                  if (!snapshot.exists()) {
                      chatMessagesContainer.innerHTML = `<div class="text-sm text-gray-500 text-center py-2">Chat is empty</div>`;
                  } else {
                      snapshot.forEach(childSnapshot => renderChatMessage(childSnapshot.val()));
                  }
                  if (!isChatOnCooldown) chatSendBtn.disabled = false;
                  chatInputField.disabled = false;
                  chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
             }, (error) => {
                 console.error("RTDB chat listener error:", error);
                 chatMessagesContainer.innerHTML = `<div class="text-sm text-red-500 text-center py-2">Chat error</div>`;
             });
        }
        
        function renderChatMessage(msg) {
            const isMyMessage = msg.senderId === userProfile.uid;
            const msgEl = document.createElement('div');
            msgEl.className = `chat-message p-3 rounded-lg max-w-[85%] text-sm ${isMyMessage ? 'bg-blue-600 text-white self-end' : 'bg-gray-700 text-white self-start'}`;
            
            const senderName = isMyMessage ? 'You' : (msg.senderName || 'Opponent');
            const time = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
            
            msgEl.innerHTML = `<p class="font-bold text-xs ${isMyMessage ? 'text-blue-200' : 'text-gray-400'}">${senderName}</p>
                             <p class="whitespace-normal break-words">${msg.text}</p>
                             <span class="text-xs ${isMyMessage ? 'text-blue-100' : 'text-gray-400'} opacity-70 block text-right mt-1">${time}</span>`;
            
            chatMessagesContainer.appendChild(msgEl);
            chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            
            if (!isChatPanelOpen) {
                 const messageToShow = `${senderName}: ${msg.text}`;
                 showNotification(messageToShow, 'info', true);
            }
        }
        
        async function sendChatMessage() {
            if (!isAuthReady || !currentRoomId || chatInputField.disabled) return;
            if (isChatOnCooldown) {
                 showNotification('Chat too fast!', 'info');
                 return;
            }
            
            const text = chatInputField.value.trim();
            if (!text) return;
            
            isChatOnCooldown = true;
            chatSendBtn.disabled = true;
            
            setTimeout(() => {
                isChatOnCooldown = false;
                if (!chatInputField.disabled) chatSendBtn.disabled = false; 
            }, CHAT_COOLDOWN_MS); 
            
            const message = {
                senderId: userProfile.uid,
                senderName: userProfile.displayName,
                text: text,
                timestamp: Date.now()
            };
            
            try {
                await push(getChatRoomRef(currentRoomId), message);
                chatInputField.value = '';
            } catch (e) {
                console.error("Error sending RTDB chat message:", e);
                showNotification('Failed to send message.', 'error');
                chatInputField.value = text;
                isChatOnCooldown = false;
                chatSendBtn.disabled = false;
            }
        }
        
        async function deleteChatHistory(roomId) {
            if (!rtdb || !roomId) return;
            try { await remove(getChatRoomRef(roomId)); }
            catch (e) { console.error(`Failed to delete RTDB chat history for room ${roomId}:`, e); }
        }
        
        async function goBackFromMultiplayer() {
             if (unsubscribeRoomListener) unsubscribeRoomListener();
             if (unsubscribeChatListener) unsubscribeChatListener(); 
             if (unsubscribeOpponentPresence) unsubscribeOpponentPresence();
             
             if (rtdb && userProfile.uid) {
                 const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                 const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                 const userStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${userProfile.uid}`);
                 await set(userStatusRef, false);
                 setupPresence(userProfile.uid);
             }
             
             clearInterval(rematchCountdownInterval); 
             clearInterval(rewardTimerInterval); 
             isMultiplayer = false;
             currentRoomId = null;
             myPlayerMark = null;
             gameStartedNotified = false; 
             lastKnownStateFingerprint = null; 
             isChatPanelOpen = false; 
             
             hideScreen(multiplayerResultModal); 
             showScreen(arcadeNexusScreen);
             multiplayerChatPanel.classList.add('hidden'); 
        }
        
        function updateRematchStatusUI() {
             const myRematch = (myPlayerMark === 'X') ? playerXRematch : playerORematch;
             const oppRematch = (myPlayerMark === 'X') ? playerORematch : playerXRematch;
             
             rematchBtn.textContent = myRematch ? 'REMATCH REQUESTED' : 'REQUEST REMATCH';
             rematchBtn.disabled = myRematch;
             
             if (oppRematch) rematchStatusEl.textContent = 'Opponent wants a rematch!';
             else rematchStatusEl.textContent = 'Awaiting opponent...';
        }
        
        function startRematchCountdown() {
             clearInterval(rematchCountdownInterval);
             let count = 3;
             rematchStatusEl.textContent = `Rematch starting in ${count}...`;
             rematchSound.triggerAttackRelease('E4', '0.1', Tone.now());
             rematchCountdownInterval = setInterval(async () => {
                  count--;
                  if (count > 0) {
                       rematchStatusEl.textContent = `Rematch starting in ${count}...`;
                       rematchSound.triggerAttackRelease('E4', '0.1', Tone.now());
                  } else {
                       clearInterval(rematchCountdownInterval);
                       rematchCountdownInterval = null;
                       rematchStatusEl.textContent = 'Starting...';
                       if (myPlayerMark === 'X') await startRematchRound();
                  }
             }, 1000);
        }
        
        async function startRematchRound() {
             if (!currentRoomId) return;
             try {
                  await updateDoc(getRoomDocRef(currentRoomId), {
                       status: 'playing',
                       boardState: Array(boardSize * boardSize).fill(null),
                       currentPlayer: 'X',
                       winner: null,
                       winningLine: [],
                       rematchX: false,
                       rematchO: false,
                       lastUpdated: Date.now()
                  });
                  gameEndedNotified = false;
             } catch (e) {
                  console.error("Error starting rematch:", e);
                  showNotification('Failed to start rematch.', 'error');
             }
        }

    </script>
</body>
</html>