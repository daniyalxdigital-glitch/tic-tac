
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Futuristic Tic-Tac-Toe</title>
    <!-- CSS Remove Kar Diya Hai (Jaisa Aapne Kaha) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

       <link rel="stylesheet" href="style.css">
      
</head>
<body class="overflow-hidden">
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-95 flex flex-col items-center justify-center z-50">
         <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-amber-500" style="border-color: var(--text-title); border-top-color: transparent;"></div>
         <p class="mt-4 text-amber-400 text-lg font-semibold tracking-wider" style="color: var(--text-title);">Loading Arcade Nexus...</p>
    </div>
    <div id="notification-bar" role="alert" class="hidden"></div>
    
    <div id="message-overlay" class="hidden"></div>
    <div id="login-screen" class="min-h-screen p-6 flex flex-col items-center justify-center animate-fade-in-scale-up hidden">
        <div class="w-full max-w-sm">
            <h1 class="w-full text-center text-3xl sm:text-4xl font-bold uppercase tracking-widest mb-4" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
                FUTURISTIC
            </h1>
            <h2 class="w-full text-center text-2xl sm:text-3xl font-bold uppercase tracking-widest mb-12" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
                TIC-TAC-TOE
            </h2>
            <div class="glass-panel p-6 sm:p-8 rounded-2xl w-full space-y-6 mb-6">
                 <button id="play-btn" class="login-btn guest-login-btn">
                     <i data-lucide="play" class="w-5 h-5"></i>
                     <span>PLAY</span>
                 </button>
            </div>
             <div class="glass-panel p-6 sm:p-8 rounded-2xl w-full space-y-4">
                <h3 class="text-lg font-semibold text-gray-400 mb-2">Load Data by ID</h3>
                <input type="text" id="old-game-id-input" class="name-input" placeholder="Paste your saved Game ID">
                <button id="load-data-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg">
                    LOAD DATA
                </button>
            </div>
        </div>
    </div>
    <div id="arcade-nexus-screen" class="min-h-screen p-6 flex flex-col items-center animate-fade-in-scale-up relative hidden">
        <div class="w-full max-w-lg flex justify-between items-center absolute top-4 px-5 z-20">
                 <button id="collect-reward-btn-top" class="play-button py-2 px-4 text-sm font-bold rounded-full shadow-lg" disabled>
                 <i data-lucide="gift" class="w-5 h-5 inline-block mr-1"></i>
                 <span>Collect Reward</span>
             </button>
            <button id="global-settings-btn" class="text-gray-500 dark:text-gray-400 transition-colors z-10 p-2 ml-auto">
                <i data-lucide="settings" class="w-7 h-7"></i>
            </button>
        </div>
        <h1 class="w-full text-center text-3xl sm:text-4xl font-bold uppercase tracking-widest mt-24 mb-4" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
            ARCADE NEXUS
        </h1>
        <h2 id="welcome-message" class="w-full text-center text-lg sm:text-xl font-medium mb-1" style="color: var(--text-light);">
            Welcome, Guest
        </h2>
         <div id="win-streak-display" class="mb-4">
             <i data-lucide="flame" class="w-5 h-5"></i>
             <span>Win Streak: <span id="win-streak-count">0</span></span>
         </div>
        <div id="hearts-bar">
             <i data-lucide="heart" class="w-6 h-6" id="heart-icon"></i>
             <span id="heart-count">20/100</span>
        </div>
        <div class="w-full max-w-lg flex justify-around items-center gap-4 my-4">
             <div class="flex-1 glass-panel p-2 text-center rounded-xl border border-gray-700">
                 <h3 class="text-sm font-semibold text-gray-400">Free Rewards</h3>
                 <p class="text-xs text-amber-400" style="color: var(--text-title);">Collect Now!</p>
             </div>
             <div class="flex-1 glass-panel p-2 text-center rounded-xl border border-gray-700">
                 <h3 class="text-sm font-semibold text-gray-400">Lucky Spin</h3>
                 <p class="text-xs text-amber-400" style="color: var(--text-title);">in 23h 58m 59s</p>
             </div>
             <div class="flex-1 glass-panel p-2 text-center rounded-xl border border-gray-700">
                 <h3 class="text-sm font-semibold text-gray-400">Leaderboards</h3>
                 <p class="text-xs text-amber-400" style="color: var(--text-title);">Ends in: 3d 10h 33m</p>
             </div>
        </div>
        <div id="reward-panel" class="hidden"></div>
        <div class="w-full max-w-lg space-y-4">
            <div id="select-ttt" class="game-list-item active">
                <div class="game-list-preview">
                    <i data-lucide="layout-grid"></i>
                </div>
                <div class="flex-grow min-w-0">
                    <h3 class="game-list-title">PLAYER VS PLAYER</h3>
                </div>
                <button class="game-list-play-btn">
                    <i data-lucide="play"></i>
                    <span>PLAY</span>
                </button>
            </div>
             <div id="select-ai" class="game-list-item">
                <div class="game-list-preview">
                    <i data-lucide="cpu"></i>
                </div>
                <div class="flex-grow min-w-0">
                    <h3 class="game-list-title">PLAY WITH AI</h3>
                </div>
                <button id="ai-btn" class="game-list-play-btn">
                    <i data-lucide="play"></i>
                    <span>PLAY</span>
                </button>
            </div>
            <div id="select-ftf" class="game-list-item">
                <div class="game-list-preview">
                    <i data-lucide="users"></i>
                </div>
                <div class="flex-grow min-w-0">
                    <h3 class="game-list-title">PLAY WITH FRIENDS</h3>
                    <p class="game-list-subtitle">Online Matchmaking</p>
                </div>
                <button id="ftf-btn" class="game-list-play-btn">
                    <i data-lucide="arrow-right"></i>
                    <span>SELECT</span>
                </button>
            </div>
        </div>
    </div>
     <div id="ftf-modal" class="modal-backdrop hidden">
        <div id="ftf-content" class="modal-content text-center">
            <button id="ftf-close-btn" class="absolute top-4 right-5 text-gray-500 hover:text-amber-500 transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
            <h2 id="ftf-title" class="text-3xl font-bold mb-6" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
                PLAY WITH FRIENDS
            </h2>
            <div id="ftf-selection-view">
                <div class="flex flex-col space-y-4">
                    <button id="ftf-create-room-select-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg">
                        <i data-lucide="plus-square" class="w-5 h-5"></i>
                        <span>CREATE ROOM (-1 Heart)</span>
                    </button>
                    <button id="ftf-join-room-select-btn" class="control-btn w-full justify-center py-3 text-lg">
                        <i data-lucide="log-in" class="w-5 h-5"></i>
                        <span>JOIN ROOM (-1 Heart)</span>
                    </button>
                </div>
            </div>
            <div id="ftf-create-view" class="hidden space-y-6">
                <p class="text-sm text-gray-400">Share this code with your friend to start the match.</p>
                <div class="bg-gray-800 p-4 rounded-xl flex justify-between items-center shadow-inner border border-amber-600">
                    <span id="room-code-display" class="text-2xl font-mono text-amber-400 font-bold tracking-widest">LOADING...</span>
                    <button id="copy-room-code-btn" class="text-amber-400 hover:text-amber-300 transition-colors p-2" title="Copy Code">
                         <i data-lucide="copy" class="w-5 h-5"></i>
                    </button>
                </div>
                <div id="waiting-status" class="flex flex-col items-center justify-center space-y-2 mt-4">
                    <div class="animate-spin rounded-full h-8 w-8 border-t-4 border-b-4 border-amber-500"></div>
                    <p class="text-amber-400 font-semibold">WAITING FOR PLAYER 2...</p>
                </div>
                 <button id="cancel-room-btn" class="control-btn justify-center py-2 text-md mt-4 text-red-400">
                    CANCEL
                </button>
            </div>
             <div id="ftf-join-view" class="hidden space-y-4">
                <input type="text" id="join-room-input" class="name-input text-center uppercase tracking-widest" placeholder="ENTER ROOM CODE">
                <button id="join-room-submit-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg" disabled>
                    SUBMIT
                </button>
                <button id="back-to-selection-btn" class="control-btn w-full justify-center py-2 text-md mt-4">
                    BACK
                </button>
            </div>
        </div>
    </div>
    <div id="main-menu-screen" class="min-h-screen max-h-screen overflow-y-auto p-6 flex flex-col items-center pt-24 hidden animate-fade-in-scale-up relative">
         <button id="main-menu-close-btn" class="absolute top-4 left-5 text-gray-500 transition-colors z-10 p-2">
            <i data-lucide="arrow-left" class="w-8 h-8"></i>
        </button>
        <div class="glass-panel p-6 sm:p-8 rounded-2xl w-full max-w-md max-h-\[95vh\] overflow-y-auto">
            <h2 class="text-3xl font-bold text-center mb-6 mt-8" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
                NEW GAME
            </h2>
            <div class="space-y-4">
                <div>
                    <h3 class="text-lg font-semibold text-gray-400 mb-2">Board Size</h3>
                    <div class="option-group grid grid-cols-2 sm:grid-cols-3 gap-3">
                        <div><input type="radio" id="size-3x3" name="board-size" value="3" checked><label for="size-3x3">3 x 3</label></div>
                        <div><input type="radio" id="size-4x4" name="board-size" value="4"><label for="size-4x4">4 x 4</label></div>
                        <div><input type="radio" id="size-5x5" name="board-size" value="5"><label for="size-5x5">5 x 5</label></div>
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-400 mb-2">Game Mode</h3>
                    <div class="option-group grid grid-cols-2 gap-3">
                        <div><input type="radio" id="mode-pvp" name="game-mode" value="pvp" checked><label for="mode-pvp">Player vs Player</label></div>
                        <div><input type="radio" id="mode-pva" name="game-mode" value="pva"><label for="mode-pva">Player vs AI (-1 Heart)</label></div>
                    </div>
                </div>
                <div id="ai-difficulty-section" class="hidden">
                    <h3 class="text-lg font-semibold text-gray-400 mb-2">AI Difficulty</h3>
                    <div class="option-group grid grid-cols-2 gap-3">
                        <div><input type="radio" id="ai-easy" name="ai-difficulty" value="easy"><label for="ai-easy">Easy</label></div>
                        <div><input type="radio" id="ai-medium" name="ai-difficulty" value="medium" checked><label for="ai-medium">Medium</label></div>
                        <div><input type="radio" id="ai-hard" name="ai-difficulty" value="hard"><label for="ai-hard">Hard</label></div>
                        <div><input type="radio" id="ai-grandmaster" name="ai-difficulty" value="grandmaster"><label for="ai-grandmaster">Grandmaster</label></div>
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-400 mb-2">Game Variant</h3>
                    <div class="option-group grid grid-cols-2 gap-3">
                        <div><input type="radio" id="variant-classic" name="game-variant" value="classic" checked><label for="variant-classic">Classic</label></div>
                        <div><input type="radio" id="variant-blocker" name="game-variant" value="blocker"><label for="variant-blocker">Blocker</label></div>
                    </div>
                </div>
                <div id="icon-customization-section">
                    <h3 id="customization-player-title" class="text-lg font-semibold text-gray-400 mb-2">Icon Customization (Player X)</h3>
                    <div class="grid grid-cols-1 gap-4">
                        <div class="space-y-2">
                             <h4 class="text-sm font-medium text-gray-500">Icon</h4>
                             <div id="icon-select-container" class="flex gap-3 flex-wrap">
                             </div>
                        </div>
                    </div>
                </div>
                <button id="start-game-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg mt-5">
                    START GAME
                </button>
            </div>
        </div>
    </div>
    <div id="game-screen" class="game-screen hidden">
        <div id="game-content-area">
            <div class="game-header-new">
                
                <div id="player-x-profile" class="player-profile player-x active-turn">
                    <div class="icon" style="color: var(--player-x-color); text-shadow: var(--player-x-shadow);">
                        <i data-lucide="x" class="w-6 h-6 md:w-7 md:h-7"></i>
                    </div>
                    <div class="profile-info">
                        <h3 id="player-x-name" class="name">DANIYAL</h3>
                        <p id="player-x-score" class="score">0</p>
                    </div>
                </div>
                <div id="game-status-display">
                    Your Turn
                </div>
                <div id="player-o-profile" class="player-profile player-o">
                    <div class="icon" style="color: var(--player-o-color); text-shadow: var(--player-o-shadow);">
                        <i data-lucide="sparkles" class="w-6 h-6 md:w-7 md:h-7"></i>
                    </div>
                    <div class="profile-info">
                        <h3 id="player-o-name" class="name">AI</h3>
                        <p id="player-o-score" class="score">0</p>
                    </div>
                </div>
            </div>
            <div id="game-board-wrapper">
                <div id="game-board-container" class="board-size-3"></div>
            </div>
            <div id="chat-panel-area">
                
                 <div id="multiplayer-chat-panel" class="hidden">
                     <h3 class="text-xl font-bold mb-3" style="color: var(--text-title);">ROOM CHAT</h3>
                     <div id="chat-messages" class="flex-grow overflow-y-auto mb-4">
                         <div class="text-sm text-gray-500 text-center py-2">Start chatting when the game begins</div>
                     </div>
                     <div id="chat-input-container">
                         <input type="text" id="chat-input-field" placeholder="Write a message..." maxlength="150">
                         <button id="chat-send-btn" disabled>
                             <i data-lucide="send" class="w-5 h-5"></i>
                         </button>
                     </div>
                 </div>
                 <div id="desktop-game-controls" class="hidden lg:flex justify-center items-center gap-4 mt-2">
                    <button id="ai-tip-btn-desktop" class="nav-btn relative" title="Get AI Hint (-5 Hearts)">
                        <i data-lucide="lightbulb" class="w-6 h-6"></i>
                    </button>
                    <button id="blocker-powerup-btn-desktop" class="nav-btn text-red-400 hover:text-red-300 hidden">
                        <i data-lucide="shield-ban"></i>
                    </button>
                 </div>
            </div>
            
        </div>
        <div id="fixed-controls-bar" class="p-4">
            
            <div class="flex gap-4">
                <button id="chat-toggle-btn" class="bottom-nav-btn">
                    <i data-lucide="message-square" class="w-6 h-6"></i>
                </button>
                
                <button id="ai-tip-btn" class="bottom-nav-btn relative hidden" title="Get AI Hint (-5 Hearts)">
                    <i data-lucide="lightbulb" class="w-6 h-6"></i>
                </button>
                <button id="blocker-powerup-btn-mobile" class="bottom-nav-btn relative hidden">
                     <i data-lucide="shield-ban" class="w-6 h-6"></i>
                </button>
            </div>
            
            <button id="settings-btn" class="bottom-nav-btn ml-auto">
                <i data-lucide="settings" class="w-6 h-6"></i>
            </button>
        </div>
        
        <div id="confetti-container"></div>
    </div>
    <div id="settings-modal" class="modal-backdrop hidden">
        <div class="modal-content text-center">
            <button id="settings-close-btn" class="absolute top-4 right-5 text-gray-500 hover:text-amber-500 transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
            <h2 class="text-3xl font-bold mb-6" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
                SETTINGS
            </h2>
            <div class="grid grid-cols-1 gap-4">
                <button id="restart-game-btn" class="control-btn py-3 text-lg"><i data-lucide="refresh-cw" class="w-5 h-5"></i>Restart</button>
                <button id="in-game-sound-toggle-btn" class="sound-toggle-btn py-3 text-lg">
                     <i data-lucide="volume-2" class="w-5 h-5"></i>
                    <span>Sound On</span>
                </button>
            </div>
            <button id="back-to-main-menu-btn" class="control-btn w-full justify-center py-3 text-lg mt-6">
                <i data-lucide="arrow-left" class="w-5 h-5"></i>Back to Main Menu
            </button>
        </div>
    </div>
     <div id="global-settings-modal" class="modal-backdrop hidden">
        <div class="modal-content text-center">
            <button id="global-settings-close-btn" class="absolute top-4 right-5 text-gray-500 hover:text-amber-500 transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
            <h2 class="text-3xl font-bold mb-6" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
                OPTIONS
            </h2>
            <div class="grid grid-cols-1 gap-4">
                 <div>
                    <h3 class="text-lg font-semibold text-gray-400 mb-2">Your Name</h3>
                    <input type="text" id="player-name-input" class="name-input" placeholder="Player 1" maxlength="10">
                 </div>
                
                <button id="sound-toggle-btn" class="sound-toggle-btn py-3 text-lg">
                    <i data-lucide="volume-2" class="w-5 h-5"></i>
                    <span>Sound On</span>
                </button>
                
                <a target="_blank" rel="noopener noreferrer" id="purchase-license-btn" 
                   class="control-btn w-full justify-center py-3 text-lg text-amber-400 opacity-50 cursor-not-allowed"
                   title="Link Disabled"
                >
                    <i data-lucide="briefcase" class="w-5 h-5"></i>
                    <span>Purchase License</span>
                </a>
                
                <button id="logout-btn" class="control-btn w-full justify-center py-3 text-lg text-red-400 hover:text-red-300">
                    <i data-lucide="log-out" class="w-5 h-5"></i>
                    <span>Logout</span>
                </button>
            </div>
        </div>
    </div>
    <div id="game-over-modal" class="modal-backdrop hidden">
        <div class="modal-content text-center">
             <h2 id="game-over-message" class="text-3xl font-bold mb-4" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
                 PLAYER X WINS!
             </h2>
             <div class="text-left mb-6 space-y-2">
                 <div class="stat-item"><span class="stat-label">Time Taken:</span> <span id="stat-time" class="stat-value">0s</span></div>
                 <div class="stat-item"><span class="stat-label">Total Moves:</span> <span id="stat-moves" class="stat-value">0</span></div>
                 <div class="stat-item"><span class="stat-label">Hearts Change:</span> <span id="stat-hearts" class="stat-value negative">-1 Heart</span></div>
                 <div class="stat-item"><span class="stat-label">Win Streak:</span> <span id="stat-win-streak" class="stat-value positive">0 Wins</span></div>
             </div>
             <div class="flex flex-col space-y-4">
                 <button id="play-again-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg">
                     Next Round
                 </button>
                 <button id="back-to-menu-btn" class="control-btn w-full justify-center py-3 text-lg">
                     Back to Menu
                 </button>
             </div>
         </div>
    </div>
    <div id="multiplayer-result-modal" class="modal-backdrop hidden">
        <div class="modal-content text-center">
            <button id="multiplayer-result-close-btn" class="absolute top-4 right-5 text-gray-500 hover:text-amber-500 transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
             <h2 id="multiplayer-result-title" class="text-3xl font-bold mb-4" style="font-family: 'Oxanium', monospace; color: var(--text-title);">
                MATCH FINISHED
            </h2>
            <div id="multiplayer-score-display" class="flex justify-around items-center mb-6">
                 <div class="player-result-card player-x">
                     <span class="text-xs text-gray-400">PLAYER X</span>
                     <div class="result-icon"> <i id="result-icon-x" data-lucide="x"></i> </div>
                     <p id="result-name-x" class="result-name">Name X</p>
                     <p id="result-score-x" class="text-3xl font-bold text-amber-400">0</p>
                 </div>
                 <span class="text-4xl font-extrabold text-gray-500 mx-4">VS</span>
                 <div class="player-result-card player-o">
                     <span class="text-xs text-gray-400">PLAYER O</span>
                     <div class="result-icon"> <i id="result-icon-o" data-lucide="circle"></i> </div>
                     <p id="result-name-o" class="result-name">Name O</p>
                     <p id="result-score-o" class="text-3xl font-bold text-red-400">0</p>
                     </div>
                 </div>
                 <div class="text-left mb-4 space-y-1 text-sm">
                      <div class="stat-item"><span class="stat-label">Hearts Change:</span> <span id="mp-stat-hearts" class="stat-value negative">0 Hearts</span></div>
                      <div class="stat-item"><span class="stat-label">Win Streak:</span> <span id="mp-stat-win-streak" class="stat-value positive">0 Wins</span></div>
                 </div>
                <p id="rematch-status" class="text-sm font-semibold mb-4">Awaiting opponent's request...</p>
                <div class="flex flex-col space-y-4">
                    <button id="rematch-btn" class="play-button w-full py-3 rounded-xl font-bold text-lg shadow-lg">
                        REQUEST REMATCH
                    </button>
                    <button id="multiplayer-back-to-menu-btn" class="control-btn w-full justify-center py-3 text-lg">
                        LEAVE ROOM
                    </button>
                </div>
            </div>
        </div>

        <script type="module">
            import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
            import { getAuth, signInAnonymously, signInWithCustomToken, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
            
            import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, deleteDoc, runTransaction, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
            
            import { getDatabase, ref, onValue, set, onDisconnect, push, remove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";
            import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
            
            let app;
            let auth;
            let db;
            let rtdb; 
            let isAuthReady = false;
            let saveDebounceTimer = null;
            
            const SCORE_COLLECTION = 'tictactoe_scores';
            const ROOM_COLLECTION = 'rooms';
        
            
            const FIREBASE_FALLBACK_CONFIG = {
                apiKey: "AIzaSyBUZ-U_NrrqLs5IHjT3QiJUI9UeYeknDQM",
                authDomain: "tic-tac-game-92b57.firebaseapp.com",
                databaseURL: "https://tic-tac-game-92b57-default-rtdb.firebaseio.com/", 
                projectId: "tic-tac-game-92b57",
                storageBucket: "tic-tac-game-92b57.appspot.com",
                messagingSenderId: "426567158009",
                appId: "1:426567158009:web:c086438883e025ff75f85b" 
            };
            
            const AI_PERSONALITIES = {
                easy: { name: 'NOODLER', thinking: 'Noodler is thinking...' },
                medium: { name: 'ANALYST', thinking: 'Analyst is thinking...' },
                hard: { name: 'ARCHITECT', thinking: 'Architect is thinking...' },
                grandmaster: { name: 'GRANDMASTER', thinking: 'Grandmaster is planning...' }
            };
            
            const FREE_REWARD_CAP = 100;
            const STARTING_HEARTS = 20;
            const REWARD_INTERVAL = 3 * 60 * 60 * 1000;
            const REWARD_AMOUNT = 3; 
            const AI_WIN_REWARD = 2;
            const AI_LOSE_COST = -1;
            const FTF_WIN_REWARD = 2;
            const FTF_CREATE_COST = -1;
            const FTF_JOIN_COST = -1;
            const AI_TIP_COST = 5;
            const WIN_STREAK_BONUS_COUNT = 3;
            const WIN_STREAK_BONUS_AMOUNT = 5;
            
            const ICON_COSTS = {
                'x': ['x', 0],
                'circle': ['circle', 0],
                'shield': ['shield', 5],
                'lightning': ['zap', 8],
                'skull': ['skull', 15],
                'anchor': ['anchor', 10],
                'sparkles': ['sparkles', 0],
            };
            const COLOR_MAP = {
                'cyan': ['var(--player-x-color)', 'var(--player-x-shadow)'],
                'purple-neon': ['var(--player-o-color)', 'var(--player-o-shadow)']
            };
            const COLOR_COSTS = COLOR_MAP;
            const MINIMAX_DEPTHS = {
                3: 5,
                4: 4,
                5: 3
            };
            let gameSettings = {};
            let player1Name = "Play";
            let playerXScore = 0;
            let playerOScore = 0;
            let currentHearts = STARTING_HEARTS;
            let nextRewardTimestamp = 0;
            let winStreak = 0; 
            let playerXIcon = 'x';
            let playerXColor = 'cyan';
            let unlockedIcons = ['x', 'circle'];
            let userProfile = {
                uid: null,
                displayName: 'Play',
                isGuest: true
            };
            let unsubscribeUserScoresListener = null;
            const humanPlayer = 'X';
            const aiPlayer = 'O';
            let playerOIcon = 'sparkles';
            let playerOColor = 'purple-neon';
            let currentPlayer = 'X';
            let boardState = [];
            let isGameActive = true;
            let boardSize = 3;
            let moveHistory = [];
            let gameStartTime;
            let moveCount = 0;
            let audioStarted = false; 
            let isMuted = false; 
            let blockerCountX = 1;
            let blockerCountO = 1;
            let isBlockerActive = false;
            let turnTimer;
            const TURN_DURATION = 5; 
            let rewardTimerInterval; 
            let isMoveOnCooldown = false;
            const MOVE_COOLDOWN_MS = 300;
            let isChatOnCooldown = false;
            const CHAT_COOLDOWN_MS = 1500;
            let isCreatingRoom = false;
            let isMultiplayer = false;
            let currentRoomId = null;
            let myPlayerMark = null;
            let unsubscribeRoomListener = null;
            let unsubscribeChatListener = null;
            let unsubscribeOpponentPresence = null; 
            let opponentName = 'Opponent'; 
            let opponentMark = null; 
            let playerXRematch = false; 
            let playerORematch = false; 
            let rematchCountdownInterval = null; 
            let gameStartedNotified = false; 
            let mpPlayerXData = {}; 
            let mpPlayerOData = {}; 
            let notificationTimeout; 
            let lastKnownStateFingerprint = null; 
            let isChatPanelOpen = false;
            let gameEndedNotified = false; 
            
            const multiplayerChatPanel = document.getElementById('multiplayer-chat-panel');
            const chatInputField = document.getElementById('chat-input-field');
            const chatSendBtn = document.getElementById('chat-send-btn');
            const chatMessagesContainer = document.getElementById('chat-messages');
            const messageOverlay = document.getElementById('message-overlay'); 
            const chatToggleButton = document.getElementById('chat-toggle-btn');
            const aiTipBtnMobile = document.getElementById('ai-tip-btn');
            const blockerPowerupBtnMobile = document.getElementById('blocker-powerup-btn-mobile');
            try {
                window.addEventListener('DOMContentLoaded', () => {
                    console.log("DOM loaded. Futuristic UI Initializing...");
                    const docHtml = document.documentElement;
                    const loadingOverlay = document.getElementById('loading-overlay');
                    const notificationBar = document.getElementById('notification-bar'); 
                    const loginScreen = document.getElementById('login-screen');
                    const playBtn = document.getElementById('play-btn');
                    const oldGameIdInput = document.getElementById('old-game-id-input'); 
                    const loadDataBtn = document.getElementById('load-data-btn'); 
                    const welcomeMessage = document.getElementById('welcome-message');
                    const logoutBtn = document.getElementById('logout-btn');
                    const winStreakDisplay = document.getElementById('win-streak-display'); 
                    const winStreakCountEl = document.getElementById('win-streak-count'); 
                    const arcadeNexusScreen = document.getElementById('arcade-nexus-screen');
                    const mainMenuScreen = document.getElementById('main-menu-screen');
                    const gameScreen = document.getElementById('game-screen');
                    const gameOverModal = document.getElementById('game-over-modal');
                    const settingsModal = document.getElementById('settings-modal'); 
                    const globalSettingsModal = document.getElementById('global-settings-modal'); 
                    const ftfModal = document.getElementById('ftf-modal'); 
                    const multiplayerResultModal = document.getElementById('multiplayer-result-modal'); 
                    const selectTttBtn = document.getElementById('select-ttt');
                    const selectAiBtn = document.getElementById('select-ai'); 
                    const selectFtfBtn = document.getElementById('select-ftf'); 
                    const ftfBtn = document.getElementById('ftf-btn'); 
                    const ftfCloseBtn = document.getElementById('ftf-close-btn'); 
                    const createRoomSelectBtn = document.getElementById('ftf-create-room-select-btn'); 
                    const joinRoomSelectBtn = document.getElementById('ftf-join-room-select-btn'); 
                    const aiBtn = document.getElementById('ai-btn'); 
                    const ftfSelectionView = document.getElementById('ftf-selection-view');
                    const ftfCreateView = document.getElementById('ftf-create-view');
                    const ftfJoinView = document.getElementById('ftf-join-view');
                    const roomCodeDisplay = document.getElementById('room-code-display');
                    const copyRoomCodeBtn = document.getElementById('copy-room-code-btn');
                    const waitingStatus = document.getElementById('waiting-status');
                    const cancelRoomBtn = document.getElementById('cancel-room-btn');
                    const joinRoomInput = document.getElementById('join-room-input');
                    const joinRoomSubmitBtn = document.getElementById('join-room-submit-btn');
                    const backToSelectionBtn = document.getElementById('back-to-selection-btn');
                    const mpResultTitle = document.getElementById('multiplayer-result-title');
                    const resultCardX = multiplayerResultModal.querySelector('.player-result-card.player-x');
                    const resultCardO = multiplayerResultModal.querySelector('.player-result-card.player-o');
                    const resultNameX = document.getElementById('result-name-x');
                    const resultNameO = document.getElementById('result-name-o');
                    const resultScoreX = document.getElementById('result-score-x');
                    const resultScoreO = document.getElementById('result-score-o');
                    const resultIconX = document.getElementById('result-icon-x');
                    const resultIconO = document.getElementById('result-icon-o');
                    const rematchStatusEl = document.getElementById('rematch-status');
                    const rematchBtn = document.getElementById('rematch-btn');
                    const mpBackToMenuBtn = document.getElementById('multiplayer-back-to-menu-btn');
                    const mpStatHearts = document.getElementById('mp-stat-hearts'); 
                    const mpStatWinStreak = document.getElementById('mp-stat-win-streak'); 
                    const globalSettingsBtn = document.getElementById('global-settings-btn'); 
                    const globalSettingsCloseBtn = document.getElementById('global-settings-close-btn'); 
                    const soundToggleBtn = document.getElementById('sound-toggle-btn'); 
                    const inGameSoundToggleBtn = document.getElementById('in-game-sound-toggle-btn'); 
                    const mainMenuCloseBtn = document.getElementById('main-menu-close-btn');
                    const startGameBtn = document.getElementById('start-game-btn');
                    const settingsBtn = document.getElementById('settings-btn'); 
                    const settingsCloseBtn = document.getElementById('settings-close-btn'); 

                    const backToMainMenuBtn = document.getElementById('back-to-main-menu-btn'); 
                    const playAgainBtn = document.getElementById('play-again-btn'); 
                    const backToMenuBtn = document.getElementById('back-to-menu-btn'); 
                    const playerNameInput = document.getElementById('player-name-input');
                    const gameModeRadios = document.querySelectorAll('input[name="game-mode"]');
                    const aiDifficultySection = document.getElementById('ai-difficulty-section');
                    const gameBoardContainer = document.getElementById('game-board-container');
                    const playerXProfile = document.getElementById('player-x-profile');
                    const playerOProfile = document.getElementById('player-o-profile');
                    const playerXScoreEl = document.getElementById('player-x-score');
                    const playerOScoreEl = document.getElementById('player-o-score');
                    const playerXNameEl = document.getElementById('player-x-name');
                    const playerONameEl = document.getElementById('player-o-name');
                    const gameStatusDisplay = document.getElementById('game-status-display');
                    const gameOverMessage = document.getElementById('game-over-message');
                    const statTime = document.getElementById('stat-time');
                    const statMoves = document.getElementById('stat-moves');
                    const statHearts = document.getElementById('stat-hearts'); 
                    const statWinStreak = document.getElementById('stat-win-streak'); 
                    const blockerPowerupBtn = document.getElementById('blocker-powerup-btn-desktop'); 
                    const confettiContainer = document.getElementById('confetti-container');
                    const aiTipBtn = document.getElementById('ai-tip-btn-desktop'); 
                    const customizationPlayerTitle = document.getElementById('customization-player-title'); 
                    const heartCountEl = document.getElementById('heart-count');
                    const rewardPanel = document.getElementById('reward-panel');
                    const collectRewardBtnTop = document.getElementById('collect-reward-btn-top'); 
                    const iconSelectContainer = document.getElementById('icon-select-container');
                    const colorSelectContainer = document.getElementById('color-select-container');
                    
                    let clickSound, winSound, drawSound, undoSound, invalidSound, themeSound, timerTickSound, tipSound, loseSound, rematchSound;
                     try {
                        if (typeof Tone !== 'undefined' && Tone.Synth) {
                             clickSound = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.0, release: 0.1 } }).toDestination();
                             winSound = new Tone.PolySynth(Tone.Synth, { envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
                             drawSound = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.0, release: 0.1 } }).toDestination();
                             undoSound = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
                             invalidSound = new Tone.Synth({ oscillator: { type: 'square' }, volume: -12, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                             themeSound = new Tone.Synth({ oscillator: { type: 'sine' }, volume: -10, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                             timerTickSound = new Tone.Synth({ oscillator: { type: 'sine' }, volume: -15, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                             tipSound = new Tone.Synth({ oscillator: { type: 'triangle' }, volume: -8, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                             loseSound = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 }, volume: -15 }).toDestination(); 
                             rematchSound = new Tone.Synth({ oscillator: { type: 'square' }, volume: -10, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination(); 
                        } else {
                             console.warn("Tone.js not fully loaded or available. Sounds disabled.");
                             throw new Error("Tone.js missing");
                        }
                    } catch (e) {
                        console.error("Tone.js init error:", e);
                        const dummySound = { triggerAttackRelease: () => {} };
                        clickSound = winSound = drawSound = undoSound = invalidSound = themeSound = timerTickSound = tipSound = loseSound = rematchSound = dummySound;
                        [soundToggleBtn, inGameSoundToggleBtn].forEach(btn => {
                             if(btn) {
                                 btn.disabled = true;
                                 const span = btn.querySelector('span');
                                 if(span) span.textContent = 'Sound Error';
                                 btn.classList.add('opacity-50', 'cursor-not-allowed');
                             }
                        });
                    }
                    const playSound = (sound, note = 'C5', duration = '8n') => {
                        if (!audioStarted || isMuted || !sound || typeof sound.triggerAttackRelease !== 'function') return;
                        try {
                            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                                Tone.start();
                                audioStarted = true;
                            }
                            sound.triggerAttackRelease(note, duration);
                        } catch (e) {
                            console.warn(`Sound play failed for [${note}]:`, e);
                        }
                    };
                    function setSoundState(muted) {
                        if (!muted && !audioStarted && typeof Tone !== 'undefined') {
                             Tone.start().then(() => {
                                  audioStarted = true;
                                  console.log('Audio context started on unmute.');
                             });
                        }
                        isMuted = muted;
                        localStorage.setItem('ticTacToeMuted', isMuted ? 'true' : 'false');
                        const icon = isMuted ? 'volume-x' : 'volume-2';
                        const text = isMuted ? 'Sound Off' : 'Sound On';
                        const className = isMuted ? 'muted' : '';
                        [soundToggleBtn, inGameSoundToggleBtn].forEach(btn => {
                             if(btn) {
                                 const i = btn.querySelector('i');
                                 const span = btn.querySelector('span');
                                 if (i) i.setAttribute('data-lucide', icon);
                                 if (span) span.textContent = text;
                                 btn.className = 'sound-toggle-btn py-3 text-lg';
                                 if (className) {
                                     btn.classList.add(className);
                                 }
                                 if (i) lucide.createIcons({ nodes: [i] });
                             }
                        });
                    }
                    function showNotification(message, type = 'info', isChatMessage = false) {
                        clearTimeout(notificationTimeout);
                        
                        if (isChatMessage) {
                             messageOverlay.textContent = message;
                             messageOverlay.classList.remove('hidden');
                             messageOverlay.style.display = 'block';
                             
                             setTimeout(() => {
                                 messageOverlay.style.display = 'none';
                             }, 2500);
                             return;
                        }
                         notificationBar.classList.remove('show', 'success', 'error', 'info');
                         notificationBar.classList.add('hidden');
                         notificationBar.textContent = message;
                         notificationBar.classList.remove('hidden');
                         notificationBar.classList.add(type);
                         setTimeout(() => {
                             notificationBar.classList.add('show');
                         }, 10); 
                         notificationTimeout = setTimeout(() => {
                              notificationBar.classList.remove('show');
                              setTimeout(() => {
                                   notificationBar.classList.add('hidden');
                              }, 300);
                         }, 4000);
                    }
                    function copyTextToClipboard(text) {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            navigator.clipboard.writeText(text).then(() => {
                                showNotification('Code copied to clipboard!', 'success');
                            }).catch(err => {
                                fallbackCopyTextToClipboard(text);
                            });
                            return;
                        }
                        fallbackCopyTextToClipboard(text);
                    }
                    function fallbackCopyTextToClipboard(text) {
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.focus();
                        textarea.select();
                        try {
                            const successful = document.execCommand('copy');
                            if (successful) {
                                showNotification('Code copied to clipboard!', 'success');
                            } else {
                                showNotification('Copy failed. Please manually select the code.', 'error');
                            }
                        } catch (err) {
                            showNotification('Copy failed. Please manually select the code.', 'error');
                        }
                        document.body.removeChild(textarea);
                    }
                    function generateRoomId() {
                        const length = 6;
                        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                        let result = '';
                        for (let i = 0; i < length; i++) {
                            result += chars.charAt(Math.floor(Math.random() * chars.length));
                        }
                        return result;
                    }
                    
                    function showScreen(screenToShow) {
                        loadingOverlay.classList.add('hidden');
                        [loginScreen, arcadeNexusScreen, mainMenuScreen, gameScreen, gameOverModal, settingsModal, globalSettingsModal, ftfModal, multiplayerResultModal].forEach(screen => {
                            if (screen) screen.classList.add('hidden');
                        });
                        if (screenToShow) {
                            screenToShow.classList.remove('hidden');
                            screenToShow.classList.remove('animate-fade-out-scale-down');
                            screenToShow.classList.add('animate-fade-in-scale-up');
                        }
                    }
                    
                    function hideScreen(screenToHide, onHidden) {
                         if (!screenToHide || screenToHide.classList.contains('hidden')) { 
                             if (onHidden) onHidden(); 
                             return; 
                         }
                         
                         if (screenToHide.dataset.isHiding === 'true') {
                             return;
                         }
                         screenToHide.dataset.isHiding = 'true';
                         
                         screenToHide.classList.remove('animate-fade-in-scale-up');
                         screenToHide.classList.add('animate-fade-out-scale-down');
                        
                        setTimeout(() => {
                            screenToHide.classList.add('hidden');
                            screenToHide.dataset.isHiding = 'false';
                            
                            if (onHidden) {
                                onHidden();
                            }
                        }, 300);
                    }
                    function applyTheme(mode) {
                         const htmlEl = document.documentElement;
                         let themeName = 'carrom-default';
                         if (mode === 'pva') {
                             themeName = 'purple';
                         } else if (mode === 'pvp' || mode === 'multiplayer') {
                             themeName = 'friend-blue';
                         }
                         htmlEl.setAttribute('data-theme', themeName);
                    }
                    function updatePlayerIconDisplay(player, iconName, colorId) {
                        const profileEl = player === 'X' ? playerXProfile : playerOProfile;
                        const iconContainer = profileEl.querySelector('.icon');
                        if (player === 'O' && !isMultiplayer && gameSettings.gameMode === 'pva') {
                             colorId = 'purple-neon';
                             iconName = 'sparkles';
                        }
                        
                        const iconData = ICON_COSTS[iconName] || ICON_COSTS.x;
                        if (!iconContainer || !iconData) return;
                        const iEl = document.createElement('i');
                        iEl.setAttribute('data-lucide', iconData[0]);
                        iconContainer.innerHTML = ''; 
                        iconContainer.appendChild(iEl);
                        lucide.createIcons({ nodes: [iEl] });
                    }
                    function loadSettings() {
                         gameSettings = gameSettings || {}; 
                         player1Name = player1Name || 'Play';
                         playerNameInput.value = player1Name;
                        
                        document.querySelector(`input[name="board-size"][value="${gameSettings.boardSize || 3}"]`).checked = true;
                        document.querySelector(`input[name="game-mode"][value="${gameSettings.gameMode || 'pvp'}"]`).checked = true;
                        let aiDiff = gameSettings.aiDifficulty || 'medium';
                        if (aiDiff === 'expert') aiDiff = 'hard';
                        const aiDiffRadio = document.querySelector(`input[name="ai-difficulty"][value="${aiDiff}"]`);
                        if (aiDiffRadio) {
                            aiDiffRadio.checked = true;
                        } else {
                            document.querySelector('input[name="ai-difficulty"][value="medium"]').checked = true;
                        }
                        const currentVariant = gameSettings.gameVariant === 'blind' || gameSettings.gameVariant === 'gravity' ? 'classic' : (gameSettings.gameVariant || 'classic');
                        document.querySelector(`input[name="game-variant"][value="${currentVariant}"]`).checked = true;
                        gameSettings.gameVariant = currentVariant;
                         const gameModeChecked = document.querySelector('input[name="game-mode"]:checked');
                         if (gameModeChecked) gameModeChecked.dispatchEvent(new Event('change'));
                         
                         isMuted = localStorage.getItem('ticTacToeMuted') === 'true';
                         setSoundState(isMuted);
                         
                         playerXIcon = playerXIcon || 'x';
                         playerXColor = 'cyan'; 
                    }
                    function saveSettings() {
                    }
                    function getScoreDocRef(userId) {
                        const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId; 
                        return doc(db, 'artifacts', appId, 'users', userId, SCORE_COLLECTION, 'user_scores');
                    }
                    function getRoomDocRef(roomId) {
                        const isCanvasEnv = typeof __app_id !== 'undefined';
                        let appId;
                        if (isCanvasEnv) {
                            appId = __app_id; 
                        } else {
                            appId = FIREBASE_FALLBACK_CONFIG.projectId;
                        }
                        return doc(db, 'artifacts', appId, 'public', 'data', ROOM_COLLECTION, roomId);
                    }
                    
                  
                    function getChatRoomRef(roomId) {
                        const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                 
                        const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                        return ref(rtdb, `artifacts/${rtdbAppId}/public/data/chat/${roomId}`);
                    }
                    
                    async function listenToUserScores(uid) {
                        if (!isAuthReady || !uid) {
                            console.warn("Firestore not ready or UID missing. Skipping score listen.");
                            return;
                        }
                        if (unsubscribeUserScoresListener) unsubscribeUserScoresListener();
                    
                        const scoreDocRef = getScoreDocRef(uid);
                        unsubscribeUserScoresListener = onSnapshot(scoreDocRef, async (docSnap) => {
                            let dataToSave = {};
                            let needsSave = false;
                    
                            if (docSnap.exists()) {
                                dataToSave = docSnap.data();
                            } else {
                                dataToSave = {
                                    x: 0,
                                    o: 0,
                                    hearts: STARTING_HEARTS,
                                    nextRewardTimestamp: Date.now() + REWARD_INTERVAL,
                                    unlockedIcons: ['x', 'circle'],
                                    winStreak: 0,
                                    displayName: userProfile.displayName,
                                    gameSettings: {},
                                    playerXIcon: 'x'
                                };
                                needsSave = true;
                            }
                    
                            playerXScore = dataToSave.x || 0;
                            playerOScore = dataToSave.o || 0;
                            currentHearts = (dataToSave.hearts !== undefined && dataToSave.hearts !== null) ? dataToSave.hearts : STARTING_HEARTS;
                            nextRewardTimestamp = dataToSave.nextRewardTimestamp || Date.now();
                            unlockedIcons = dataToSave.unlockedIcons || ['x', 'circle'];
                            winStreak = dataToSave.winStreak || 0;
                            player1Name = dataToSave.displayName || userProfile.displayName;
                            gameSettings = dataToSave.gameSettings || {};
                            
                            if (unlockedIcons.includes(dataToSave.playerXIcon) && ICON_COSTS[dataToSave.playerXIcon]) {
                                playerXIcon = dataToSave.playerXIcon;
                            } else {
                                playerXIcon = 'x';
                            }
                            
                            playerXScoreEl.textContent = playerXScore;
                            playerOScoreEl.textContent = playerOScore;
                    
                            if (needsSave) {
                                await setDoc(scoreDocRef, dataToSave, { merge: true });
                            }

                            userProfile.displayName = player1Name;
                            updateUIforUser();
                            startRewardTimer();
                            
                        }, (error) => {
                            console.error("Error listening to user scores:", error);
                            playerXScore = 0; playerOScore = 0;
                            currentHearts = STARTING_HEARTS;
                            winStreak = 0;
                            updateUIforUser();
                        });
                    }
                    async function saveAllData() {
                        if (saveDebounceTimer) {
                            clearTimeout(saveDebounceTimer);
                        }
                    
                        saveDebounceTimer = setTimeout(async () => {
                            if (!isAuthReady || !userProfile.uid) {
                                console.warn("Firestore not ready or UID missing. Skipping data save.");
                                saveDebounceTimer = null;
                                return;
                            }
                            try {
                                const scoreDocRef = getScoreDocRef(userProfile.uid);
                                
                                const data = {
                                    x: playerXScore,
                                    o: playerOScore,
                                    hearts: currentHearts,
                                    nextRewardTimestamp: nextRewardTimestamp,
                                    playerXIcon: playerXIcon, 
                                    unlockedIcons: unlockedIcons, 
                                    winStreak: winStreak, 
                                    displayName: player1Name, 
                                    gameSettings: gameSettings,
                                    lastUpdated: new Date()
                                };
                                await setDoc(scoreDocRef, data, { merge: true });
                            } catch (e) {
                                console.error("Error saving data to Firestore:", e);
                            } finally {
                                saveDebounceTimer = null;
                            }
                        }, 2000);
                    }
                    function updateHeartsUI() {
                        heartCountEl.textContent = `${currentHearts}`;
                        
                        const now = Date.now();
                        const timeRemaining = nextRewardTimestamp - now;
                        if (currentHearts >= FREE_REWARD_CAP) {
                            collectRewardBtnTop.disabled = true;
                            collectRewardBtnTop.querySelector('span').textContent = 'Hearts Full';
                            collectRewardBtnTop.classList.add('opacity-50');
                            return;
                        }
                        if (timeRemaining <= 0) {
                            collectRewardBtnTop.disabled = false;
                            collectRewardBtnTop.querySelector('span').textContent = 'Collect Reward';
                            collectRewardBtnTop.classList.remove('opacity-50');
                        } else {
                            collectRewardBtnTop.disabled = true;
                            const totalSeconds = Math.floor(timeRemaining / 1000);
                            const hours = Math.floor((totalSeconds / 3600));
                            const minutes = Math.floor((totalSeconds % 3600) / 60);
                            const seconds = totalSeconds % 60;
                            const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                            collectRewardBtnTop.querySelector('span').textContent = formattedTime;
                            collectRewardBtnTop.classList.add('opacity-50');
                        }
                    }
                    function startRewardTimer() {
                        clearInterval(rewardTimerInterval);
                        updateHeartsUI();
                        rewardTimerInterval = setInterval(() => {
                            updateHeartsUI();
                            if (currentHearts >= FREE_REWARD_CAP || (nextRewardTimestamp <= Date.now() && !collectRewardBtnTop.disabled)) {
                                clearInterval(rewardTimerInterval);
                            }
                        }, 1000);
                    }
                    collectRewardBtnTop.addEventListener('click', async () => {
                        if (currentHearts >= FREE_REWARD_CAP || nextRewardTimestamp > Date.now() || collectRewardBtnTop.disabled) {
                            showNotification('Reward not ready or hearts are full!', 'info');
                            return;
                        }
                        currentHearts = currentHearts + REWARD_AMOUNT;
                        nextRewardTimestamp = Date.now() + REWARD_INTERVAL;
                        await saveAllData();
                        showNotification(`${REWARD_AMOUNT} Hearts collected!`, 'success');
                        updateHeartsUI();
                        startRewardTimer();
                    });
                    async function initializeFirebase() {
                        try {
                            const canvasConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
                            
                            const updatedFallbackConfig = {
                                apiKey: "AIzaSyBUZ-U_NrrqLs5IHjT3QiJUI9UeYeknDQM",
                                authDomain: "tic-tac-game-92b57.firebaseapp.com",
                                databaseURL: "https://tic-tac-game-92b57-default-rtdb.firebaseio.com/",
                                projectId: "tic-tac-game-92b57",
                                storageBucket: "tic-tac-game-92b57.appspot.com",
                                messagingSenderId: "426567158009",
                                appId: "1:426567158009:web:c086438883e025ff75f85b" 
                            };
                            
                            const firebaseConfig = canvasConfig && canvasConfig.projectId ? canvasConfig : updatedFallbackConfig;
                            if (!firebaseConfig.projectId) {
                                console.error("Firebase config is missing. Cannot initialize Firestore/Auth.");
                                await handleAuth(null); 
                                loadingOverlay.classList.add('hidden'); 
                                return;
                            }
                            app = initializeApp(firebaseConfig);
                            db = getFirestore(app);
                            rtdb = getDatabase(app); 
                            auth = getAuth(app);
                            setLogLevel('debug'); 
                            onAuthStateChanged(auth, async (user) => {
                                isAuthReady = true;
                                loadingOverlay.classList.add('hidden');
                                await handleAuth(user);
                            });
                            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                            if (initialAuthToken) {
                                signInWithCustomToken(auth, initialAuthToken).catch(error => {
                                    console.warn("Custom token sign-in failed, falling back to anonymous:", error.message);
                                    signInAnonymously(auth).catch(async anonError => { 
                                         console.error("Anonymous Sign-in failed after token failure:", anonError);
                                         loadingOverlay.classList.add('hidden'); 
                                         await handleAuth(null); 
                                    });
                                });
                            } else {
                                signInAnonymously(auth).catch(async anonError => {
                                     console.error("Initial Anonymous Sign-in failed:", anonError);
                                     loadingOverlay.classList.add('hidden'); 
                                     await handleAuth(null); 
                                });
                            }
                        } catch (e) {
                            console.error("Firebase Initialization Failed:", e);
                            loadingOverlay.classList.add('hidden');
                            await handleAuth(null); 
                        }
                    }
                    async function handleAuth(user) {
                        if (unsubscribeUserScoresListener) unsubscribeUserScoresListener();
                        
                        if (user) {
                            const loadedUID = localStorage.getItem('ticTacToeLoadedUID');
                            
                            let effectiveUID;
                            if (loadedUID) {
                                effectiveUID = loadedUID;
                            } else {
                                effectiveUID = user.uid;
                            }
                            
                            userProfile = {
                                uid: effectiveUID,
                                displayName: 'Play',
                                isGuest: user.isAnonymous,
                                pendingPenaltyMessage: null
                            };
                            
                            await listenToUserScores(effectiveUID);
                            setupPresence(effectiveUID); 
                            
                            userProfile.displayName = player1Name; 
                            
                            updateUIforUser(); 
                            startRewardTimer(); 
                            
                            const playedOnce = localStorage.getItem('ticTacToePlayedOnce') === 'true';
                            if (playedOnce) {
                                showScreen(arcadeNexusScreen);
                            } else {
                                showScreen(loginScreen);
                            }
                        } else {
                            userProfile = { uid: null, displayName: 'Play', isGuest: true };
                            updateUIforUser();
                            showScreen(loginScreen); 
                        }
                        try { lucide.createIcons(); } catch(e) { console.error("Lucide icon creation failed:", e); }
                    }
                    
                    function setupPresence(userId) {
                        if (!rtdb) return; 
                        
                        const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                        const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                        const userStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${userId}`);
                        
                        onDisconnect(userStatusRef).set(false).catch((err) => {
                            console.error("RTDB onDisconnect setup failed:", err);
                        });
    
                        set(userStatusRef, true).catch((err) => {
                            console.error("RTDB initial presence set failed:", err);
                        });
                    }

                    function updateUIforUser() {
                        if (userProfile.uid) {
                            const displayUID = userProfile.uid;
                            welcomeMessage.innerHTML = `Welcome, <span style="color: var(--text-dark);">${player1Name}</span><br>
                                <span id="user-uid-display" class="text-xs font-mono cursor-pointer transition-colors hover:text-amber-400"
                                      style="color: var(--text-light);"
                                      title="Click to Copy ID">
                                      Game ID (UID): ${displayUID}
                                </span>`;
                            playerNameInput.value = player1Name;
                            playerNameInput.disabled = false;
                            
                            globalSettingsBtn.classList.add('ml-auto');
                            
                            winStreakCountEl.textContent = winStreak; 
                        } else {
                            welcomeMessage.textContent = 'Welcome, Play';
                            playerNameInput.value = 'Play';
                            playerNameInput.disabled = false;
                            
                            globalSettingsBtn.classList.add('ml-auto');
                            
                            winStreakCountEl.textContent = 0; 
                        }
                        
                        applyTheme(gameSettings.gameMode === 'pva' ? 'pva' : 'pvp');
                        
                        playerXScoreEl.textContent = playerXScore;
                        playerOScoreEl.textContent = playerOScore;
                        updateHeartsUI(); 
                        renderIconCustomization(); 
                        if (customizationPlayerTitle) customizationPlayerTitle.textContent = `Icon Customization (${player1Name})`;
                    }
                    function renderIconCustomization() {
                        if (!iconSelectContainer) return;
                        if (customizationPlayerTitle) customizationPlayerTitle.textContent = `Icon Customization (${player1Name})`;
                        iconSelectContainer.innerHTML = '';
                        Object.entries(ICON_COSTS).forEach(([id, [iconName, cost]]) => {
                            const isUnlocked = unlockedIcons.includes(id);
                            const isSelected = id === playerXIcon;
                            const div = document.createElement('div');
                            div.className = `icon-option bg-gray-700 ${isSelected ? 'selected' : ''}`;
                            div.dataset.id = id;
                            div.dataset.cost = cost;
                            div.dataset.type = 'icon';
                            if (id === 'sparkles') return;
                            if (cost > 0 && !isUnlocked) {
                                div.innerHTML = `<div class="icon-lock"><i data-lucide="lock" class="w-4 h-4 text-white"></i></div>
                                                <span class="icon-cost">${cost} <i data-lucide="heart" class="w-3 h-3 inline-block"></i></span>`;
                                div.classList.add('relative');
                            } else {
                                div.innerHTML = `<i data-lucide="${iconName}" class="text-white"></i>`;
                            }
                            iconSelectContainer.appendChild(div);
                            if (div.querySelector('i')) lucide.createIcons({ nodes: [div] });
                            if (div.querySelector('.icon-cost i')) lucide.createIcons({ nodes: [div.querySelector('.icon-cost i')] });
                        });
                    }
                    
                    if (iconSelectContainer) {
                        iconSelectContainer.addEventListener('click', async (e) => {
                            const target = e.target.closest('.icon-option'); 
                            if (!target || target.classList.contains('icon-lock')) return;
                            const id = target.dataset.id;
                            const cost = parseInt(target.dataset.cost);
                            const isUnlocked = unlockedIcons.includes(id) || cost === 0;
                            if (!isUnlocked) {
                                if (currentHearts >= cost) {
                                    currentHearts -= cost;
                                    unlockedIcons.push(id);
                                    showNotification(`${id} unlocked for ${cost} hearts!`, 'success');
                                    await saveAllData(); 
                                    renderIconCustomization();
                                } else {
                                    showNotification(`Need ${cost - currentHearts} more hearts to unlock!`, 'error');
                                    return;
                                }
                            }
                            playerXIcon = id;
                            document.querySelectorAll('.icon-option').forEach(el => el.classList.remove('selected'));
                            target.classList.add('selected');
                            await saveSettings();
                            updateHeartsUI();
                            updatePlayerIconDisplay('X', playerXIcon, 'cyan');
                        });
                    }
                    
                    playBtn.addEventListener('click', () => {
                        localStorage.setItem('ticTacToePlayedOnce', 'true');
                        showScreen(arcadeNexusScreen);
                    });
                    loadDataBtn.addEventListener('click', async () => {
                         const targetUid = oldGameIdInput.value.trim();
                         if (!targetUid) {
                              showNotification('Please enter a valid Game ID.', 'error');
                              return;
                         }
                         if (targetUid.length < 20) {
                              showNotification('Invalid Game ID format.', 'error');
                              return;
                         }
                         loadDataBtn.disabled = true;
                         
                         if (unsubscribeUserScoresListener) unsubscribeUserScoresListener();
                         await listenToUserScores(targetUid);
                         
                         loadDataBtn.disabled = false;
                         
                         userProfile.uid = targetUid;
                         userProfile.displayName = player1Name; 
                         localStorage.setItem('ticTacToePlayedOnce', 'true');
                         
                         localStorage.setItem('ticTacToeLoadedUID', targetUid); 
                         
                         showNotification(`Data loaded successfully for ID: ${targetUid.substring(0, 8)}...`, 'success');
                         showScreen(arcadeNexusScreen);
                         updateUIforUser();
                         startRewardTimer();
                         oldGameIdInput.value = '';
                    });
                    logoutBtn.addEventListener('click', () => {
                        localStorage.removeItem('ticTacToePlayedOnce');
                        
                        localStorage.removeItem('ticTacToeLoadedUID'); 
                        
                        if (auth) {
                            signOut(auth).catch(error => {
                                console.error("Sign-out failed:", error);
                                showNotification('Logout failed.', 'error');
                            });
                        }
                    });
                    document.addEventListener('click', (e) => {
                        if (e.target.id === 'user-uid-display' && userProfile.uid) {
                            e.preventDefault();
                            copyTextToClipboard(userProfile.uid);
                        }
                    });
                    playerNameInput.addEventListener('input', () => {
                        const newName = playerNameInput.value.trim().substring(0, 10) || 'Play';
                        player1Name = newName;
                        userProfile.displayName = newName;
                        if(userProfile.uid) saveAllData();
                        welcomeMessage.innerHTML = `Welcome, <span style="color: var(--text-dark);">${player1Name}</span><br>
                                <span id="user-uid-display" class="text-xs font-mono cursor-pointer transition-colors hover:text-amber-400"
                                      style="color: var(--text-light);"
                                      title="Click to Copy ID">
                                      Game ID (UID): ${userProfile.uid}
                                </span>`;
                    });
                    loadSettings();
                    initializeFirebase(); 
                    selectTttBtn.addEventListener('click', () => {
                        hideScreen(arcadeNexusScreen, () => {
                            document.querySelector('input[name="game-mode"][value="pvp"]').checked = true;
                            document.querySelector('input[name="game-mode"]:checked').dispatchEvent(new Event('change'));
                            showScreen(mainMenuScreen);
                            renderIconCustomization(); 
                        });
                    });
                    selectAiBtn.addEventListener('click', () => {
                        hideScreen(arcadeNexusScreen, () => {
                            document.querySelector('input[name="game-mode"][value="pva"]').checked = true;
                            document.querySelector('input[name="game-mode"]:checked').dispatchEvent(new Event('change'));
                            showScreen(mainMenuScreen);
                            renderIconCustomization(); 
                        });
                    });
                    ftfBtn.addEventListener('click', () => {
                        ftfModal.classList.remove('hidden');
                        ftfModal.classList.remove('animate-fade-out-scale-down');
                        ftfModal.classList.add('animate-fade-in-scale-up');
                        showFtfView('selection');
                    });
                    ftfCloseBtn.addEventListener('click', async () => {
                        if (currentRoomId && myPlayerMark) {
                            
                             await cancelRoom();
                        }
                        hideScreen(ftfModal);
                    });
                    
                    cancelRoomBtn.addEventListener('click', async () => {
                        await cancelRoom();
                        showFtfView('selection');
                    });
                    backToSelectionBtn.addEventListener('click', () => {
                         showFtfView('selection');
                    });
                    createRoomSelectBtn.addEventListener('click', () => {
                        if (isCreatingRoom) {
                            showNotification('Request in progress... please wait.', 'info');
                            return;
                        }
                        
                        if (currentHearts < Math.abs(FTF_CREATE_COST)) {
                            showNotification(`Not enough hearts! Need ${Math.abs(FTF_CREATE_COST)} heart to create a room.`, 'error');
                            return;
                        }
                        
                        isCreatingRoom = true;
                        setTimeout(() => { isCreatingRoom = false; }, 10000); 
                        
                        showFtfView('create');
                        createRoom();
                    });
                    joinRoomSelectBtn.addEventListener('click', () => {
                        showFtfView('join');
                    });
                    joinRoomInput.addEventListener('input', () => {
                        joinRoomInput.value = joinRoomInput.value.toUpperCase();
                        joinRoomSubmitBtn.disabled = joinRoomInput.value.trim().length !== 6;
                    });
                    joinRoomSubmitBtn.addEventListener('click', () => {
                        const code = joinRoomInput.value.trim().toUpperCase();
                        if (code.length === 6) {
                            joinRoom(code);
                        }
                    });
                    copyRoomCodeBtn.addEventListener('click', () => {
                         const code = roomCodeDisplay.textContent;
                         if (code && code !== 'LOADING...') {
                              copyTextToClipboard(code);
                         } else {
                              showNotification('Room code is not yet ready.', 'info');
                         }
                    });
                    function showFtfView(view) {
                        [ftfSelectionView, ftfCreateView, ftfJoinView].forEach(v => v.classList.add('hidden'));
                        ftfModal.querySelector('#ftf-title').textContent = 'PLAY WITH FRIENDS';
                        if (view === 'selection') {
                            ftfSelectionView.classList.remove('hidden');
                        } else if (view === 'create') {
                            ftfCreateView.classList.remove('hidden');
                            ftfModal.querySelector('#ftf-title').textContent = 'CREATE ROOM';
                        } else if (view === 'join') {
                            ftfJoinView.classList.remove('hidden');
                            ftfModal.querySelector('#ftf-title').textContent = 'JOIN ROOM';
                            joinRoomInput.value = '';
                            joinRoomSubmitBtn.disabled = true;
                        }
                    }
                    async function createRoom() {
                        if (!userProfile.uid) { 
                            showNotification('Authentication error. Try playing first.', 'error'); 
                            isCreatingRoom = false;
                            return; 
                        }
                        currentRoomId = generateRoomId();
                        roomCodeDisplay.textContent = currentRoomId;
                        const roomDocRef = getRoomDocRef(currentRoomId);
                        const creatorIcon = playerXIcon;
                        const creatorColor = 'cyan'; 
                        try {
                            const initialRoomData = {
                                status: 'waiting',
                                boardSize: 3, 
                                playerXId: userProfile.uid,
                                playerXName: userProfile.displayName,
                                playerXIcon: creatorIcon,
                                playerXColor: creatorColor, 
                                playerOId: '', 
                                playerOName: '', 
                                playerOIcon: null,
                                playerOColor: null,
                                boardState: Array(9).fill(null),
                                currentPlayer: 'X',
                                rematchX: false,
                                rematchO: false,
                                lastUpdated: Date.now()
                            };
                            await setDoc(roomDocRef, initialRoomData);
                            
                            showNotification('Room created. Waiting for opponent.', 'info');
                            myPlayerMark = 'X';
                            listenToRoomState(currentRoomId);
                            currentHearts = Math.max(0, currentHearts + FTF_CREATE_COST);
                            updateHeartsUI();
                            saveAllData();
                        } catch (e) {
                            console.error("Error creating room:", e);
                            showNotification('Failed to create room. Check console/permissions.', 'error');
                            currentRoomId = null;
                            showFtfView('selection');
                            isCreatingRoom = false;
                        }
                    }
                    async function joinRoom(roomId) {
                        if (!userProfile.uid) { showNotification('Authentication error. Try playing first.', 'error'); return; }
                        
                        if (currentHearts < Math.abs(FTF_JOIN_COST)) {
                            showNotification(`Not enough hearts! Need ${Math.abs(FTF_JOIN_COST)} heart to join a room.`, 'error');
                            currentRoomId = null;
                            joinRoomSubmitBtn.disabled = false;
                            return;
                        }
                        
                        currentRoomId = roomId;
                        joinRoomSubmitBtn.disabled = true;
                        const roomDocRef = getRoomDocRef(roomId);
                        try {
                            const docSnap = await getDoc(roomDocRef);
                            if (!docSnap.exists()) {
                                showNotification('Invalid Room Code. Room not found.', 'error');
                                currentRoomId = null;
                                joinRoomSubmitBtn.disabled = false;
                                return;
                            }
                            const roomData = docSnap.data();
                            if (roomData.status !== 'waiting' && roomData.status !== 'playing' ) { 
                                showNotification('Room is already full or game started.', 'error');
                                currentRoomId = null;
                                joinRoomSubmitBtn.disabled = false;
                                return;
                            }
                            if (roomData.playerXId === userProfile.uid) {
                                 showNotification('You are Player X in this room! Starting game.', 'success');
                                 myPlayerMark = 'X';
                                 listenToRoomState(currentRoomId);
                                 return;
                            }
                            if (roomData.playerOId && roomData.playerOId !== userProfile.uid) {
                                 showNotification('Room is already occupied by Player O.', 'error');
                                 currentRoomId = null;
                                 joinRoomSubmitBtn.disabled = false;
                                 return;
                            }
                            let playerOIconCurrent = playerXIcon; 
                            const playerOColorCurrent = 'purple-neon'; 
                            if(playerXIcon === roomData.playerXIcon) {
                                 playerOIconCurrent = 'circle';
                                 showNotification('Icon clash! You were assigned the Circle icon.', 'info');
                            }
                            await updateDoc(roomDocRef, {
                                status: 'playing',
                                playerOId: userProfile.uid,
                                playerOName: userProfile.displayName,
                                playerOIcon: playerOIconCurrent,
                                playerOColor: playerOColorCurrent
                            });
                            
                            currentHearts = Math.max(0, currentHearts + FTF_JOIN_COST);
                            updateHeartsUI();
                            saveAllData();
                            
                            showNotification('Joined room successfully! Starting game.', 'success');
                            myPlayerMark = 'O';
                            listenToRoomState(currentRoomId);
                        } catch (e) {
                            console.error("Error joining room:", e);
                            showNotification('Failed to join room. Check code or connection.', 'error');
                            currentRoomId = null;
                            joinRoomSubmitBtn.disabled = false;
                        }
                    }
                     async function cancelRoom() {
                        
                         if (unsubscribeRoomListener) {
                              unsubscribeRoomListener();
                              unsubscribeRoomListener = null;
                         }
                         if (unsubscribeChatListener) {
                              unsubscribeChatListener();
                              unsubscribeChatListener = null;
                         }
                         if (unsubscribeOpponentPresence) { 
                              unsubscribeOpponentPresence();
                              unsubscribeOpponentPresence = null;
                         }
                         
                         if (chatMessagesContainer) {
                             chatMessagesContainer.innerHTML = '';
                         }
                         
                         isChatPanelOpen = false;
                         if (multiplayerChatPanel) multiplayerChatPanel.classList.remove('open');
                         multiplayerChatPanel.classList.add('hidden');
                         
                         if (currentRoomId) {
                              try {
                                   if (rtdb && userProfile.uid) {
                                       const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                                       const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                                       const userStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${userProfile.uid}`);
                                       
                                       await set(userStatusRef, false);
                                       setupPresence(userProfile.uid); 
                                   }
                                   
                                  
                                   await deleteChatHistory(currentRoomId);
                                   
                                   if (myPlayerMark === 'X') {
                                     
                                       await updateDoc(getRoomDocRef(currentRoomId), {
                                            status: 'abandoned',
                                            winner: 'O' 
                                       });
                                       showNotification('Room abandoned. Opponent wins by forfeit.', 'info');
                                   } else if (myPlayerMark === 'O') { 
                                      
                                        await updateDoc(getRoomDocRef(currentRoomId), {
                                             status: 'abandoned',
                                             winner: 'X' 
                                        });
                                        showNotification('You left the room. Host wins by forfeit.', 'info');
                                   }
                              } catch (e) {
                                   console.error("Error managing room/chat deletion:", e);
                              }
                         }
                         currentRoomId = null;
                         myPlayerMark = null;
                         gameStartedNotified = false; 
                    }
                    
                    async function handleOpponentAbandonment(room) {
                        if (gameEndedNotified) return;
                        gameEndedNotified = true;
                        isGameActive = false;
                    
                        if (unsubscribeRoomListener) {
                            unsubscribeRoomListener();
                            unsubscribeRoomListener = null;
                        }
                        if (unsubscribeChatListener) {
                            unsubscribeChatListener();
                            unsubscribeChatListener = null;
                        }
                        
                        showNotification('Opponent disconnected. Please wait...', 'info');
                        
                        setTimeout(async () => {
                            const winner = myPlayerMark;
                            const leaverMark = (myPlayerMark === 'X') ? 'O' : 'X';
                            const leaverName = (myPlayerMark === 'X') ? (room.playerOName || 'Opponent') : (room.playerXName || 'Host');
                    
                            try {
                                const roomDocRef = getRoomDocRef(currentRoomId);
                                await updateDoc(roomDocRef, {
                                    status: 'abandoned',
                                    winner: winner
                                });
                            } catch (e) { console.error("Failed to update room to 'abandoned'", e); }
                    
                            let heartsChange = FTF_WIN_REWARD;
                    
                            winStreak++;
                            
                            if (winStreak > 0 && winStreak % WIN_STREAK_BONUS_COUNT === 0) {
                                heartsChange += WIN_STREAK_BONUS_AMOUNT;
                                showNotification(`+${WIN_STREAK_BONUS_AMOUNT} Hearts for ${winStreak}-Win Streak!`, 'success');
                            }
                            
                            currentHearts = Math.max(0, currentHearts + heartsChange);
                            if (myPlayerMark === 'X') playerXScore++;
                            else playerOScore++;
                            
                            await saveAllData();
                            updateHeartsUI();
                            
                            mpResultTitle.textContent = " OPPONENT LEFT! ";
                            
                            playerXScoreEl.textContent = playerXScore;
                            playerOScoreEl.textContent = playerOScore;
                    
                            const myName = userProfile.displayName.toUpperCase();
                            const myIcon = (myPlayerMark === 'X') ? playerXIcon : playerOIcon;
                            if (myPlayerMark === 'X') {
                                resultNameX.textContent = myName;
                                resultScoreX.textContent = playerXScore;
                                const iconX = document.createElement('i');
                                iconX.setAttribute('data-lucide', ICON_COSTS[myIcon || 'x'][0]);
                                resultIconX.innerHTML = ''; resultIconX.appendChild(iconX);
                            } else {
                                resultNameO.textContent = myName;
                                resultScoreO.textContent = playerOScore;
                                const iconO = document.createElement('i');
                                iconO.setAttribute('data-lucide', ICON_COSTS[myIcon || 'circle'][0]);
                                resultIconO.innerHTML = ''; resultIconO.appendChild(iconO);
                            }
                    
                            const oppIcon = (myPlayerMark === 'X') ? room.playerOIcon : room.playerXIcon;
                            if (myPlayerMark === 'X') {
                                resultNameO.textContent = leaverName.toUpperCase();
                                resultScoreO.textContent = playerOScore;
                                const iconO = document.createElement('i');
                                iconO.setAttribute('data-lucide', ICON_COSTS[oppIcon || 'circle'][0]);
                                resultIconO.innerHTML = ''; resultIconO.appendChild(iconO);
                            } else {
                                resultNameX.textContent = leaverName.toUpperCase();
                                resultScoreX.textContent = playerXScore;
                                const iconX = document.createElement('i');
                                iconX.setAttribute('data-lucide', ICON_COSTS[oppIcon || 'x'][0]);
                                resultIconX.innerHTML = ''; resultIconX.appendChild(iconX);
                            }
                            lucide.createIcons({ nodes: [resultIconX, resultIconO] });
                    
                            mpStatHearts.textContent = `+${heartsChange} Hearts`;
                            mpStatHearts.className = 'stat-value positive';
                            mpStatWinStreak.textContent = `${winStreak} Wins`;
                            mpStatWinStreak.className = 'stat-value positive';
                    
                            rematchBtn.disabled = true;
                            rematchBtn.textContent = 'GAME OVER';
                            
                            rematchStatusEl.textContent = `${leaverName} disconnected. You win!`;
                            
                            showScreen(multiplayerResultModal);
                    
                        }, 1000); 
                    }
                    
                    function listenToRoomState(roomId) {
                        if (unsubscribeRoomListener) unsubscribeRoomListener();
                        listenToChatState(roomId);
                        
                        unsubscribeRoomListener = onSnapshot(getRoomDocRef(roomId), (doc) => {
                            const room = doc.data();
                            if (!room) {
                                showNotification('Room was deleted by the host.', 'error');
                                goBackFromMultiplayer();
                                return;
                            }
                            
                            const currentStatus = room.status;

                            if (currentStatus === 'waiting') {
                                if (myPlayerMark === 'X') {
                                    
                                    if (!gameScreen.classList.contains('hidden')) {
                                        showNotification('Player O left the room. Returning to Nexus.', 'info');
                                        goBackFromMultiplayer();
                                    } 
                                    else if (!ftfModal.classList.contains('hidden')) {
                                        console.log("Host is waiting for Player O to join.");
                                       
                                        roomCodeDisplay.textContent = currentRoomId;
                                        waitingStatus.classList.remove('hidden');
                                    }
                                    
                                   
                                }
                                else if (myPlayerMark === 'O') {
                                     showNotification('Room reset by host. Returning to menu.', 'error');
                                     goBackFromMultiplayer();
                                }
                                return; 
                            }

                            if (currentStatus === 'playing' && myPlayerMark === 'X') {
                                checkAndEndGameIfNeeded(room);
                            }

                            if (currentStatus === 'playing' || currentStatus === 'finished' || currentStatus === 'abandoned') {
                                const isRematchStarting = currentStatus === 'playing' && !multiplayerResultModal.classList.contains('hidden');
                                const isFirstGameStarting = currentStatus === 'playing' && !ftfModal.classList.contains('hidden');

                                if (isFirstGameStarting) {
                                    hideScreen(ftfModal, () => {
                                        showScreen(gameScreen);
                                        initializeGame(room);
                                    });
                                } else if (isRematchStarting) {
                                    hideScreen(multiplayerResultModal, () => {
                                        initializeGame(room);
                                        showScreen(gameScreen);
                                    });
                                } else {
                                    boardState = room.boardState;
                                    currentPlayer = room.currentPlayer;
                                    isGameActive = (currentStatus === 'playing');
                                    if (!isFirstGameStarting && !isRematchStarting) {
                                         drawBoard(room);
                                         updateTurnStatus();
                                    }
                                }

                                playerXRematch = room.rematchX;
                                playerORematch = room.rematchO;

                                if (currentStatus === 'finished' || currentStatus === 'abandoned') {
                                    if (!gameEndedNotified) {
                                        gameEndedNotified = true;
                                        endGame(room.winner === 'Draw', room.winningLine || [], room.winner, room);
                                    }
                                }

                                if (playerXRematch && playerORematch && currentStatus !== 'playing' && rematchCountdownInterval === null) {
                                    if (!multiplayerResultModal.classList.contains('hidden')) {
                                         startRematchCountdown();
                                    }
                                } else {
                                     if (!multiplayerResultModal.classList.contains('hidden')) {
                                         updateRematchStatusUI();
                                     }
                                }
                            }
                        }, (error) => {
                             console.error("Firestore room listener error:", error);
                             showNotification('Connection lost or room error.', 'error');
                             goBackFromMultiplayer();
                        });
                    }
                    
                    function listenToOpponentPresence(opponentId, room) {
                        if (unsubscribeOpponentPresence) unsubscribeOpponentPresence();
                        if (!rtdb || !opponentId) {
                             console.warn("RTDB listener skipped: DB ya opponentId missing.");
                             return;
                        }
                        
                        const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                        const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                        const opponentStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${opponentId}`);
                        
                        unsubscribeOpponentPresence = onValue(opponentStatusRef, (snapshot) => {
                            const isOnline = snapshot.val();
                            
                            // 1. BUG FIX: Ab 'null' (loading) ko 'false' (offline) nahi samjhega.
                            //    Yeh aapke 'Race Condition' (null value) wale bug ko fix karta hai.
                            if (isOnline === false) {
                                if (gameEndedNotified || !isMultiplayer) return; 
                                
                                console.warn(`Opponent (ID: ${opponentId}) disconnected! (RTDB Presence)`);
                                
                                // 2. BUG FIX: Grace Period 2.5s se barha kar 8s kar diya.
                                //    Yeh 'Micro-Disconnects' (network drops) ko handle karega. (100% Free Solution)
                                setTimeout(async () => {
                                    if (gameEndedNotified || !currentRoomId) return;

                                    try {
                                         const roomDocRef = getRoomDocRef(currentRoomId);
                                         const roomSnap = await getDoc(roomDocRef);
                                         
                                         if (roomSnap.exists()) {
                                            const currentData = roomSnap.data();
                                            
                                            if (currentData.status === 'waiting') {
                                                console.log("Opponent disconnected, but status is 'waiting'. Graceful exit confirmed.");
                                                return;
                                            }
                                            // --------------------------------------------------
                                            // --- YAHAN HAI AAPKA FIX ---
                                            // Agar status 'playing' hai, toh host ko winner banayein
                                            // --------------------------------------------------
                                            else if (currentData.status === 'playing') {
                                                console.log("Opponent disconnected during 'playing' state. Declaring current player as winner.");
                                                handleOpponentAbandonment(currentData);
                                                return; 
                                            }
                                    }
                                } catch (e) { // <-- YEH HAI BUG FIX
                                    console.error("Error checking room status during grace period:", e);
                                }
 
                                }, 6000); // <-- 20s se 6s kar diya (Aapke request ke mutabik)
                                
                              
                            }
                        }, (error) => {
                            console.error("RTDB Presence listener error:", error);
                        });
                    }

                    function listenToChatState(roomId) {
                         if (unsubscribeChatListener) unsubscribeChatListener();
                         if (!chatMessagesContainer) return;
                         chatMessagesContainer.innerHTML = '';
                         chatSendBtn.disabled = true;
                         chatInputField.disabled = true;
                         
                         const chatRef = getChatRoomRef(roomId); 
                         
                         unsubscribeChatListener = onValue(chatRef, (snapshot) => {
                              chatMessagesContainer.innerHTML = '';
                              if (!snapshot.exists()) {
                                  chatMessagesContainer.innerHTML = `<div class="text-sm text-gray-500 text-center py-2">Chat is currently empty</div>`;
                              } else {
                                  snapshot.forEach(childSnapshot => {
                                      const msg = childSnapshot.val();
                                      renderChatMessage(msg);
                                  });
                              }
                              
                              if (!isChatOnCooldown) {
                                   chatSendBtn.disabled = false;
                              }
                              chatInputField.disabled = false;
                              chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
                         }, (error) => {
                             console.error("RTDB chat listener error:", error);
                             chatMessagesContainer.innerHTML = `<div class="text-sm text-red-500 text-center py-2">Chat connection error</div>`;
                         });
                    }
                    
                    function renderChatMessage(msg) {
                        const isMyMessage = msg.senderId === userProfile.uid;
                        const msgEl = document.createElement('div');
                        msgEl.classList.add('chat-message', isMyMessage ? 'my-message' : 'opponent-message');
                        const senderName = isMyMessage ? 'You' : (msg.senderName || 'Opponent');
                        const time = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'now';
                        
                        const senderEl = document.createElement('p');
                        senderEl.className = 'chat-sender';
                        senderEl.textContent = `${senderName}:`;
                        
                        const textEl = document.createElement('p');
                        textEl.className = 'chat-text whitespace-normal break-words';
                        textEl.textContent = msg.text;
                        
                        const timeEl = document.createElement('span');
                        timeEl.className = 'chat-time';
                        timeEl.textContent = time;

                        msgEl.innerHTML = '';
                        msgEl.appendChild(senderEl);
                        msgEl.appendChild(textEl);
                        msgEl.appendChild(timeEl);
                        
                        chatMessagesContainer.appendChild(msgEl);
                        chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
                        
                        if (gameScreen.classList.contains('hidden') === false) {
                             const messageToShow = `${senderName}: ${msg.text}`;
                             showNotification(messageToShow, 'info', true);
                        }
                    }
                    
                    async function sendChatMessage() {
                        if (!isAuthReady || !currentRoomId || chatInputField.disabled) return;
                        
                        if (isChatOnCooldown) {
                             showNotification('Bohot jaldi chat mat karo! (Chat too fast!)', 'info');
                             return;
                        }
                        
                        const text = chatInputField.value.trim();
                        if (!text) return;
                        
                        isChatOnCooldown = true;
                        chatSendBtn.disabled = true;
                        
                        let timeoutId = setTimeout(() => {
                            isChatOnCooldown = false;
                            if (!chatInputField.disabled) {
                                chatSendBtn.disabled = false; 
                            }
                        }, CHAT_COOLDOWN_MS); 
                        
                        const message = {
                            senderId: userProfile.uid,
                            senderName: userProfile.displayName,
                            text: text,
                            timestamp: Date.now()
                        };
                        
                        try {
                            const chatRef = getChatRoomRef(currentRoomId); 
                            await push(chatRef, message);
                            chatInputField.value = '';
                        } catch (e) {
                            console.error("Error sending RTDB chat message:", e);
                            showNotification('Failed to send message.', 'error');
                            chatInputField.value = text;
                            
                            clearTimeout(timeoutId);
                            isChatOnCooldown = false;
                            chatSendBtn.disabled = false;
                        } finally {
                            chatInputField.focus();
                        }
                    }
                    
                  
                    async function deleteChatHistory(roomId) {
                        if (!rtdb || !roomId) return;
                        try {
                             const chatRef = getChatRoomRef(roomId); 
                             await remove(chatRef); 
                             console.log(`RTDB Chat history deleted for room: ${roomId}`);
                        } catch (e) {
                             console.error(`Failed to delete RTDB chat history for room ${roomId}:`, e);
                        }
                    }
                    
                    chatSendBtn.addEventListener('click', sendChatMessage);
                    chatInputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !chatSendBtn.disabled) {
                            sendChatMessage();
                        }
                    });
                    
                    chatToggleButton.addEventListener('click', () => {
                         if (!isMultiplayer && !currentRoomId) {
                              showNotification('Chat is only available in Play with Friends mode.', 'info');
                              return;
                         }
                         isChatPanelOpen = !isChatPanelOpen;
                         if (window.innerWidth >= 1024) {
                             multiplayerChatPanel.classList.toggle('hidden', !isChatPanelOpen);
                             if (!multiplayerChatPanel.classList.contains('hidden')) {
                                 chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
                             }
                             return;
                         }
                         if (isChatPanelOpen) {
                             multiplayerChatPanel.classList.remove('hidden');
                             requestAnimationFrame(() => {
                                 multiplayerChatPanel.classList.add('open');
                             });
                             setTimeout(() => {
                                 chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
                                 try { chatInputField.focus(); } catch (e) {}
                             }, 220);
                         } else {
                             multiplayerChatPanel.classList.remove('open');
                             setTimeout(() => { if (!multiplayerChatPanel.classList.contains('open')) multiplayerChatPanel.classList.add('hidden'); }, 300);
                         }
                    });
                    
                    async function goBackFromMultiplayer() {
                        
                         if (unsubscribeRoomListener) unsubscribeRoomListener();
                         if (unsubscribeChatListener) unsubscribeChatListener(); 
                         if (unsubscribeOpponentPresence) { 
                            unsubscribeOpponentPresence();
                            unsubscribeOpponentPresence = null;
                         }
                         
                         if (rtdb && userProfile.uid) {
                             const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                             const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                             const userStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${userProfile.uid}`);
                             
                             await set(userStatusRef, false);
                             setupPresence(userProfile.uid);
                         }
                         
                         clearInterval(rematchCountdownInterval); 
                         clearInterval(rewardTimerInterval); 
                         isMultiplayer = false;
                         currentRoomId = null;
                         myPlayerMark = null;
                         playerXRematch = false;
                         playerORematch = false;
                         gameStartedNotified = false; 
                         lastKnownStateFingerprint = null; 
                         
                         isChatPanelOpen = false; 
                         hideScreen(multiplayerResultModal); 
                         showScreen(arcadeNexusScreen);
                         multiplayerChatPanel.classList.add('hidden'); 
                    }
                    
                    function resetBoardVisuals() {
                         gameBoardContainer.querySelectorAll('.game-cell').forEach(cell => {
                             cell.classList.remove('winning-cell', 'ai-tip-highlight', 'cell-bounce-in', 'blocked');
                             cell.classList.remove('player-x', 'player-o'); 
                             cell.innerHTML = '';
                             cell.dataset.mark = '';
                             cell.style.opacity = '1';
                         });
                    }

                    function drawBoard(roomData) {
                        const existingCells = gameBoardContainer.querySelectorAll('.game-cell');
                        const requiredCells = roomData.boardSize * roomData.boardSize;
                        if (existingCells.length !== requiredCells) {
                            gameBoardContainer.innerHTML = '';
                            gameBoardContainer.style.gridTemplateColumns = `repeat(${roomData.boardSize}, 1fr)`;
                            for (let i = 0; i < requiredCells; i++) {
                                const cell = document.createElement('div');
                                cell.classList.add('game-cell');
                                cell.dataset.index = i;
                                cell.dataset.mark = '';
                                gameBoardContainer.appendChild(cell);
                            }
                        }
                        const myMark = myPlayerMark; 
                        const opponentMark = myMark === 'X' ? 'O' : 'X';
                        const isMyTurn = roomData.currentPlayer === myMark;
                        
                        const pXData = (myMark === 'X') ? { ...roomData, name: userProfile.displayName } : roomData;
                        const pOData = (myMark === 'X') ? roomData : { ...roomData, name: userProfile.displayName };
                        
                        const playerXDisplayData = pXData; 
                        const playerODisplayData = pOData; 
                        playerXNameEl.textContent = playerXDisplayData.playerXName.toUpperCase(); 
                        updatePlayerIconDisplay('X', playerXDisplayData.playerXIcon, playerXDisplayData.playerXColor); 
                        playerXProfile.classList.toggle('active-turn', isMyTurn);
                        
                        playerONameEl.textContent = playerODisplayData.playerOName.toUpperCase() || 'OPPONENT'; 
                        updatePlayerIconDisplay('O', playerODisplayData.playerOIcon, playerODisplayData.playerOColor); 
                        playerOProfile.classList.toggle('active-turn', !isMyTurn);
                        if (isMultiplayer && !gameStartedNotified) {
                            showNotification(`You are Player ${myMark}. Opponent is Player ${opponentMark}.`, 'info');
                            gameStartedNotified = true; 
                        }
                        
                        const iconsToCreate = [];
                        
                        gameBoardContainer.querySelectorAll('.game-cell').forEach((cell, index) => {
                            const mark = roomData.boardState[index];
                            const currentMark = cell.dataset.mark || null; 
                            cell.classList.remove('processing', 'ai-tip-highlight');
                            cell.style.opacity = '1';
                            
                            if ((!currentMark || currentMark === '') && !mark) {
                                cell.innerHTML = '';
                                cell.classList.remove('player-x', 'player-o', 'winning-cell', 'cell-bounce-in', 'blocked');
                                cell.dataset.mark = '';
                                return;
                            }
                            
                            if (currentMark === mark) {
                                 if (roomData.winningLine && roomData.winningLine.includes(index)) {
                                      cell.classList.add('winning-cell');
                                 } else {
                                     cell.classList.remove('winning-cell');
                                 }
                                 return;
                            }
                            
                            cell.dataset.mark = mark || ''; 
                            cell.innerHTML = ''; 
                            cell.classList.remove('player-x', 'player-o', 'winning-cell', 'cell-bounce-in', 'blocked');
                            if (mark) {
                                 cell.classList.add(`player-${mark.toLowerCase()}`);
                                 
                                 const iconId = (mark === 'X') ? (roomData.playerXIcon || 'x') : (roomData.playerOIcon || 'circle');
                                 const iconName = ICON_COSTS[iconId] ? ICON_COSTS[iconId][0] : iconId;
                                 const iconEl = document.createElement('i');
                                 iconEl.setAttribute('data-lucide', iconName);
                                 cell.appendChild(iconEl);
                                 iconsToCreate.push(iconEl);
                                 cell.classList.add('cell-bounce-in'); 
                                 if (roomData.winningLine && roomData.winningLine.includes(index)) {
                                      cell.classList.add('winning-cell');
                                 }
                            }
                        });
                        
                        if (iconsToCreate.length > 0) {
                            lucide.createIcons({ nodes: iconsToCreate });
                        }
                        
                         aiTipBtn.classList.add('hidden');
                         blockerPowerupBtn.classList.add('hidden');
                    }
                    function initializeGame(room = null) {
                        gameEndedNotified = false;
                        lastKnownStateFingerprint = null;
                        isChatPanelOpen = false;
                        resetBoardVisuals(); 
    
                        if (room) {
                            applyTheme('multiplayer');
                            isMultiplayer = true;
                            boardSize = room.boardSize;
                            
                            mpPlayerXData = { id: room.playerXId, name: room.playerXName, icon: room.playerXIcon, color: room.playerXColor };
                            mpPlayerOData = { id: room.playerOId, name: room.playerOName, icon: room.playerOIcon, color: room.playerOColor };
                            opponentName = (myPlayerMark === 'X') ? mpPlayerOData.name : mpPlayerXData.name;
                            
                            playerXIcon = room.playerXIcon;
                            playerXColor = room.playerXColor;
                            playerOIcon = room.playerOIcon;
                            playerOColor = room.playerOColor;
                            boardState = room.boardState;
                            currentPlayer = room.currentPlayer;
                            isGameActive = (room.status === 'playing');
                            playerXScoreEl.textContent = playerXScore;
                            playerOScoreEl.textContent = playerOScore;
                            
                            const opponentId = (myPlayerMark === 'X') ? mpPlayerOData.id : mpPlayerXData.id;
                            listenToOpponentPresence(opponentId, room);
                            
                            aiTipBtn.classList.add('hidden');
                            blockerPowerupBtn.classList.add('hidden');
                            
                            chatToggleButton.classList.remove('hidden');
                            aiTipBtnMobile.classList.add('hidden');
                            blockerPowerupBtnMobile.classList.add('hidden');
                            
                            gameBoardContainer.className = 'game-board-container';
                            gameBoardContainer.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
                            drawBoard(room);
                            updateTurnStatus();
                            
                            if(window.innerWidth >= 1024) multiplayerChatPanel.classList.remove('hidden');
                            return;
                        }
                        isMultiplayer = false;
                        
                        const isPVA = gameSettings.gameMode === 'pva';
                        applyTheme(isPVA ? 'pva' : 'pvp');
                        chatToggleButton.classList.add('hidden');
                        multiplayerChatPanel.classList.add('hidden');
                        gameStartTime = new Date();
                        moveCount = 0;
                        isGameActive = true;
                        boardSize = gameSettings.boardSize; 
                        boardState = Array(boardSize * boardSize).fill(null);
                        moveHistory = [];
                        blockerCountX = 1;
                        blockerCountO = 1;
                        isBlockerActive = false;
                        currentPlayer = humanPlayer;
                        playerXNameEl.textContent = player1Name.toUpperCase();
                        if (isPVA) {
                            const personality = AI_PERSONALITIES[gameSettings.aiDifficulty] || AI_PERSONALITIES.medium;
                            playerONameEl.textContent = personality.name; 
                        } else {
                            playerONameEl.textContent = 'PLAYER 2';
                        }
                        updatePlayerIconDisplay('X', playerXIcon, 'cyan');
                        updatePlayerIconDisplay('O', 'sparkles', 'purple-neon');
                        gameBoardContainer.innerHTML = '';
                        gameBoardContainer.className = 'game-board-container';
                        gameBoardContainer.classList.add(`board-size-${boardSize}`);
                        gameBoardContainer.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
                        for (let i = 0; i < boardSize * boardSize; i++) {
                            const cell = document.createElement('div');
                            cell.classList.add('game-cell');
                            cell.dataset.index = i;
                            cell.dataset.mark = '';
                            gameBoardContainer.appendChild(cell);
                        }
                        const showBlocker = (gameSettings.gameVariant === 'blocker');
                        
                        aiTipBtn.classList.toggle('hidden', !isPVA);
                        aiTipBtnMobile.classList.toggle('hidden', !isPVA);
                        
                        blockerPowerupBtn.classList.toggle('hidden', !showBlocker || !isPVA);
                        blockerPowerupBtnMobile.classList.toggle('hidden', !showBlocker || !isPVA);
                        
                        if (isPVA) {
                            const canAffordTip = currentHearts >= AI_TIP_COST;
                            aiTipBtn.disabled = !canAffordTip;
                            aiTipBtnMobile.disabled = !canAffordTip;
                        }
                        updateTurnStatus();
                        confettiContainer.innerHTML = '';
                    }
                    gameBoardContainer.addEventListener('click', handleCellClick);
                    
                    function handleCellClick(event) {
                        if (!isGameActive) return;
                        
                        const clickedCell = event.target.closest('.game-cell');
                        if (!clickedCell) return;
                        const clickedIndex = parseInt(clickedCell.dataset.index);
                        if (isNaN(clickedIndex)) return;
                        
                        if (clickedCell.dataset.mark || clickedCell.classList.contains('processing')) {
                            playSound(invalidSound, 'C3', '0.1');
                            clickedCell.classList.add('shake');
                            setTimeout(() => clickedCell.classList.remove('shake'), 300);
                            return;
                        }
                        
                        if (isMultiplayer) {
                             if (currentPlayer !== myPlayerMark) {
                                  showNotification("Wait for your opponent's turn.", 'info');
                                  return;
                             }
                             
                             isGameActive = false;
                             gameBoardContainer.classList.add('ai-thinking');
                             
                             placeMark(clickedCell, clickedIndex); 
                             
                             syncMoveToFirestore(clickedIndex, clickedCell);
                             
                             return;
                        }
                        if (isBlockerActive) {
                            placeBlock(clickedCell, clickedIndex, currentPlayer);
                            isBlockerActive = false;
                            gameBoardContainer.classList.remove('blocker-active');
                            blockerPowerupBtn.classList.remove('active');
                            blockerPowerupBtnMobile.classList.remove('active');
                            if (checkEndCondition()) return;
                            switchPlayer();
                            if (gameSettings.gameMode === 'pva' && currentPlayer === aiPlayer) aiMove();
                            return;
                        }
                        if (gameSettings.gameMode === 'pva' && currentPlayer !== humanPlayer) return;
                        if (window.navigator.vibrate) window.navigator.vibrate(50);
                        if (gameSettings.gameMode === 'pvp') {
                            clearInterval(turnTimer);
                        }
                        placeMark(clickedCell, clickedIndex);
                        if (checkEndCondition()) return;
                        switchPlayer();
                        if (gameSettings.gameMode === 'pva' && currentPlayer === aiPlayer && isGameActive) {
                            aiMove();
                        }
                    }
                    async function syncMoveToFirestore(index, cell) {
                         if (isMoveOnCooldown) return; 
                         isMoveOnCooldown = true;
                         try {
                             let retries = 0;
                             const maxRetries = 2;
                             let success = false;
                     
                             while (retries <= maxRetries && !success) {
                                 try {
                                     await runTransaction(db, async (transaction) => {
                                          const roomDoc = await transaction.get(getRoomDocRef(currentRoomId));
                                          if (!roomDoc.exists()) { throw new Error("Room doesn't exist."); }
                                          
                                          const roomData = roomDoc.data();
                                          if (roomData.status !== 'playing') { throw new Error("Game is not active."); }
                                          if (roomData.currentPlayer !== myPlayerMark) { throw new Error("Not your turn."); }
                                          if (roomData.boardState[index] !== null) { throw new Error("Cell already taken."); }
                                          
                                          const newBoardState = [...roomData.boardState];
                                          newBoardState[index] = myPlayerMark;
                                          const newCurrentPlayer = (myPlayerMark === 'X') ? 'O' : 'X';
                                          
                                          transaction.update(getRoomDocRef(currentRoomId), {
                                              boardState: newBoardState,
                                              currentPlayer: newCurrentPlayer,
                                              lastUpdated: Date.now()
                                          });
                                     });
                                     success = true;
                                 } catch (e) {
                                     if (retries < maxRetries && e.code === 'aborted') {
                                         retries++;
                                         showNotification(`Conflict detected. Retrying move (${retries}/${maxRetries})...`, 'info');
                                         await new Promise(res => setTimeout(res, 600 * retries));
                                     } else {
                                         throw e;
                                     }
                                 }
                             }
                         } catch (e) {
                              console.error("Move sync transaction failed:", e.message);
                              showNotification(e.message || "Invalid move. Board desynced.", 'error');
                              cell.classList.remove('processing'); 
                              cell.style.opacity = '1'; 
                         } finally {
                              setTimeout(() => { isMoveOnCooldown = false; }, MOVE_COOLDOWN_MS);
                         }
                    }
                    function placeMark(cell, index) {
                        const mark = currentPlayer;
                        boardState[index] = mark;
                        cell.dataset.mark = mark;
                        cell.classList.add(`player-${mark.toLowerCase()}`);
                        
                        let iconId;
                        if (isMultiplayer) {
                            iconId = (mark === 'X') ? mpPlayerXData.icon : mpPlayerOData.icon;
                        } else {
                            iconId = (mark === 'X') ? playerXIcon : (gameSettings.gameMode === 'pva' ? 'sparkles' : 'circle');
                        }
                        
                        const iconName = ICON_COSTS[iconId] ? ICON_COSTS[iconId][0] : iconId;
                        const iconEl = document.createElement('i');
                        iconEl.setAttribute('data-lucide', iconName);
                        cell.innerHTML = '';
                        cell.appendChild(iconEl);
                        lucide.createIcons({ nodes: [iconEl] });
                        cell.classList.add('cell-bounce-in');
                        moveHistory.push({ index, player: mark, type: 'mark' });
                        moveCount++;
                        playSound(clickSound, (mark === 'X' ? 'C5' : 'E5'), '0.05');
                    }
                    function switchPlayer() {
                        currentPlayer = (currentPlayer === 'X') ? 'O' : 'X';
                        updateTurnStatus();
                    }
                    function updateTurnStatus() {
                        if (!isGameActive && !isMultiplayer) return;
                        
                        let isMyTurn, statusText;
                        
                        if (isMultiplayer) {
                            isGameActive = (currentPlayer === myPlayerMark);
                            gameBoardContainer.classList.toggle('ai-thinking', !isGameActive);
                            
                            isMyTurn = (currentPlayer === myPlayerMark);
                            statusText = isMyTurn ? "YOUR TURN" : (opponentName.toUpperCase() + "'S TURN");
                        } else {
                            isMyTurn = (currentPlayer === humanPlayer);
                            if (gameSettings.gameMode === 'pva') {
                                const personality = AI_PERSONALITIES[gameSettings.aiDifficulty] || AI_PERSONALITIES.medium;
                                statusText = isMyTurn ? "YOUR TURN" : personality.thinking;
                            } else {
                                statusText = `PLAYER ${currentPlayer}'S TURN`;
                            }
                        }
                        
                        gameStatusDisplay.textContent = statusText;
                        playerXProfile.classList.toggle('active-turn', currentPlayer === 'X');
                        playerOProfile.classList.toggle('active-turn', currentPlayer === 'O');
                        
                        const isPVA = gameSettings.gameMode === 'pva';
                        const showBlockerPVA = (gameSettings.gameVariant === 'blocker') && isPVA;
                        
                        blockerPowerupBtn.classList.toggle('hidden', !showBlockerPVA);
                        blockerPowerupBtnMobile.classList.toggle('hidden', !showBlockerPVA);
                        
                        aiTipBtn.classList.toggle('hidden', !isPVA);
                        aiTipBtnMobile.classList.toggle('hidden', !isPVA);
                        if (isPVA) {
                            const canAffordTip = currentHearts >= AI_TIP_COST;
                            aiTipBtn.disabled = !canAffordTip || !isMyTurn;
                            aiTipBtnMobile.disabled = !canAffordTip || !isMyTurn;
                            updateBlockerButton();
                        }
                    }
                    function checkWin(board, player) {
                        const size = boardSize;
                        const flatBoard = board;
                        for (let r = 0; r < size; r++) {
                            let line = [];
                            let won = true;
                            for (let c = 0; c < size; c++) {
                                const index = r * size + c;
                                line.push(index);
                                if (flatBoard[index] !== player) { won = false; break; }
                            }
                            if (won) return { won: true, line };
                        }
                        for (let c = 0; c < size; c++) {
                            let line = [];
                            let won = true;
                            for (let r = 0; r < size; r++) {
                                const index = r * size + c;
                                line.push(index);
                                if (flatBoard[index] !== player) { won = false; break; }
                            }
                            if (won) return { won: true, line };
                        }
                        let diag1 = [];
                        let wonDiag1 = true;
                        for (let i = 0; i < size; i++) {
                            const index = i * size + i;
                            diag1.push(index);
                            if (flatBoard[index] !== player) { wonDiag1 = false; break; }
                        }
                        if (wonDiag1) return { won: true, line: diag1 };
                        let diag2 = [];
                        let wonDiag2 = true;
                        for (let i = 0; i < size; i++) {
                            const index = i * size + (size - 1 - i);
                            diag2.push(index);
                            if (flatBoard[index] !== player) { wonDiag2 = false; break; }
                        }
                        if (wonDiag2) return { won: true, line: diag2 };
                        return { won: false, line: [] };
                    }
                    
                    async function checkAndEndGameIfNeeded(room) {
                        if (!room || room.status !== 'playing' || myPlayerMark !== 'X') return;

                        const winInfoX = checkWin(room.boardState, 'X');
                        const winInfoO = checkWin(room.boardState, 'O');
                        const isDraw = checkDraw(room.boardState);

                        let newStatus = 'playing';
                        let winner = null;
                        let winningLine = [];

                        if (winInfoX.won) {
                            newStatus = 'finished';
                            winner = 'X';
                            winningLine = winInfoX.line;
                        } else if (winInfoO.won) {
                            newStatus = 'finished';
                            winner = 'O';
                            winningLine = winInfoO.line;
                        } else if (isDraw) {
                            newStatus = 'finished';
                            winner = 'Draw';
                        }

                        if (newStatus === 'finished') {
                            try {
                                await updateDoc(getRoomDocRef(currentRoomId), {
                                    status: newStatus,
                                    winner: winner,
                                    winningLine: winningLine,
                                    lastUpdated: Date.now()
                                });
                            } catch (e) {
                                console.error("Error updating game end status:", e);
                                showNotification('Error ending game.', 'error');
                            }
                        }
                    }

                    function checkDraw(board) {
                        const opponentMark = (currentPlayer === 'X') ? 'O' : 'X';
                        return getAvailableMoves(board).length === 0 &&
                               !checkWin(board, currentPlayer).won &&
                               !checkWin(board, opponentMark).won;
                    }
                    function checkEndCondition() {
                        const opponentMark = (currentPlayer === 'X') ? 'O' : 'X';
                        const winInfo = checkWin(boardState, currentPlayer);
                        const isDraw = checkDraw(boardState);
                        if (winInfo.won) {
                            endGame(false, winInfo.line, currentPlayer);
                            return true;
                        } else if (isDraw) {
                            endGame(true, [], 'Draw');
                            return true;
                        }
                        return false;
                    }
                    function highlightWinningCells(line) {
                        line.forEach(index => {
                            const cell = gameBoardContainer.querySelector(`[data-index='${index}']`);
                            if (cell) cell.classList.add('winning-cell');
                        });
                    }
                    async function endGame(isDraw, winningLine = [], winner = 'Draw', room = null) {
                        if (gameEndedNotified && !isMultiplayer) return;
                        gameEndedNotified = true;
                        isGameActive = false;
                        
                        clearInterval(turnTimer);
                        let heartsChange = 0;
                        let heartsChangeSymbol = '';
                        let heartsChangeClass = '';
                        let winStreakText = '';
                        
                        if (isDraw) {
                            playSound(drawSound, 'C4', '0.5');
                            if (!isMultiplayer) {
                                winStreak = 0;
                                if (gameSettings.gameMode === 'pva') {
                                    heartsChange = 0;
                                    heartsChangeSymbol = '0';
                                    heartsChangeClass = 'neutral';
                                }
                            } else {
                                winStreak = 0;
                                heartsChange = 0;
                                heartsChangeSymbol = '0';
                                heartsChangeClass = 'neutral';
                            }
                            winStreakText = `${winStreak} Wins`;
                        } else {
                            playSound(winSound, ['C5', 'E5', 'G5'], '0.4');
                            if (!isMultiplayer) {
                                if (winner === humanPlayer) {
                                    playerXScore++;
                                    winStreak++;
                                    if (gameSettings.gameMode === 'pva') {
                                        heartsChange = AI_WIN_REWARD;
                                    }
                                } else if (winner === aiPlayer) {
                                    playerOScore++;
                                    winStreak = 0;
                                    heartsChange = 0;
                                } else {
                                    if(winner === 'X') playerXScore++;
                                    if(winner === 'O') playerOScore++;
                                    winStreak = 0;
                                }
                            } else {
                                if (winner === myPlayerMark) {
                                    winStreak++;
                                    heartsChange = FTF_WIN_REWARD;
                                    if (myPlayerMark === 'X') playerXScore++; else playerOScore++;
                                } else {
                                    winStreak = 0;
                                    heartsChange = 0;
                                    if (myPlayerMark === 'X') playerOScore++; else playerXScore++;
                                }
                            }
                            if (winStreak > 0 && winStreak % WIN_STREAK_BONUS_COUNT === 0) {
                                heartsChange += WIN_STREAK_BONUS_AMOUNT;
                                showNotification(`+${WIN_STREAK_BONUS_AMOUNT} Hearts for ${winStreak}-Win Streak!`, 'success');
                            }
                            if (heartsChange > 0) {
                                heartsChangeSymbol = `+${heartsChange}`;
                                heartsChangeClass = 'positive';
                            } else {
                                heartsChangeSymbol = `${heartsChange}`;
                                heartsChangeClass = heartsChange < 0 ? 'negative' : 'neutral';
                            }
                        }
                        
                        currentHearts = Math.max(0, currentHearts + heartsChange);
                        playerXScoreEl.textContent = playerXScore;
                        playerOScoreEl.textContent = playerOScore;
                        winStreakText = `${winStreak} Wins`;
                        
                        await saveAllData();
                        updateHeartsUI();
                        
                        highlightWinningCells(winningLine);
                        
                        await new Promise(res => setTimeout(res, 1000));

                        if (!isMultiplayer) {
                            if (winner === 'X' || (winner === 'O' && gameSettings.gameMode === 'pva')) {
                                runConfetti();
                            }
                            const timeTaken = ((new Date() - gameStartTime) / 1000).toFixed(1);
                            gameOverMessage.textContent = isDraw ? "It's a Draw!" : (winner === 'X' ? `${player1Name.toUpperCase()} WINS!` : `${playerONameEl.textContent.toUpperCase()} WINS!`);
                            gameOverMessage.style.color = isDraw ? 'var(--text-light)' : (winner === 'X' ? 'var(--player-x-color)' : 'var(--player-o-color)');
                            statTime.textContent = `${timeTaken}s`;
                            statMoves.textContent = moveCount;
                            
                            if (gameSettings.gameMode === 'pva' && !isDraw) {
                                statHearts.textContent = (winner === 'X') ? `+${heartsChange} Hearts` : `0 Hearts`;
                                statHearts.className = `stat-value ${winner === 'X' ? 'positive' : 'neutral'}`;
                            } else {
                                statHearts.textContent = `${heartsChangeSymbol} Hearts`;
                                statHearts.className = `stat-value ${heartsChangeClass}`;
                            }
                            
                            statWinStreak.textContent = winStreakText;
                            statWinStreak.className = `stat-value ${winStreak > 0 ? 'positive' : 'neutral'}`;
                            
                            playAgainBtn.disabled = false;
                            
                            showScreen(gameOverModal);
                        } else {
                            showMultiplayerResult(room, heartsChangeSymbol, heartsChangeClass, winStreakText, winStreak > 0, room.status === 'abandoned');
                        }
                    }
                    function showMultiplayerResult(room, heartsSymbol, heartsClass, streakText, streakPositive, isAbandoned = false) {
                        mpResultTitle.textContent = room.winner === 'Draw' ? "IT'S A DRAW!" : (room.winner === myPlayerMark ? " YOU WON! " : "YOU LOST");
                        
                        if (isAbandoned && room.winner === myPlayerMark) {
                             mpResultTitle.textContent = " OPPONENT LEFT! ";
                        }
                        
                        resultNameX.textContent = mpPlayerXData.name.toUpperCase();
                        resultScoreX.textContent = playerXScore;
                        const iconX = document.createElement('i');
                        iconX.setAttribute('data-lucide', ICON_COSTS[mpPlayerXData.icon || 'x'][0]);
                        resultIconX.innerHTML = '';
                        resultIconX.appendChild(iconX);
                        resultNameO.textContent = mpPlayerOData.name.toUpperCase();
                        resultScoreO.textContent = playerOScore;
                        const iconO = document.createElement('i');
                        iconO.setAttribute('data-lucide', ICON_COSTS[mpPlayerOData.icon || 'circle'][0]);
                        resultIconO.innerHTML = '';
                        resultIconO.appendChild(iconO);
                        lucide.createIcons({ nodes: [resultIconX, resultIconO] });
                        mpStatHearts.textContent = `${heartsSymbol} Hearts`;
                        mpStatHearts.className = `stat-value ${heartsClass}`;
                        mpStatWinStreak.textContent = streakText;
                        mpStatWinStreak.className = `stat-value ${streakPositive ? 'positive' : 'neutral'}`;
                        
                        if (isAbandoned) {
                             rematchBtn.disabled = true;
                             rematchBtn.textContent = 'GAME OVER';
                             rematchStatusEl.textContent = 'Opponent left the match.';
                        } else {
                             playerXRematch = false;
                             playerORematch = false;
                             rematchBtn.disabled = false;
                             rematchBtn.textContent = 'REQUEST REMATCH';
                             rematchStatusEl.textContent = 'Challenge your opponent to a rematch!';
                        }
                        
                        showScreen(multiplayerResultModal);
                    }
                    rematchBtn.addEventListener('click', async () => {
                        if (!currentRoomId || !myPlayerMark) return;
                        rematchBtn.disabled = true;
                        rematchBtn.textContent = 'WAITING...';
                        playSound(rematchSound, 'C4', '0.1');
                        try {
                            const roomDocRef = getRoomDocRef(currentRoomId);
                            if (myPlayerMark === 'X') {
                                await updateDoc(roomDocRef, { rematchX: true });
                            } else {
                                await updateDoc(roomDocRef, { rematchO: true });
                            }
                        } catch (e) {
                            console.error("Error requesting rematch:", e);
                            showNotification('Failed to send rematch request.', 'error');
                            rematchBtn.disabled = false;
                        }
                    });
                    function updateRematchStatusUI() {
                         const myRematch = (myPlayerMark === 'X') ? playerXRematch : playerORematch;
                         const oppRematch = (myPlayerMark === 'X') ? playerORematch : playerXRematch;
                         if (myRematch) {
                              rematchBtn.textContent = 'REMATCH REQUESTED';
                              rematchBtn.disabled = true;
                         } else {
                             rematchBtn.textContent = 'REQUEST REMATCH';
                             rematchBtn.disabled = false;
                         }
                         if (oppRematch) {
                             rematchStatusEl.textContent = 'Opponent wants a rematch!';
                         } else {
                              rematchStatusEl.textContent = 'Awaiting opponent...';
                         }
                    }
                    function startRematchCountdown() {
                         clearInterval(rematchCountdownInterval);
                         let count = 3;
                         rematchStatusEl.textContent = `Rematch starting in ${count}...`;
                         rematchSound.triggerAttackRelease('E4', '0.1', Tone.now());
                         rematchCountdownInterval = setInterval(async () => {
                              count--;
                              if (count > 0) {
                                   rematchStatusEl.textContent = `Rematch starting in ${count}...`;
                                   rematchSound.triggerAttackRelease('E4', '0.1', Tone.now());
                              } else {
                                   clearInterval(rematchCountdownInterval);
                                   rematchCountdownInterval = null;
                                   rematchStatusEl.textContent = 'Starting...';
                                   if (myPlayerMark === 'X') {
                                        await startRematchRound();
                                   }
                              }
                         }, 1000);
                    }
                    async function startRematchRound() {
                         if (!currentRoomId) return;
                         try {
                              const newBoard = Array(boardSize * boardSize).fill(null);
                              const roomDocRef = getRoomDocRef(currentRoomId);
                              await updateDoc(roomDocRef, {
                                   status: 'playing',
                                   boardState: newBoard,
                                   currentPlayer: 'X',
                                   winner: null,
                                   winningLine: [],
                                   rematchX: false,
                                   rematchO: false,
                                   lastUpdated: Date.now()
                              });
                              
                              
                              
                              gameEndedNotified = false;
                              
                         } catch (e) {
                              console.error("Error starting rematch:", e);
                              showNotification('Failed to start rematch.', 'error');
                         }
                    }
                    function findAllWinningMoves(board, player) {
                        const threats = [];
                        const available = getAvailableMoves(board);
                        for (let index of available) {
                            board[index] = player;
                            if (checkWin(board, player).won) threats.push(index);
                            board[index] = null;
                        }
                        return threats;
                    }
                    function findWinningMove(board, player) {
                        const available = getAvailableMoves(board);
                        for (let index of available) {
                            board[index] = player;
                            if (checkWin(board, player).won) { board[index] = null; return index; }
                            board[index] = null;
                        }
                        return -1;
                    }
                    function findForkMove(board, player) {
                        const available = getAvailableMoves(board);
                        if (available.length < (board.length - 4)) return -1;
                        for (let index of available) {
                            board[index] = player;
                            const winningMoves = findAllWinningMoves(board, player);
                            board[index] = null;
                            
                            if (winningMoves.length >= 2) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function placeBlock(cell, index, player) {
                        boardState[index] = 'B';
                        const iconEl = document.createElement('i');
                        iconEl.setAttribute('data-lucide', 'shield-ban');
                        cell.innerHTML = '';
                        cell.appendChild(iconEl);
                        lucide.createIcons({ nodes: [iconEl] });
                        cell.classList.add('blocked', 'cell-bounce-in');
                        moveHistory.push({ index, player: player, type: 'block' });
                        if (player === 'X') blockerCountX--; else blockerCountO--;
                        playSound(clickSound, 'G4', '0.05');
                    }
                    function updateBlockerButton() {
                        const blockerButton = document.getElementById('blocker-powerup-btn-desktop');
                        const blockerButtonMobile = document.getElementById('blocker-powerup-btn-mobile');
                        if (gameSettings.gameVariant !== 'blocker' || !isGameActive) {
                            blockerButton.classList.add('hidden');
                            blockerButtonMobile.classList.add('hidden');
                            return;
                        }
                        const isPVA = gameSettings.gameMode === 'pva';
                        blockerButton.classList.toggle('hidden', !isPVA);
                        blockerPowerupBtnMobile.classList.toggle('hidden', !isPVA);
                        const disableButton = (currentPlayer === 'X' ? blockerCountX : blockerCountO) <= 0 || isBlockerActive;
                        blockerButton.disabled = disableButton;
                        blockerPowerupBtnMobile.disabled = disableButton;
                        blockerButton.classList.toggle('active', isBlockerActive);
                        blockerPowerupBtnMobile.classList.toggle('active', isBlockerActive);
                    }
                    [blockerPowerupBtn, blockerPowerupBtnMobile].forEach(btn => {
                        btn.addEventListener('click', () => {
                            if (!isGameActive || btn.disabled) return;
                            isBlockerActive = !isBlockerActive;
                            gameBoardContainer.classList.toggle('blocker-active', isBlockerActive);
                            
                            blockerPowerupBtn.classList.toggle('active', isBlockerActive);
                            blockerPowerupBtnMobile.classList.toggle('active', isBlockerActive);
                            if (!isBlockerActive) {
                                updateTurnStatus();
                            } else {
                                 playSound(clickSound, 'A4', '0.05');
                            }
                        });
                    });
                    
                    [aiTipBtn, aiTipBtnMobile].forEach(tipBtn => {
                        tipBtn.addEventListener('click', async () => {
                            
                            if (currentHearts < AI_TIP_COST || !isGameActive) {
                                if (currentHearts < AI_TIP_COST) {
                                    showNotification(`Need ${AI_TIP_COST} hearts for a tip!`, 'error');
                                    playSound(invalidSound, 'C3', '0.1');
                                }
                                return;
                            }
                            if (!((gameSettings.gameMode === 'pva' && currentPlayer === humanPlayer))) {
                                return;
                            }
                            
                            playSound(tipSound, ['G5', 'E6'], '0.1');
                            
                            currentHearts = Math.max(0, currentHearts - AI_TIP_COST);
                            await saveAllData();
                            updateHeartsUI();
                            
                            tipBtn.disabled = true;
                            if(currentHearts < AI_TIP_COST) {
                                aiTipBtn.disabled = true;
                                aiTipBtnMobile.disabled = true;
                            }
                            
                            const hintIndex = findBestMove(boardState.slice(), true);
                            if (hintIndex !== -1) {
                                const cell = gameBoardContainer.querySelector(`[data-index='${hintIndex}']`);
                                if (cell) {
                                    cell.classList.add('ai-tip-highlight');
                                    setTimeout(() => {
                                        cell.classList.remove('ai-tip-highlight');
                                    }, 300);
                                }
                            } else {
                                showNotification('No clear advantage found for this move.', 'info');
                            }
                        });
                    });
                     function aiMove() {
                         if (!isGameActive) return;
                         gameBoardContainer.classList.add('ai-thinking');
                         let finalMove = -1;
                         let calculatedMove = -1;
                         let useBlocker = false;
                         let blockIndex = -1;
                         const difficulty = gameSettings.aiDifficulty || 'medium';
                         const isAIFirstMove = (moveCount <= 1 && currentPlayer === aiPlayer);
                         if (gameSettings.gameVariant === 'blocker' && blockerCountO > 0 && difficulty !== 'easy') {
                             const aiWinMove = findWinningMove(boardState, aiPlayer);
                             if (aiWinMove == -1) {
                                 const humanThreats = findAllWinningMoves(boardState, humanPlayer);
                                 if (humanThreats.length > 1) {
                                     useBlocker = true;
                                     blockIndex = humanThreats[0];
                                 }
                                 else if (humanThreats.length === 0 && difficulty === 'hard' && Math.random() < 0.2 && moveCount > (boardSize * 1.5)) { 
                                     const available = getAvailableMoves(boardState);
                                     if (available.length > (boardSize * boardSize / 2)) {
                                         useBlocker = true;
                                         blockIndex = available[Math.floor(Math.random() * available.length)];
                                     }
                                 }
                             }
                         }
                         if (!useBlocker) {
                             if (difficulty === 'easy') {
                                 calculatedMove = findRandomMove(boardState);
                                 finalMove = calculatedMove;
                             } else if (difficulty === 'medium') {
                                 calculatedMove = findMediumMove(boardState, false);
                                 if (Math.random() < 0.20) {
                                      finalMove = findRandomMove(boardState);
                                 } else {
                                      finalMove = calculatedMove;
                                 }
                             } else if (difficulty === 'hard') { 
                                 calculatedMove = findBestMove(boardState, false);
                                 if (isAIFirstMove && boardSize === 3) {
                                     const centerIndex = Math.floor((boardSize * boardSize) / 2);
                                     if (calculatedMove === centerIndex && boardState[centerIndex] === null) {
                                         if (Math.random() < 0.3) {
                                             const corners = [0, boardSize - 1, boardSize * (boardSize - 1), boardSize * boardSize - 1];
                                             const availableCorners = corners.filter(index => boardState[index] === null);
                                             if (availableCorners.length > 0) {
                                                 finalMove = availableCorners[Math.floor(Math.random() * availableCorners.length)];
                                             } else { finalMove = calculatedMove; }
                                         } else { finalMove = calculatedMove; }
                                     } else { finalMove = calculatedMove; }
                                 }
                                 else if (Math.random() < 0.10 && !isAIFirstMove) {
                                      finalMove = findRandomMove(boardState);
                                 }
                                 else { finalMove = calculatedMove; }
                             } else if (difficulty === 'grandmaster') {
                                if (isAIFirstMove && boardSize === 3) {
                                    const centerIndex = Math.floor((boardSize * boardSize) / 2);
                                    if (boardState[centerIndex] === null && Math.random() < 0.70) {
                                        calculatedMove = centerIndex;
                                    } else {
                                        const corners = [0, boardSize - 1, boardSize * (boardSize - 1), boardSize * boardSize - 1];
                                        const availableCorners = corners.filter(index => boardState[index] === null);
                                        if (availableCorners.length > 0) {
                                            calculatedMove = availableCorners[Math.floor(Math.random() * availableCorners.length)];
                                        } else {
                                            calculatedMove = findBestMove(boardState, false);
                                        }
                                    }
                                } else {
                                    let winMove = findWinningMove(boardState, aiPlayer);
                                    if (winMove !== -1) {
                                        calculatedMove = winMove;
                                    } else {
                                        let blockMove = findWinningMove(boardState, humanPlayer);
                                        if (blockMove !== -1) {
                                            calculatedMove = blockMove;
                                        } else {
                                            let forkMove = findForkMove(boardState, aiPlayer);
                                            if (forkMove !== -1) {
                                                calculatedMove = forkMove;
                                            } else {
                                                let blockForkMove = findForkMove(boardState, humanPlayer);
                                                if (blockForkMove !== -1) {
                                                    calculatedMove = blockForkMove;
                                                } else {
                                                    calculatedMove = findBestMove(boardState, false);
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                if (Math.random() < 0.05 && !isAIFirstMove) {
                                    finalMove = findRandomMove(boardState);
                                } else {
                                    finalMove = calculatedMove;
                                }
                             }
                         }
                          if (finalMove === -1 && !useBlocker) {
                               const available = getAvailableMoves(boardState);
                               if (available.length > 0) finalMove = available[0];
                          }
                         const delay = Math.random() * 400 + 400;
                         setTimeout(() => {
                             if (!isGameActive) { gameBoardContainer.classList.remove('ai-thinking'); return; }
                             if (useBlocker) { 
                                 const aiCell = gameBoardContainer.querySelector(`[data-index='${blockIndex}']`);
                                 if (aiCell && boardState[blockIndex] === null) {
                                     placeBlock(aiCell, blockIndex, aiPlayer);
                                 } else {
                                     console.error(`AI tried to block invalid cell: ${blockIndex}. Making random move instead.`);
                                     const randomFallback = findRandomMove(boardState);
                                     if(randomFallback !== -1) {
                                          const fallbackCell = gameBoardContainer.querySelector(`[data-index='${randomFallback}']`);
                                          if (fallbackCell && boardState[randomFallback] === null) {
                                               placeMark(fallbackCell, randomFallback);
                                          }
                                     }
                                 }
                             } else if (finalMove !== -1) { 
                                 const aiCell = gameBoardContainer.querySelector(`[data-index='${finalMove}']`);
                                 if (aiCell && boardState[finalMove] === null) {
                                     placeMark(aiCell, finalMove);
                                 } else {
                                      console.error(`AI tried to play invalid move: ${finalMove}. Cell occupied or not found. Trying random.`);
                                       const randomFallback = findRandomMove(boardState);
                                       if (randomFallback !== -1) {
                                            const fallbackCell = gameBoardContainer.querySelector(`[data-index='${randomFallback}']`);
                                            if (fallbackCell && boardState[randomFallback] === null) {
                                                 console.warn(`AI using random fallback move: ${randomFallback}`);
                                                 placeMark(fallbackCell, randomFallback);
                                            }
                                       }
                                 }
                             } else {
                                  console.warn("AI (Stall Fix): 'finalMove' was -1. Playing random move.");
                                  const randomFallback = findRandomMove(boardState);
                                  if (randomFallback !== -1) {
                                       const fallbackCell = gameBoardContainer.querySelector(`[data-index='${randomFallback}']`);
                                       if (fallbackCell && boardState[randomFallback] === null) {
                                            placeMark(fallbackCell, randomFallback);
                                       }
                                  } else {
                                       console.error("AI ERROR: No move decided upon AND no random moves left.");
                                  }
                             }
                             gameBoardContainer.classList.remove('ai-thinking');
                             if (!checkEndCondition()) {
                                 switchPlayer();
                             }
                         }, delay);
                     }
                    function findRandomMove(board) {
                        const available = getAvailableMoves(board);
                        if (available.length === 0) return -1;
                        return available[Math.floor(Math.random() * available.length)];
                    }
                    function findMediumMove(board, forHuman) {
                        const player = forHuman ? humanPlayer : aiPlayer;
                        const opponent = forHuman ? aiPlayer : humanPlayer;
                        const available = getAvailableMoves(board);
                        if (available.length === 0) return -1;
                        let winMove = findWinningMove(board, player);
                        if(winMove !== -1) return winMove;
                        let blockMove = findWinningMove(board, opponent);
                        if(blockMove !== -1) return blockMove;
                        return available[Math.floor(Math.random() * available.length)];
                    }
                    function findBestMove(board, forHuman) {
                        let bestScore = -Infinity;
                        let move = -1;
                        const player = forHuman ? humanPlayer : aiPlayer;
                        const opponent = forHuman ? aiPlayer : humanPlayer;
                        const availableMoves = getAvailableMoves(board);
                        if (availableMoves.length === 0) return -1;
                        availableMoves.forEach(index => {
                            board[index] = player;
                            let score = minimax(board, 0, false, -Infinity, Infinity, forHuman);
                            board[index] = null;
                            if (score > bestScore) {
                                bestScore = score;
                                move = index;
                            }
                            else if (score === bestScore && Math.random() < 0.3) {
                                 move = index;
                            }
                        });
                        if (move === -1) {
                            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
                        }
                        return move;
                    }
                    function minimax(board, depth, isMaximizing, alpha, beta, forHuman) {
                        const player = forHuman ? humanPlayer : aiPlayer;
                        const opponent = forHuman ? aiPlayer : humanPlayer;
                        const winScore = 100 - depth; const loseScore = depth - 100;
                         if (checkWin(board, player).won) return winScore;
                         if (checkWin(board, opponent).won) return loseScore;
                         if (checkDraw(board)) return 0;
                        
                        const maxDepth = MINIMAX_DEPTHS[boardSize] || 3;
                        
                        if (depth >= maxDepth) return 0;
                        const availableMoves = getAvailableMoves(board);
                        if (availableMoves.length === 0) return 0;
                        if (isMaximizing) {
                            let bestScore = -Infinity;
                            for (const index of availableMoves) {
                                board[index] = player;
                                bestScore = Math.max(bestScore, minimax(board, depth + 1, false, alpha, beta, forHuman));
                                board[index] = null;
                                alpha = Math.max(alpha, bestScore);
                                if (beta <= alpha) break;
                            }
                            return bestScore;
                        } else {
                            let bestScore = Infinity;
                            for (const index of availableMoves) {
                                board[index] = opponent;
                                bestScore = Math.min(bestScore, minimax(board, depth + 1, true, alpha, beta, forHuman));
                                board[index] = null;
                                beta = Math.min(beta, bestScore);
                                if (beta <= alpha) break;
                            }
                            return bestScore;
                        }
                    }
                    function getAvailableMoves(board) {
                         if (!Array.isArray(board)) {
                              console.error("getAvailableMoves received non-array board:", board);
                              return [];
                         }
                        const moves = [];
                        board.forEach((cell, index) => { if (cell === null) moves.push(index); });
                        return moves;
                    }
                    function runConfetti() {
                         confettiContainer.innerHTML = '';
                         for (let i = 0; i < 100; i++) {
                             const confetti = document.createElement('div');
                             confetti.className = 'confetti';
                             confetti.style.left = `${Math.random() * 100}%`;
                             confetti.style.animationDelay = `${Math.random() * 2}s`;
                             confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
                             confettiContainer.appendChild(confetti);
                         }
                    }
                    const gameListItems = document.querySelectorAll('.game-list-item');
                    gameListItems.forEach(item => {
                        item.addEventListener('mousemove', (e) => {
                            if (item.classList.contains('disabled')) return;
                            const rect = item.getBoundingClientRect();
                            const x = e.clientX - rect.left - rect.width / 2;
                            const y = e.clientY - rect.top - rect.height / 2;
                            const rotateX = -y / (rect.height / 2) * 7; 
                            const rotateY = x / (rect.width / 2) * 7; 
                            item.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(1.02)`;
                            item.style.transition = "transform 0.1s ease-out";
                        });
                    });
                    settingsBtn.addEventListener('click', () => { 
                      
                        
                        if (confettiContainer) {
                            confettiContainer.innerHTML = '';
                        }
                        
                        showScreen(settingsModal); 
                    });
                    settingsCloseBtn.addEventListener('click', () => { hideScreen(settingsModal, () => showScreen(gameScreen)); });
                    globalSettingsBtn.addEventListener('click', () => { 
                        playerNameInput.value = player1Name;
                        showScreen(globalSettingsModal); 
                        const purchaseBtnIcon = document.querySelector('#purchase-license-btn i');
                        const logoutBtnIcon = document.querySelector('#logout-btn i');
                        
                        const nodesToCreate = [];
                        if (purchaseBtnIcon) nodesToCreate.push(purchaseBtnIcon);
                        if (logoutBtnIcon) nodesToCreate.push(logoutBtnIcon);
                        
                        if (nodesToCreate.length > 0) {
                            lucide.createIcons({ nodes: nodesToCreate });
                        }
                    });
                    globalSettingsCloseBtn.addEventListener('click', () => { hideScreen(globalSettingsModal, () => showScreen(arcadeNexusScreen)); }); 
                    [soundToggleBtn, inGameSoundToggleBtn].forEach(btn => {
                        btn.addEventListener('click', () => {
                            setSoundState(!isMuted);
                        });
                    });
                    mainMenuCloseBtn.addEventListener('click', () => { hideScreen(mainMenuScreen, () => showScreen(arcadeNexusScreen)); });
                    startGameBtn.addEventListener('click', () => {
                         
                         gameSettings.gameMode = document.querySelector('input[name="game-mode"]:checked').value;
                         if (gameSettings.gameMode === 'pva' && currentHearts < Math.abs(AI_LOSE_COST)) {
                              showNotification(`Not enough hearts! Need ${Math.abs(AI_LOSE_COST)} heart to play vs AI.`, 'error');
                              return;
                         }
                         
                         gameEndedNotified = false;
                         
                         gameSettings.boardSize = parseInt(document.querySelector('input[name="board-size"]:checked').value);
                         gameSettings.aiDifficulty = document.querySelector('input[name="ai-difficulty"]:checked')?.value || 'medium';
                         gameSettings.gameVariant = document.querySelector('input[name="game-variant"]:checked').value;
                         
                         if(gameSettings.gameMode === 'pva' && !isMultiplayer) {
                             currentHearts = Math.max(0, currentHearts + AI_LOSE_COST);
                             updateHeartsUI();
                             saveAllData(); 
                         }
                         hideScreen(mainMenuScreen, () => showScreen(gameScreen));
                         initializeGame();
                         saveSettings();
                    });
                    gameModeRadios.forEach(radio => {
                        radio.addEventListener('change', () => {
                            const isPVA = radio.value === 'pva';
                            aiDifficultySection.classList.toggle('hidden', !isPVA);
                            
                            const showBlocker = document.querySelector('input[name="game-variant"]:checked').value === 'blocker';
                            blockerPowerupBtn.classList.toggle('hidden', !showBlocker || !isPVA);
                            blockerPowerupBtnMobile.classList.toggle('hidden', !showBlocker || !isPVA);
                            
                        });
                    });
                    
                    
                    playAgainBtn.addEventListener('click', () => {
                         if (playAgainBtn.disabled) return;
                         playAgainBtn.disabled = true;

                         hideScreen(gameOverModal, () => { 
                             resetBoardVisuals(); 
                             initializeGame(); 
                             showScreen(gameScreen);
                             playAgainBtn.disabled = false;
                         });
                    });
                    
                    
                    [backToMenuBtn, mpBackToMenuBtn, backToMainMenuBtn].forEach(btn => { 
                        btn.addEventListener('click', async () => {
                             
                         
                             const actionAfterHiding = () => {
                                 if (isMultiplayer) {
                                 
                                      // 1. BUG FIX: User ko foran main menu dikhao. Intezaar mat karwao.
                                      showScreen(arcadeNexusScreen); 
                                      
                                      // 2. Ab saara Firebase cleanup background mein karo.
                                      (async () => {
                                           await cancelRoom();
                                           
                                           // 3. Local state ko manually reset karo (bina screen change kiye)
                                           if (unsubscribeRoomListener) unsubscribeRoomListener();
                                           if (unsubscribeChatListener) unsubscribeChatListener(); 
                                           if (unsubscribeOpponentPresence) { 
                                              unsubscribeOpponentPresence();
                                              unsubscribeOpponentPresence = null;
                                           }
                                           
                                           if (rtdb && userProfile.uid) {
                                               const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_FALLBACK_CONFIG.projectId;
                                               const rtdbAppId = appId.replace(/[.#$\[\]]/g, '_'); 
                                               const userStatusRef = ref(rtdb, `artifacts/${rtdbAppId}/public/data/presence/${userProfile.uid}`);
                                               
                                               await set(userStatusRef, false); 
                                               setupPresence(userProfile.uid);
                                           }
                                           
                                           clearInterval(rematchCountdownInterval); 
                                           clearInterval(rewardTimerInterval); 
                                           isMultiplayer = false;
                                           playerXRematch = false;
                                           playerORematch = false;
                                           gameStartedNotified = false; 
                                           lastKnownStateFingerprint = null; 
                                           isChatPanelOpen = false; 
                                           multiplayerChatPanel.classList.add('hidden'); 
                                      })();
                                      
                                 } else {
                                      showScreen(arcadeNexusScreen); 
                                 }
                             };
                             
                             let visibleModal = null;
                             if (!settingsModal.classList.contains('hidden')) visibleModal = settingsModal;
                             else if (!gameOverModal.classList.contains('hidden')) visibleModal = gameOverModal;
                             else if (!multiplayerResultModal.classList.contains('hidden')) visibleModal = multiplayerResultModal;

                            
                             hideScreen(gameScreen); 

                             if (visibleModal) {
                                 hideScreen(visibleModal, actionAfterHiding);
                             } else {
                              
                                 setTimeout(actionAfterHiding, 300);
                             }
                        });
                    });
                    
                    
                });
            } catch (error) {
                console.error("Critical error during initialization:", error);
                 document.body.innerHTML = `<div style="color: red; padding: 20px;">
                     <h1>Initialization Error</h1><p>Something went wrong. Check console.</p><pre>${error.stack || error}</pre>
                 </div>`;
            }
        </script>
    
    </body>
    
    </html>